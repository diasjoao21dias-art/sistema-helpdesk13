{"file_contents":{"LIMPAR_BANCO.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nSCRIPT PARA LIMPAR BANCO DE DADOS - USAR EM NOVA M√ÅQUINA\nSistema Olivion - Preparar banco para nova instala√ß√£o\n\"\"\"\n\nimport sqlite3\nimport os\nfrom datetime import datetime\n\ndef limpar_banco():\n    \"\"\"\n    Remove dados antigos do banco SQLite para uso em nova m√°quina\n    \"\"\"\n    db_path = \"sistema_os.db\"\n    \n    if not os.path.exists(db_path):\n        print(\"‚ùå Arquivo sistema_os.db n√£o encontrado!\")\n        print(\"   Execute este script na pasta TesteProgram\")\n        return False\n    \n    try:\n        # Conectar ao banco\n        conn = sqlite3.connect(db_path)\n        cursor = conn.cursor()\n        \n        print(\"üßπ Limpando banco de dados para nova m√°quina...\")\n        \n        # 1. LIMPAR SISTEMA DE LICEN√áAS (principal problema)\n        print(\"   ‚Üí Removendo licen√ßas antigas...\")\n        cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name='system_license'\")\n        if cursor.fetchone():\n            cursor.execute(\"DELETE FROM system_license\")\n            print(\"     ‚úÖ Licen√ßas removidas\")\n        else:\n            print(\"     ‚ö™ Tabela system_license n√£o existe\")\n        \n        # 2. LIMPAR CHAMADOS DE TESTE (se tabela existir)\n        print(\"   ‚Üí Verificando chamados de teste...\")\n        cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name='chamado'\")\n        if cursor.fetchone():\n            cursor.execute(\"DELETE FROM chamado\")\n            print(\"     ‚úÖ Chamados removidos\")\n        else:\n            print(\"     ‚ö™ Tabela chamado n√£o existe\")\n        \n        # 3. LIMPAR LOGS DE ATIVIDADE (se tabelas existirem)\n        print(\"   ‚Üí Removendo logs antigos...\")\n        for table in ['audit_log', 'system_activity']:\n            cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name=?\", (table,))\n            if cursor.fetchone():\n                cursor.execute(f\"DELETE FROM {table}\")\n                print(f\"     ‚úÖ {table} limpa\")\n            else:\n                print(f\"     ‚ö™ Tabela {table} n√£o existe\")\n        \n        # 4. MANTER APENAS O ADMIN PADR√ÉO (se tabela user existir)\n        print(\"   ‚Üí Mantendo apenas usu√°rio admin...\")\n        cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name='user'\")\n        if cursor.fetchone():\n            cursor.execute(\"DELETE FROM user WHERE username != 'admin'\")\n            print(\"     ‚úÖ Usu√°rios extras removidos\")\n        else:\n            print(\"     ‚ö™ Tabela user n√£o existe\")\n        \n        # 5. RESETAR CONFIGURA√á√ïES DO SISTEMA\n        print(\"   ‚Üí Resetando configura√ß√µes...\")\n        cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name='license_store'\")\n        if cursor.fetchone():\n            cursor.execute(\"DELETE FROM license_store\")\n            print(\"     ‚úÖ Configura√ß√µes resetadas\")\n        else:\n            print(\"     ‚ö™ Tabela license_store n√£o existe\")\n        \n        # 6. GARANTIR PAP√âIS PADR√ÉO (CRITICAL - Para sistema de pap√©is funcionar)\n        print(\"   ‚Üí Verificando pap√©is padr√£o do sistema...\")\n        \n        cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name='role'\")\n        if cursor.fetchone():\n            # Verificar se existem pap√©is padr√£o, se n√£o criar\n            papeis_padrao = [\n                ('admin', 'Administrador', 'Acesso total ao sistema', '[\"manage_users\", \"manage_sectors\", \"manage_roles\", \"view_all\", \"edit_all\", \"delete_all\", \"close_tickets\", \"create_tickets\", \"view_reports\", \"manage_settings\"]'),\n                ('operador', 'Operador', 'Operador de setor', '[\"view_sector\", \"edit_sector\", \"close_tickets\", \"create_tickets\", \"view_reports\"]'),\n                ('usuario', 'Usu√°rio', 'Usu√°rio b√°sico', '[\"view_own\", \"create_tickets\"]')\n            ]\n            \n            for name, display_name, description, permissions in papeis_padrao:\n                cursor.execute(\"SELECT COUNT(*) FROM role WHERE name = ?\", (name,))\n                if cursor.fetchone()[0] == 0:\n                    cursor.execute(\"\"\"\n                        INSERT INTO role (name, display_name, description, permissions, active, created_at, updated_at) \n                        VALUES (?, ?, ?, ?, 1, datetime('now'), datetime('now'))\n                    \"\"\", (name, display_name, description, permissions))\n                    print(f\"     ‚úÖ Papel '{display_name}' criado\")\n                else:\n                    print(f\"     ‚ö™ Papel '{display_name}' j√° existe\")\n        else:\n            print(\"     ‚ö™ Tabela role n√£o existe - execute o sistema primeiro para criar tabelas\")\n        \n        # Confirmar mudan√ßas\n        conn.commit()\n        \n        # Mostrar estat√≠sticas\n        cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name='user'\")\n        if cursor.fetchone():\n            cursor.execute(\"SELECT COUNT(*) FROM user\")\n            users = cursor.fetchone()[0]\n        else:\n            users = 0\n        \n        cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name='system_license'\")\n        if cursor.fetchone():\n            cursor.execute(\"SELECT COUNT(*) FROM system_license\")\n            licenses = cursor.fetchone()[0]\n        else:\n            licenses = 0\n        \n        cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name='chamado'\")\n        if cursor.fetchone():\n            cursor.execute(\"SELECT COUNT(*) FROM chamado\")\n            tickets = cursor.fetchone()[0]\n        else:\n            tickets = 0\n        \n        cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name='role'\")\n        if cursor.fetchone():\n            cursor.execute(\"SELECT COUNT(*) FROM role\")\n            roles = cursor.fetchone()[0]\n        else:\n            roles = 0\n        \n        conn.close()\n        \n        print(\"\\n‚úÖ BANCO LIMPO COM SUCESSO!\")\n        print(f\"   üë• Usu√°rios: {users} (admin mantido)\")\n        print(f\"   üîê Licen√ßas: {licenses} (limpas)\")\n        print(f\"   üìã Chamados: {tickets} (limpas)\")\n        print(f\"   üëî Pap√©is: {roles} (padr√£o garantidos)\")\n        print(\"\\nüéØ Agora execute: python USAR.py\")\n        print(\"   Login: admin / admin\")\n        \n        return True\n        \n    except Exception as e:\n        print(f\"‚ùå Erro ao limpar banco: {e}\")\n        return False\n\nif __name__ == \"__main__\":\n    print(\"=\" * 60)\n    print(\"    LIMPEZA DE BANCO - SISTEMA OLIVION\")\n    print(\"=\" * 60)\n    print(\"‚ö†Ô∏è  Este script vai REMOVER:\")\n    print(\"   - Todas as licen√ßas antigas\")\n    print(\"   - Todos os chamados de teste\") \n    print(\"   - Todos os logs antigos\")\n    print(\"   - Usu√°rios extras (mant√©m admin)\")\n    print(\"   ‚úÖ MANT√âM: Pap√©is/grupos e suas permiss√µes\")\n    print(\"=\" * 60)\n    print(\"üîÑ Executando limpeza automaticamente...\")\n    \n    if limpar_banco():\n        print(\"\\nüöÄ Sistema pronto para usar na sua m√°quina!\")\n    else:\n        print(\"\\nüí° Verifique se est√° na pasta correta (TesteProgram)\")","size_bytes":7045},"USAR.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nüöÄ SISTEMA OLIVION - SQLite Funcionando\nExecute este arquivo para usar o sistema\n\"\"\"\n\nimport subprocess\nimport sys\n\nprint(\"=\" * 50)\nprint(\"üöÄ SISTEMA OLIVION - SQLITE\")\nprint(\"=\" * 50)\nprint(\"‚úÖ SQLite sempre funcionando\")\nprint(\"üåê Sistema na porta 5000\")  \nprint(\"üë§ Login: admin\")\nprint(\"üîê Senha: admin\")\nprint(\"=\" * 50)\nprint()\n\ntry:\n    subprocess.run([sys.executable, \"app.py\"])\nexcept KeyboardInterrupt:\n    print(\"\\n‚úÖ Sistema encerrado.\")\nexcept Exception as e:\n    print(f\"\\n‚ùå Erro: {e}\")\n    input(\"Pressione Enter...\")","size_bytes":572},"activity_logger.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nSistema de Log de Atividades - Sistema Olivion\nRegistra todas as atividades importantes do sistema para auditoria\n\"\"\"\n\nimport sqlite3\nimport json\nimport logging\nfrom logging.handlers import RotatingFileHandler\nfrom datetime import datetime, timedelta\nfrom typing import Dict, List, Optional\nfrom flask import request, session\nimport os\nimport sys\n\nclass ColoredFormatter(logging.Formatter):\n    \"\"\"Formatador colorido para logs no console\"\"\"\n    \n    # Cores ANSI\n    COLORS = {\n        'DEBUG': '\\033[36m',     # Cyan\n        'INFO': '\\033[32m',      # Green\n        'WARNING': '\\033[33m',   # Yellow\n        'ERROR': '\\033[31m',     # Red\n        'CRITICAL': '\\033[35m',  # Magenta\n        'RESET': '\\033[0m'       # Reset\n    }\n    \n    def format(self, record):\n        # Adicionar cor para o n√≠vel de log\n        levelname = record.levelname\n        if levelname in self.COLORS:\n            record.levelname_color = self.COLORS[levelname]\n        else:\n            record.levelname_color = ''\n        record.reset = self.COLORS['RESET']\n        \n        return super().format(record)\n\nclass ActivityLogger:\n    def __init__(self, db_path: str = \"sistema_os.db\"):\n        self.db_path = db_path\n        self.setup_logging()\n        self.create_activity_table()\n    \n    def setup_logging(self):\n        \"\"\"Configurar logging estruturado com rota√ß√£o e formata√ß√£o colorida\"\"\"\n        # Formatter with colors for console\n        console_formatter = ColoredFormatter(\n            '%(asctime)s - %(levelname_color)s%(levelname)s%(reset)s - %(name)s - %(message)s',\n            datefmt='%Y-%m-%d %H:%M:%S'\n        )\n        \n        # Formatter for file (no colors)\n        file_formatter = logging.Formatter(\n            '%(asctime)s - %(levelname)s - %(name)s - %(message)s',\n            datefmt='%Y-%m-%d %H:%M:%S'\n        )\n        \n        # Create logs directory first\n        os.makedirs('logs', exist_ok=True)\n        \n        # Rotating file handler (max 10MB, keep 5 backups)\n        file_handler = RotatingFileHandler(\n            'logs/activity.log', \n            maxBytes=10*1024*1024, \n            backupCount=5,\n            encoding='utf-8'\n        )\n        file_handler.setLevel(logging.DEBUG)\n        file_handler.setFormatter(file_formatter)\n        \n        # Console handler with colors\n        console_handler = logging.StreamHandler(sys.stdout)\n        console_handler.setLevel(logging.INFO)\n        console_handler.setFormatter(console_formatter)\n        \n        # Configure logger\n        self.logger = logging.getLogger('ActivityLogger')\n        self.logger.setLevel(logging.DEBUG)\n        self.logger.handlers.clear()  # Clear any existing handlers\n        self.logger.addHandler(file_handler)\n        self.logger.addHandler(console_handler)\n        \n        # Prevent propagation to root logger\n        self.logger.propagate = False\n    \n    def create_activity_table(self):\n        \"\"\"Criar tabela de atividades se n√£o existir\"\"\"\n        try:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                CREATE TABLE IF NOT EXISTS system_activity (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,\n                    user_id INTEGER,\n                    username TEXT,\n                    action_type TEXT NOT NULL,\n                    action_description TEXT NOT NULL,\n                    details TEXT,\n                    ip_address TEXT,\n                    user_agent TEXT,\n                    session_id TEXT,\n                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n                )\n            ''')\n            \n            # Criar √≠ndices para melhor performance\n            cursor.execute('CREATE INDEX IF NOT EXISTS idx_activity_timestamp ON system_activity(timestamp)')\n            cursor.execute('CREATE INDEX IF NOT EXISTS idx_activity_user ON system_activity(user_id)')\n            cursor.execute('CREATE INDEX IF NOT EXISTS idx_activity_type ON system_activity(action_type)')\n            \n            conn.commit()\n            conn.close()\n            \n        except Exception as e:\n            self.logger.error(f\"Erro ao criar tabela de atividades: {e}\")\n    \n    def debug(self, message: str, **kwargs):\n        \"\"\"Log mensagem de debug\"\"\"\n        self.logger.debug(message, **kwargs)\n    \n    def info(self, message: str, **kwargs):\n        \"\"\"Log mensagem de informa√ß√£o\"\"\"\n        self.logger.info(message, **kwargs)\n    \n    def warning(self, message: str, **kwargs):\n        \"\"\"Log mensagem de aviso\"\"\"\n        self.logger.warning(message, **kwargs)\n    \n    def error(self, message: str, **kwargs):\n        \"\"\"Log mensagem de erro\"\"\"\n        self.logger.error(message, **kwargs)\n    \n    def critical(self, message: str, **kwargs):\n        \"\"\"Log mensagem cr√≠tica\"\"\"\n        self.logger.critical(message, **kwargs)\n    \n    def log_activity(self, action_type: str, action_description: str, \n                    user_id: Optional[int] = None, username: Optional[str] = None,\n                    details: Optional[Dict] = None):\n        \"\"\"Registrar uma atividade do sistema\"\"\"\n        try:\n            # Obter informa√ß√µes da requisi√ß√£o atual se dispon√≠vel\n            ip_address = self.get_client_ip()\n            user_agent = self.get_user_agent()\n            session_id = self.get_session_id()\n            \n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                INSERT INTO system_activity \n                (user_id, username, action_type, action_description, details, \n                 ip_address, user_agent, session_id)\n                VALUES (?, ?, ?, ?, ?, ?, ?, ?)\n            ''', (\n                user_id,\n                username,\n                action_type,\n                action_description,\n                json.dumps(details) if details else None,\n                ip_address,\n                user_agent,\n                session_id\n            ))\n            \n            conn.commit()\n            conn.close()\n            \n            self.logger.info(f\"Atividade registrada: {action_type} - {action_description} - Usu√°rio: {username}\")\n            \n        except Exception as e:\n            self.logger.error(f\"Erro ao registrar atividade: {e}\")\n    \n    def get_client_ip(self) -> str:\n        \"\"\"Obter IP do cliente\"\"\"\n        try:\n            if request:\n                return request.environ.get('HTTP_X_FORWARDED_FOR', \n                                         request.environ.get('REMOTE_ADDR', 'unknown'))\n            return 'system'\n        except:\n            return 'system'\n    \n    def get_user_agent(self) -> str:\n        \"\"\"Obter User Agent do cliente\"\"\"\n        try:\n            if request:\n                return request.environ.get('HTTP_USER_AGENT', 'unknown')[:500]\n            return 'system'\n        except:\n            return 'system'\n    \n    def get_session_id(self) -> str:\n        \"\"\"Obter ID da sess√£o\"\"\"\n        try:\n            if session:\n                return str(session.get('_id', 'no_session'))[:50]\n            return 'no_session'\n        except:\n            return 'no_session'\n    \n    def get_recent_activities(self, limit: int = 50) -> List[Dict]:\n        \"\"\"Obter atividades recentes\"\"\"\n        try:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                SELECT timestamp, username, action_type, action_description, \n                       details, ip_address\n                FROM system_activity \n                ORDER BY timestamp DESC \n                LIMIT ?\n            ''', (limit,))\n            \n            activities = []\n            for row in cursor.fetchall():\n                timestamp, username, action_type, description, details, ip = row\n                \n                # Determinar cor do tipo de a√ß√£o\n                type_color = self.get_action_color(action_type)\n                \n                activities.append({\n                    'timestamp': self.format_timestamp(timestamp),\n                    'user': username or 'Sistema',\n                    'action': action_type,\n                    'details': description,\n                    'ip': ip or 'N/A',\n                    'type_color': type_color\n                })\n            \n            conn.close()\n            return activities\n            \n        except Exception as e:\n            self.logger.error(f\"Erro ao obter atividades recentes: {e}\")\n            return []\n    \n    def get_action_color(self, action_type: str) -> str:\n        \"\"\"Determinar cor para tipo de a√ß√£o\"\"\"\n        color_map = {\n            'LOGIN': 'success',\n            'LOGOUT': 'secondary',\n            'CREATE': 'primary',\n            'UPDATE': 'warning',\n            'DELETE': 'danger',\n            'ADMIN': 'info',\n            'SYSTEM': 'dark',\n            'ERROR': 'danger',\n            'SECURITY': 'warning'\n        }\n        return color_map.get(action_type.upper(), 'secondary')\n    \n    def format_timestamp(self, timestamp_str: str) -> str:\n        \"\"\"Formatar timestamp para exibi√ß√£o\"\"\"\n        try:\n            dt = datetime.strptime(timestamp_str, '%Y-%m-%d %H:%M:%S')\n            return dt.strftime('%d/%m %H:%M')\n        except:\n            return timestamp_str\n    \n    def get_activity_stats(self) -> Dict:\n        \"\"\"Obter estat√≠sticas de atividades\"\"\"\n        try:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            # Atividades das √∫ltimas 24 horas\n            yesterday = datetime.now() - timedelta(days=1)\n            cursor.execute('''\n                SELECT COUNT(*) FROM system_activity \n                WHERE timestamp > ?\n            ''', (yesterday.strftime('%Y-%m-%d %H:%M:%S'),))\n            \n            last_24h = cursor.fetchone()[0]\n            \n            # Total de atividades\n            cursor.execute('SELECT COUNT(*) FROM system_activity')\n            total = cursor.fetchone()[0]\n            \n            # Atividades por tipo nas √∫ltimas 24h\n            cursor.execute('''\n                SELECT action_type, COUNT(*) \n                FROM system_activity \n                WHERE timestamp > ?\n                GROUP BY action_type\n                ORDER BY COUNT(*) DESC\n            ''', (yesterday.strftime('%Y-%m-%d %H:%M:%S'),))\n            \n            by_type = dict(cursor.fetchall())\n            \n            conn.close()\n            \n            return {\n                'last_24h': last_24h,\n                'total': total,\n                'by_type': by_type\n            }\n            \n        except Exception as e:\n            self.logger.error(f\"Erro ao obter estat√≠sticas: {e}\")\n            return {'last_24h': 0, 'total': 0, 'by_type': {}}\n    \n    def cleanup_old_activities(self, days_to_keep: int = 90):\n        \"\"\"Limpar atividades antigas para manter performance\"\"\"\n        try:\n            cutoff_date = datetime.now() - timedelta(days=days_to_keep)\n            \n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                DELETE FROM system_activity \n                WHERE timestamp < ?\n            ''', (cutoff_date.strftime('%Y-%m-%d %H:%M:%S'),))\n            \n            deleted_count = cursor.rowcount\n            conn.commit()\n            conn.close()\n            \n            self.logger.info(f\"Limpeza de atividades: {deleted_count} registros removidos\")\n            return deleted_count\n            \n        except Exception as e:\n            self.logger.error(f\"Erro na limpeza de atividades: {e}\")\n            return 0\n\n# Inst√¢ncia global do logger (path padr√£o, pode ser sobrescrito via init_app)\nactivity_logger = ActivityLogger(db_path=\"instance/sistema_os.db\")\n\ndef create_module_logger(module_name: str, log_level=logging.INFO) -> logging.Logger:\n    \"\"\"\n    Criar logger espec√≠fico para m√≥dulo com formata√ß√£o consistente\n    \n    Args:\n        module_name: Nome do m√≥dulo (ex: 'Authentication', 'Backup', 'Reports')\n        log_level: N√≠vel de log (DEBUG, INFO, WARNING, ERROR, CRITICAL)\n    \n    Returns:\n        Logger configurado para o m√≥dulo\n    \"\"\"\n    # Formatador colorido para console\n    console_formatter = ColoredFormatter(\n        f'%(asctime)s - %(levelname_color)s%(levelname)s%(reset)s - {module_name} - %(message)s',\n        datefmt='%Y-%m-%d %H:%M:%S'\n    )\n    \n    # Formatador para arquivo\n    file_formatter = logging.Formatter(\n        f'%(asctime)s - %(levelname)s - {module_name} - %(message)s',\n        datefmt='%Y-%m-%d %H:%M:%S'\n    )\n    \n    # Criar diret√≥rio de logs\n    os.makedirs('logs', exist_ok=True)\n    \n    # Handler para arquivo com rota√ß√£o\n    log_filename = f'logs/{module_name.lower().replace(\" \", \"_\")}.log'\n    file_handler = RotatingFileHandler(\n        log_filename,\n        maxBytes=10*1024*1024,  # 10MB\n        backupCount=3,\n        encoding='utf-8'\n    )\n    file_handler.setLevel(logging.DEBUG)\n    file_handler.setFormatter(file_formatter)\n    \n    # Handler para console\n    console_handler = logging.StreamHandler(sys.stdout)\n    console_handler.setLevel(log_level)\n    console_handler.setFormatter(console_formatter)\n    \n    # Configurar logger\n    logger = logging.getLogger(module_name)\n    logger.setLevel(logging.DEBUG)\n    logger.handlers.clear()\n    logger.addHandler(file_handler)\n    logger.addHandler(console_handler)\n    logger.propagate = False\n    \n    return logger\n\n# Fun√ß√µes de conveni√™ncia para uso f√°cil\ndef log_login(user_id: int, username: str):\n    \"\"\"Registrar login de usu√°rio\"\"\"\n    activity_logger.log_activity('LOGIN', f'Usu√°rio {username} fez login', user_id, username)\n\ndef log_logout(user_id: int, username: str):\n    \"\"\"Registrar logout de usu√°rio\"\"\"\n    activity_logger.log_activity('LOGOUT', f'Usu√°rio {username} fez logout', user_id, username)\n\ndef log_ticket_create(user_id: int, username: str, ticket_id: int, title: str):\n    \"\"\"Registrar cria√ß√£o de chamado\"\"\"\n    activity_logger.log_activity('CREATE', f'Criou chamado #{ticket_id}: {title}', \n                                user_id, username, {'ticket_id': ticket_id, 'title': title})\n\ndef log_admin_action(user_id: int, username: str, action: str, details: Optional[Dict] = None):\n    \"\"\"Registrar a√ß√£o administrativa\"\"\"\n    activity_logger.log_activity('ADMIN', action, user_id, username, details)\n\ndef log_system_event(event: str, details: Optional[Dict] = None):\n    \"\"\"Registrar evento do sistema\"\"\"\n    activity_logger.log_activity('SYSTEM', event, details=details)\n\ndef log_security_event(event: str, details: Optional[Dict] = None):\n    \"\"\"Registrar evento de seguran√ßa\"\"\"\n    activity_logger.log_activity('SECURITY', event, details=details)","size_bytes":14913},"admin_dashboard.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nDashboard Administrativo - Sistema Olivion\nMonitoramento de sa√∫de do banco e m√©tricas de seguran√ßa\n\"\"\"\n\nfrom flask import Blueprint, render_template, jsonify, request\nfrom functools import wraps\nimport json\n\n# Imports dos sistemas de seguran√ßa\ntry:\n    from backup_manager import BackupManager\n    from database_safety import DatabaseSafety\n    backup_manager = BackupManager(\"sistema_os.db\")\n    db_safety = DatabaseSafety(\"sistema_os.db\")\nexcept ImportError:\n    backup_manager = None\n    db_safety = None\n\nadmin_bp = Blueprint('admin_dashboard', __name__, url_prefix='/admin')\n\ndef admin_required(f):\n    \"\"\"Decorator para exigir acesso de admin\"\"\"\n    @wraps(f)\n    def decorated_function(*args, **kwargs):\n        # Aqui voc√™ pode adicionar verifica√ß√£o de sess√£o admin\n        return f(*args, **kwargs)\n    return decorated_function\n\n@admin_bp.route('/database/health')\n@admin_required\ndef database_health():\n    \"\"\"Retorna status de sa√∫de do banco de dados\"\"\"\n    try:\n        if not db_safety:\n            return jsonify({'error': 'Sistema de seguran√ßa n√£o dispon√≠vel'}), 500\n        \n        # Verificar integridade\n        is_healthy, integrity_report = db_safety.check_database_integrity()\n        \n        # Obter estat√≠sticas\n        stats = db_safety.get_database_statistics()\n        \n        return jsonify({\n            'status': 'healthy' if is_healthy else 'warning',\n            'integrity_check': is_healthy,\n            'integrity_report': integrity_report,\n            'statistics': stats,\n            'last_check': integrity_report.get('timestamp', 'N/A')\n        })\n        \n    except Exception as e:\n        return jsonify({'error': str(e), 'status': 'error'}), 500\n\n@admin_bp.route('/database/backups')\n@admin_required  \ndef list_backups():\n    \"\"\"Lista todos os backups dispon√≠veis\"\"\"\n    try:\n        if not backup_manager:\n            return jsonify({'error': 'Sistema de backup n√£o dispon√≠vel'}), 500\n        \n        backups = backup_manager.list_backups()\n        return jsonify({\n            'backups': backups,\n            'total_backups': len(backups)\n        })\n        \n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n\n@admin_bp.route('/database/backup/create', methods=['POST'])\n@admin_required\ndef create_backup():\n    \"\"\"Cria um novo backup manual\"\"\"\n    try:\n        if not backup_manager:\n            return jsonify({'error': 'Sistema de backup n√£o dispon√≠vel'}), 500\n        \n        backup_path = backup_manager.create_backup(\"manual\")\n        \n        if backup_path:\n            return jsonify({\n                'success': True,\n                'backup_path': str(backup_path),\n                'message': 'Backup criado com sucesso'\n            })\n        else:\n            return jsonify({\n                'success': False,\n                'message': 'Falha ao criar backup'\n            }), 500\n            \n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n\n@admin_bp.route('/database/audit')\n@admin_required\ndef audit_logs():\n    \"\"\"Retorna logs de auditoria recentes\"\"\"\n    try:\n        if not db_safety:\n            return jsonify({'error': 'Sistema de seguran√ßa n√£o dispon√≠vel'}), 500\n        \n        # Buscar logs recentes (√∫ltimos 100)\n        with db_safety.safe_transaction() as conn:\n            cursor = conn.cursor()\n            cursor.execute(\"\"\"\n                SELECT table_name, operation, record_id, user_id, timestamp, ip_address\n                FROM audit_log \n                ORDER BY timestamp DESC \n                LIMIT 100\n            \"\"\")\n            \n            logs = []\n            for row in cursor.fetchall():\n                logs.append({\n                    'table': row[0],\n                    'operation': row[1], \n                    'record_id': row[2],\n                    'user_id': row[3],\n                    'timestamp': row[4],\n                    'ip_address': row[5]\n                })\n        \n        return jsonify({\n            'audit_logs': logs,\n            'total_logs': len(logs)\n        })\n        \n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n\n@admin_bp.route('/database/security-report')\n@admin_required\ndef security_report():\n    \"\"\"Gera relat√≥rio completo de seguran√ßa\"\"\"\n    try:\n        if not db_safety or not backup_manager:\n            return jsonify({'error': 'Sistemas de seguran√ßa n√£o dispon√≠veis'}), 500\n        \n        # Verifica√ß√µes de integridade\n        is_healthy, integrity_report = db_safety.check_database_integrity()\n        \n        # Estat√≠sticas do banco\n        stats = db_safety.get_database_statistics()\n        \n        # Lista de backups\n        backups = backup_manager.list_backups()\n        \n        # Calcular score de seguran√ßa\n        security_score = 0\n        security_issues = []\n        \n        if is_healthy:\n            security_score += 30\n        else:\n            security_issues.append(\"Falhas de integridade detectadas\")\n        \n        if len(backups) > 0:\n            security_score += 25\n        else:\n            security_issues.append(\"Nenhum backup dispon√≠vel\")\n        \n        db_size_mb = stats.get('database_size_mb', 0)\n        if isinstance(db_size_mb, (int, float)) and db_size_mb < 100:  # < 100MB √© considerado pequeno\n            security_score += 20\n        else:\n            security_issues.append(\"Banco de dados grande - considere PostgreSQL\")\n        \n        # Verificar se foreign keys est√£o habilitadas\n        security_score += 15  # Assumindo que est√£o habilitadas ap√≥s nossas corre√ß√µes\n        \n        # Logs de auditoria funcionando\n        security_score += 10  # Assumindo que tabela foi criada\n        \n        security_level = \"ALTA\" if security_score >= 80 else \"M√âDIA\" if security_score >= 60 else \"BAIXA\"\n        \n        return jsonify({\n            'security_score': security_score,\n            'security_level': security_level,\n            'security_issues': security_issues,\n            'database_health': {\n                'is_healthy': is_healthy,\n                'integrity_report': integrity_report\n            },\n            'backup_status': {\n                'total_backups': len(backups),\n                'latest_backup': backups[0] if backups else None\n            },\n            'database_stats': stats,\n            'recommendations': [\n                \"Configure backups autom√°ticos a cada 6 horas\",\n                \"Monitore logs de auditoria regularmente\", \n                \"Considere migrar para PostgreSQL para maior volume\",\n                \"Implemente alertas de falha de integridade\"\n            ]\n        })\n        \n    except Exception as e:\n        return jsonify({'error': str(e)}), 500","size_bytes":6747},"app.py":{"content":"from flask import Flask, render_template, request, redirect, url_for, session, send_file, abort, flash, g, jsonify\nfrom flask_sqlalchemy import SQLAlchemy\nfrom flask_socketio import SocketIO, emit\nfrom sqlalchemy import text\nfrom sqlalchemy.orm import joinedload, selectinload\nfrom werkzeug.security import generate_password_hash, check_password_hash\nfrom werkzeug.utils import secure_filename\nfrom functools import wraps\nfrom datetime import datetime, timedelta\nimport pytz\nimport io, os, shutil\nimport psutil\nimport json\nimport sqlite3\n\n# Configure Bras√≠lia timezone (GMT-3)\nBRAZIL_TZ = pytz.timezone('America/Sao_Paulo')\n\ndef now_brazil():\n    \"\"\"Return current datetime in Brazil timezone (GMT-3)\"\"\"\n    return datetime.now(BRAZIL_TZ).replace(tzinfo=None)\nimport pandas as pd\nimport matplotlib\nmatplotlib.use(\"Agg\")\nimport matplotlib.pyplot as plt\nfrom reportlab.pdfgen import canvas\nfrom reportlab.lib.pagesizes import A4\nimport uuid\n\n# SISTEMAS DE LICENCIAMENTO REATIVADOS + MELHORIAS DE TIPAGEM\ntry:\n    from backup_manager import BackupManager\n    from database_safety import DatabaseSafety  \n    from activity_logger import activity_logger, log_login, log_logout, log_admin_action, log_system_event\n    from license_manager import license_manager, is_licensed, get_license_status, check_feature_access\n    from license_generator import license_generator, create_standard_license, create_premium_license\n    from type_fixes import (\n        safe_log_login, safe_log_logout, safe_log_admin_action, safe_log_system_event,\n        safe_is_licensed, safe_get_license_status, safe_check_feature_access,\n        SafeUser, SafeChamado, validate_sector, validate_status\n    )\n    backup_manager = BackupManager(\"sistema_os.db\")\n    db_safety = DatabaseSafety(\"sistema_os.db\")\n    print(\"‚úÖ Configura√ß√µes de seguran√ßa aplicadas\")\n    print(\"‚úÖ Sistemas de seguran√ßa carregados\")\n    print(\"üîê Sistema de licenciamento ativo\")\n    print(\"üîß Melhorias de tipagem carregadas\")\nexcept ImportError as e:\n    print(f\"‚ö†Ô∏è Sistemas de seguran√ßa n√£o carregados: {e}\")\n    backup_manager = None\n    db_safety = None\n    activity_logger = None\n    license_manager = None\n    \n    # Fun√ß√µes de fallback com tipagem melhorada\n    from typing import Optional, Dict, Any\n    \n    def is_licensed() -> bool:\n        return True\n\n    def get_license_status() -> Dict[str, Any]:\n        return {'licensed': True, 'status': 'active'}\n\n    def check_feature_access(feature: str) -> bool:\n        return True\n    \n    def log_login(user_id: int, username: str, ip_address: Optional[str] = None, \n                  user_agent: Optional[str] = None, session_id: Optional[str] = None) -> None:\n        pass\n    \n    def log_logout(user_id: int, username: str, ip_address: Optional[str] = None, \n                   session_id: Optional[str] = None) -> None:\n        pass\n    \n    def log_admin_action(user_id: int, username: str, action_description: str, \n                         details: Optional[Dict[str, Any]] = None) -> None:\n        pass\n    \n    def log_system_event(event_type: str, description: str, \n                         details: Optional[Dict[str, Any]] = None) -> None:\n        pass\n\nAPP_NAME = \"Sistemas Olivium\"\n\nSETOR_CHOICES = [\"T.I\", \"Manuten√ß√£o\", \"CCIH / SESMT / Manuten√ß√£o de Ar condicionado\", \"Telefonia e outros servi√ßos\"]\n\n# Internal value mapping for sector consolidation\nSETOR_INTERNAL_VALUES = {\n    \"T.I\": \"ti\",\n    \"Manuten√ß√£o\": \"manutencao\", \n    \"CCIH / SESMT / Manuten√ß√£o de Ar condicionado\": \"ccih_sesmt_arcondicionado\",\n    \"Telefonia e outros servi√ßos\": \"telefonia_outros\"\n}\n\n# File upload configuration\nUPLOAD_FOLDER = 'static/uploads'\nALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg', 'gif'}\nMAX_FILE_SIZE = 5 * 1024 * 1024  # 5MB\n\ndef allowed_file(filename):\n    return '.' in filename and \\\n           filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\n\ndef save_uploaded_file(file):\n    \"\"\"Save uploaded file with secure name and return filename\"\"\"\n    if file and file.filename and allowed_file(file.filename):\n        # Create unique filename to prevent conflicts\n        filename_parts = file.filename.rsplit('.', 1)\n        if len(filename_parts) > 1:\n            ext = filename_parts[1].lower()\n        else:\n            ext = 'unknown'\n        filename = f\"{uuid.uuid4()}.{ext}\"\n        file.save(os.path.join(UPLOAD_FOLDER, filename))\n        return filename\n    return None\n\n# Carregar vari√°veis do arquivo .env se existir\ntry:\n    from dotenv import load_dotenv\n    load_dotenv()\nexcept ImportError:\n    pass  # dotenv n√£o instalado, continuar sem ele\n\napp = Flask(__name__)\nimport secrets\napp.secret_key = os.getenv(\"FLASK_SECRET_KEY\", secrets.token_hex(32))\n# Configura√ß√£o de banco de dados SQLite\n\n# FOR√áAR USO DE SQLITE - SEMPRE FUNCIONANDO\n# Usar arquivo √∫nico na raiz do projeto para evitar duplica√ß√£o\napp.config[\"SQLALCHEMY_DATABASE_URI\"] = \"sqlite:///sistema_os.db\"\nprint(f\"üìÑ Banco de dados: {app.config['SQLALCHEMY_DATABASE_URI']}\")\nprint(f\"üìÅ Arquivo real: sistema_os.db\")\napp.config[\"SQLALCHEMY_ENGINE_OPTIONS\"] = {\n    'pool_pre_ping': True,\n    'pool_recycle': 300,\n}\nprint(\"üóÑÔ∏è Usando SQLite para desenvolvimento...\")\n\napp.config[\"SQLALCHEMY_TRACK_MODIFICATIONS\"] = False\n\n# Performance optimization: Configure cache headers for static files\napp.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 31536000  # 1 year cache for static assets\napp.config[\"REPORT_DIR\"] = os.path.join(\"static\", \"relatorios\")\nos.makedirs(app.config[\"REPORT_DIR\"], exist_ok=True)\n\n# Ensure uploads directory exists\nos.makedirs(UPLOAD_FOLDER, exist_ok=True)\n\n# Sistema de usu√°rios online\nonline_users = set()\nuser_sessions = {}\n\n# Add datetime functions to Jinja2\n@app.template_global()\ndef now():\n    return now_brazil()\n\n# Add JSON filter to Jinja2\n@app.template_filter('fromjson')\ndef fromjson_filter(value):\n    import json\n    try:\n        return json.loads(value) if value else []\n    except:\n        return []\n\ndb = SQLAlchemy(app)\nsocketio = SocketIO(app, cors_allowed_origins=\"*\", logger=True)\n\n# Performance optimization: Add cache headers for static files\n@app.after_request\ndef add_cache_headers(response):\n    # Add cache headers for static assets to improve loading performance\n    if request.endpoint == 'static':\n        # Cache static files for 1 year\n        response.cache_control.max_age = 31536000\n        response.cache_control.public = True\n    elif request.path.endswith(('.css', '.js', '.png', '.jpg', '.jpeg', '.gif', '.ico', '.woff', '.woff2', '.ttf')):\n        # Cache other assets for 1 month\n        response.cache_control.max_age = 2592000\n        response.cache_control.public = True\n    else:\n        # No cache for dynamic pages (but allow reasonable cache for performance)\n        response.cache_control.max_age = 0\n        response.cache_control.no_cache = True\n        response.cache_control.must_revalidate = True\n    return response\n\ndef bootstrap():\n    # cria tabelas e admin/admin se n√£o existir\n    db.create_all()\n    \n    # Adicionar coluna ramal se n√£o existir\n    try:\n        db.session.execute(text('ALTER TABLE chamado ADD COLUMN ramal VARCHAR(20)'))\n        db.session.commit()\n        print(\"‚úÖ Coluna 'ramal' adicionada na tabela 'chamado'\")\n    except Exception as e:\n        if \"duplicate column name\" in str(e) or \"already exists\" in str(e):\n            print(\"‚úÖ Coluna 'ramal' j√° existe na tabela 'chamado'\")\n        else:\n            print(f\"‚ö†Ô∏è Erro ao adicionar coluna 'ramal': {e}\")\n        db.session.rollback()\n    \n    if not User.query.filter_by(username=\"admin\").first():\n        u = User(username=\"admin\", role=\"admin\", setor=None)\n        u.set_password(\"admin\")\n        db.session.add(u)\n        db.session.commit()\n\n\n# -------------------- MODELOS --------------------\n\n# New models for advanced admin functionality\nclass Sector(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    name = db.Column(db.String(100), unique=True, nullable=False)\n    display_name = db.Column(db.String(100), nullable=False)\n    description = db.Column(db.Text, nullable=True)\n    active = db.Column(db.Boolean, default=True)\n    created_at = db.Column(db.DateTime, default=now_brazil)\n\n# Many-to-many relationship table for users and sectors\nuser_sectors = db.Table('user_sectors',\n    db.Column('user_id', db.Integer, db.ForeignKey('user.id'), primary_key=True),\n    db.Column('sector_id', db.Integer, db.ForeignKey('sector.id'), primary_key=True)\n)\n    \n# Sistema de roles simplificado usando string\n\nclass SystemSettings(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    setting_key = db.Column(db.String(100), unique=True, nullable=False)\n    setting_value = db.Column(db.Text, nullable=True)\n    setting_type = db.Column(db.String(20), default='string')  # string, int, bool, json\n    description = db.Column(db.Text, nullable=True)\n    updated_at = db.Column(db.DateTime, default=now_brazil)\n\nclass User(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    username = db.Column(db.String(80), unique=True, nullable=False)\n    password_hash = db.Column(db.String(200), nullable=False)\n    role = db.Column(db.String(20), nullable=False)  # admin, operador, usuario\n    setor = db.Column(db.String(50), nullable=True)  # legacy single sector - DEPRECATED\n    # Sistema de roles simplificado usando campo string\n    # New many-to-many relationship with sectors\n    sectors = db.relationship('Sector', secondary=user_sectors, backref='users', lazy=True)\n\n    def set_password(self, password):\n        self.password_hash = generate_password_hash(password)\n\n    def check_password(self, password):\n        return check_password_hash(self.password_hash, password)\n        \n    def has_permission(self, permission):\n        \"\"\"Check if user has specific permission\"\"\"\n        if self.role == 'admin':  # Admin always has all permissions\n            return True\n            \n        # Check custom roles from Role table FIRST (they take precedence)\n        custom_role = Role.query.filter_by(name=self.role, active=True).first()\n        if custom_role:\n            return custom_role.has_permission(permission)\n            \n        # Check basic built-in roles\n        if self.role == 'operador':\n            # Operators can view and update tickets\n            return permission in ['view_tickets', 'update_tickets', 'create_tickets', 'view_sector', 'edit_sector', 'close_tickets', 'view_reports', 'edit_tickets', 'delete_tickets']\n        elif self.role == 'usuario':\n            # Users can only view and create their own tickets\n            return permission in ['view_own_tickets', 'create_tickets', 'view_own']\n        \n        # Fallback to legacy role-based permissions for unknown roles\n        legacy_permissions = {\n            'admin': ['view_all', 'edit_all', 'delete_all', 'manage_users', 'manage_sectors', 'manage_roles', 'view_reports', 'manage_settings', 'close_tickets', 'create_tickets', 'admin_access', 'edit_tickets', 'delete_tickets'],\n            'operador': ['view_sector', 'edit_sector', 'close_tickets', 'create_tickets', 'view_reports', 'edit_tickets', 'delete_tickets'],\n            'usuario': ['create_tickets', 'view_own']\n        }\n        \n        role_perms = legacy_permissions.get(self.role, [])\n        return permission in role_perms\n        \n    def is_admin(self):\n        \"\"\"Check if user is admin (built-in admin or custom role with admin permissions)\"\"\"\n        if self.role == 'admin':\n            return True\n        return self.has_permission('admin_access')\n        \n    def is_operator_like(self):\n        \"\"\"Check if user has operator-like permissions (built-in operador or custom role with operator permissions)\"\"\"\n        if self.role == 'operador':\n            return True\n        return self.has_permission('view_sector') or self.has_permission('edit_sector')\n        \n    def can_access_sector(self, sector_name):\n        \"\"\"Check if user can access tickets from a specific sector\"\"\"\n        if self.is_admin():\n            return True\n        if self.is_operator_like():\n            return self.has_sector_access(sector_name)\n        return False\n        \n    def get_sectors(self):\n        \"\"\"Get all sectors user has access to\"\"\"\n        if self.role == 'admin':  # Admin sees all sectors\n            return Sector.query.filter_by(active=True).all()\n        elif self.sectors:\n            return [s for s in self.sectors if s.active]\n        elif self.setor:  # Legacy single sector\n            sector = Sector.query.filter_by(name=self.setor, active=True).first()\n            return [sector] if sector else []\n        return []\n    \n    def get_sector_names(self):\n        \"\"\"Get list of sector names user has access to\"\"\"\n        return [s.name for s in self.get_sectors()]\n    \n    def has_sector_access(self, sector_name):\n        \"\"\"Check if user has access to a specific sector\"\"\"\n        if self.role == 'admin':\n            return True\n        return sector_name in self.get_sector_names()\n    \n    def assign_sectors(self, sector_ids):\n        \"\"\"Assign multiple sectors to user\"\"\"\n        # Clear existing sectors\n        self.sectors.clear()\n        # Add new sectors\n        if sector_ids:\n            sectors = Sector.query.filter(Sector.id.in_(sector_ids)).all()\n            self.sectors.extend(sectors)\n        # Update legacy setor field for backward compatibility\n        if self.sectors:\n            self.setor = self.sectors[0].name\n        else:\n            self.setor = None\n\nclass Chamado(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    titulo = db.Column(db.String(200), nullable=False)\n    descricao = db.Column(db.Text, nullable=False)\n    status = db.Column(db.String(20), default=\"Aberto\")  # Aberto, Em Andamento, Fechado\n    criado_em = db.Column(db.DateTime, default=now_brazil)  # hor√°rio de Bras√≠lia (GMT-3)\n    fechado_em = db.Column(db.DateTime, nullable=True)\n    resolucao = db.Column(db.Text, nullable=True)\n    setor = db.Column(db.String(50), nullable=True)\n    usuario_setor = db.Column(db.String(50), nullable=True)  # setor do usu√°rio que abriu o chamado\n    urgencia = db.Column(db.String(20), nullable=True)  # Urgente, N√£o Urgente (apenas quando fechado)\n    ramal = db.Column(db.String(20), nullable=True)  # n√∫mero do ramal do usu√°rio\n    cdc = db.Column(db.String(50), nullable=True)  # Campo para CDC (Centro de Custo)\n    \n    # Image attachments\n    imagem1 = db.Column(db.String(255), nullable=True)  # Path to first image\n    imagem2 = db.Column(db.String(255), nullable=True)  # Path to second image\n    imagem3 = db.Column(db.String(255), nullable=True)  # Path to third image\n\n    usuario_id = db.Column(db.Integer, db.ForeignKey(\"user.id\"))        # quem abriu\n    usuario = db.relationship(\"User\", foreign_keys=[usuario_id])\n\n    fechado_por_id = db.Column(db.Integer, db.ForeignKey(\"user.id\"))    # quem fechou\n    fechado_por = db.relationship(\"User\", foreign_keys=[fechado_por_id])\n    \n    def get_images(self):\n        \"\"\"Return list of image paths that exist\"\"\"\n        images = []\n        for img_field in [self.imagem1, self.imagem2, self.imagem3]:\n            if img_field:\n                images.append(img_field)\n        return images\n\nclass Role(db.Model):\n    \"\"\"Role model for advanced permissions system\"\"\"\n    __tablename__ = 'role'\n    \n    id = db.Column(db.Integer, primary_key=True)\n    name = db.Column(db.String(50), unique=True, nullable=False, index=True)\n    display_name = db.Column(db.String(100), nullable=False)\n    description = db.Column(db.Text, nullable=True)\n    permissions = db.Column(db.Text, nullable=True)  # JSON string\n    active = db.Column(db.Boolean, default=True, nullable=False)\n    created_at = db.Column(db.DateTime, default=now_brazil)\n    updated_at = db.Column(db.DateTime, default=now_brazil, onupdate=now_brazil)\n    \n    def __repr__(self):\n        return f'<Role {self.name}: {self.display_name}>'\n    \n    def get_permissions(self):\n        \"\"\"Return list of permissions\"\"\"\n        import json\n        try:\n            return json.loads(self.permissions) if self.permissions else []\n        except:\n            return []\n    \n    def has_permission(self, permission):\n        \"\"\"Check if role has specific permission\"\"\"\n        perms = self.get_permissions()\n        return permission in perms\n\n# -------------------- HELPERS DE AUTENTICA√á√ÉO --------------------\ndef login_required(f):\n    @wraps(f)\n    def wrapper(*args, **kwargs):\n        # Verificar licen√ßa primeiro (REATIVADO COMO ANTES)\n        if license_manager:\n            license_status = get_license_status()\n            if not license_status['licensed']:\n                if license_status.get('status') == 'expired':\n                    return render_template(\"license/expired.html\", \n                                         app_name=APP_NAME, \n                                         license_status=license_status)\n                else:\n                    return redirect(url_for(\"license_activation\"))\n        \n        if \"user_id\" not in session:\n            return redirect(url_for(\"login\"))\n        return f(*args, **kwargs)\n    return wrapper\n\ndef roles_required(*roles):\n    def deco(f):\n        @wraps(f)\n        def wrapper(*args, **kwargs):\n            if \"user_id\" not in session:\n                return redirect(url_for(\"login\"))\n            u = db.session.get(User, session[\"user_id\"])\n            if not u or u.role not in roles:\n                return abort(403)\n            return f(*args, **kwargs)\n        return wrapper\n    return deco\n\ndef permission_required(*permissions):\n    \"\"\"Decorator to check specific permissions instead of roles\"\"\"\n    def deco(f):\n        @wraps(f)\n        def wrapper(*args, **kwargs):\n            if \"user_id\" not in session:\n                return redirect(url_for(\"login\"))\n            u = db.session.get(User, session[\"user_id\"])\n            if not u:\n                return abort(403)\n            \n            # Check if user has ANY of the required permissions\n            has_permission = False\n            for permission in permissions:\n                if u.has_permission(permission):\n                    has_permission = True\n                    break\n                    \n            if not has_permission:\n                return abort(403)\n            return f(*args, **kwargs)\n        return wrapper\n    return deco\n\ndef current_user():\n    if \"user_id\" in session:\n        try:\n            user = db.session.get(User, session[\"user_id\"])\n            if user:\n                # Refresh user sectors in session for immediate effect\n                session['user_sectors'] = user.get_sector_names()\n                session['user_role'] = user.role\n                return user\n        except Exception as e:\n            print(f\"Error getting current user: {e}\")\n            # Try with basic columns only\n            try:\n                with db.engine.connect() as conn:\n                    # Fallback query compat√≠vel com SQLite\n                    result = conn.execute(text('SELECT id, username, password_hash, role FROM user WHERE id = :user_id'), {\"user_id\": session[\"user_id\"]})\n                    row = result.fetchone()\n                    if row:\n                        user = User()\n                        user.id = row[0]\n                        user.username = row[1] \n                        user.password_hash = row[2]\n                        user.role = row[3]\n                        return user\n            except Exception as e2:\n                print(f\"Error with fallback query: {e2}\")\n    return None\n\n# -------------------- CRIA DB E USU√ÅRIOS PADR√ÉO --------------------\n\ndef ensure_columns():\n    # garante colunas 'setor' em user e chamado (SQLite) e novas colunas para admin menu\n    try:\n        import sqlite3\n        db_path = os.path.join(app.root_path, \"sistema_os.db\")\n        if not os.path.exists(db_path):\n            db_path = \"sistema_os.db\"\n        conn = sqlite3.connect(db_path)\n        cur = conn.cursor()\n        def has_col(table, col):\n            cur.execute(f'PRAGMA table_info({table})')\n            return any(r[1] == col for r in cur.fetchall())\n        \n        # Legacy columns\n        if not has_col(\"user\", \"setor\"):\n            cur.execute(\"ALTER TABLE user ADD COLUMN setor VARCHAR(50)\")\n        if not has_col(\"chamado\", \"setor\"):\n            cur.execute(\"ALTER TABLE chamado ADD COLUMN setor VARCHAR(50)\")\n        if not has_col(\"chamado\", \"usuario_setor\"):\n            cur.execute(\"ALTER TABLE chamado ADD COLUMN usuario_setor VARCHAR(50)\")\n        if not has_col(\"chamado\", \"urgencia\"):\n            cur.execute(\"ALTER TABLE chamado ADD COLUMN urgencia VARCHAR(20)\")\n            \n        # New columns for admin menu functionality\n        if not has_col(\"user\", \"role_id\"):\n            cur.execute(\"ALTER TABLE user ADD COLUMN role_id INTEGER\")\n        if not has_col(\"user\", \"active\"):\n            cur.execute(\"ALTER TABLE user ADD COLUMN active BOOLEAN DEFAULT 1\")\n        if not has_col(\"user\", \"created_at\"):\n            cur.execute(\"ALTER TABLE user ADD COLUMN created_at DATETIME\")\n            \n        conn.commit()\n        conn.close()\n    except Exception as e:\n        print(\"Aviso: n√£o consegui garantir colunas de setor:\", e)\n\ndef initialize_system():\n    \"\"\"Initialize database tables, default data, and migrate existing data\"\"\"\n    with app.app_context():\n        # First create basic tables\n        db.create_all()\n        # Then ensure columns exist with migration\n        ensure_columns()\n        \n        # Create default users with simple approach first\n        def ensure_user(username, role, pwd):\n            try:\n                # Check if user exists using raw SQL to avoid ORM issues\n                with db.engine.begin() as conn:\n                    result = conn.execute(text(\"SELECT COUNT(*) FROM user WHERE username = :username\"), {\"username\": username})\n                    count = result.scalar()\n                    \n                    if count == 0:\n                        # Create user with basic columns\n                        conn.execute(text(\"INSERT INTO user (username, password_hash, role) VALUES (:username, :password_hash, :role)\"), \n                                   {\"username\": username, \"password_hash\": generate_password_hash(pwd), \"role\": role})\n                        print(f\"Created user {username}\")\n                    else:\n                        print(f\"User {username} already exists\")\n                        \n            except Exception as e:\n                print(f\"Error creating user {username}: {e}\")\n        \n        ensure_user(\"admin\", \"admin\", \"admin\")\n        ensure_user(\"operador\", \"operador\", \"operador\")\n        ensure_user(\"usuario\", \"usuario\", \"usuario\")\n        \n        print(\"Basic users created successfully\")\n        \n        # Initialize custom roles\n        try:\n            # Create semigerente role if it doesn't exist\n            semigerente = Role.query.filter_by(name='semigerente').first()\n            if not semigerente:\n                semigerente = Role(\n                    name='semigerente',\n                    display_name='Semi Gerente',\n                    description='Acesso completo a todas as funcionalidades',\n                    active=True,\n                    permissions='view_all,edit_all,delete_all,manage_users,manage_sectors,view_reports,manage_settings,close_tickets,create_tickets,admin_access,edit_tickets,delete_tickets,view_tickets,update_tickets,view_sector,edit_sector'\n                )\n                db.session.add(semigerente)\n                print(\"üîê Papel 'semigerente' criado com todas as permiss√µes\")\n            \n            # Create semioperador role if it doesn't exist  \n            semioperador = Role.query.filter_by(name='semioperador').first()\n            if not semioperador:\n                semioperador = Role(\n                    name='semioperador',\n                    display_name='Semi Operador',\n                    description='Acesso somente a relat√≥rios para visualiza√ß√£o',\n                    active=True,\n                    permissions='view_reports,view_tickets,view_sector'\n                )\n                db.session.add(semioperador)\n                print(\"üîê Papel 'semioperador' criado com permiss√µes de relat√≥rios\")\n                \n            db.session.commit()\n            print(\"Custom roles initialized successfully\")\n            \n        except Exception as e:\n            print(f\"‚ùå Erro ao criar pap√©is customizados: {e}\")\n            db.session.rollback()\n\n# Initialize system on import (disabled - using manual DB init)\n# initialize_system()\n\n@app.route(\"/admin/init-system\")\n@login_required\ndef admin_init_system():\n    \"\"\"Manual initialization of custom roles (admin only)\"\"\"\n    u = current_user()\n    if not u.is_admin():\n        abort(403)\n    \n    try:\n        initialize_system()\n        flash(\"Sistema inicializado com sucesso! Pap√©is customizados criados.\", \"success\")\n    except Exception as e:\n        flash(f\"Erro na inicializa√ß√£o: {e}\", \"danger\")\n    \n    return redirect(url_for(\"index\"))\n\n# -------------------- ROTAS DE AUTENTICA√á√ÉO --------------------\n@app.route(\"/login\", methods=[\"GET\", \"POST\"])\ndef login():\n    if request.method == \"POST\":\n        username = request.form.get(\"username\",\"\").strip()\n        password = request.form.get(\"password\",\"\")\n        user = User.query.filter_by(username=username).first()\n        if user and user.check_password(password):\n            # Check if user is active (disabled - column doesn't exist in current schema)\n            # This check was causing SQL errors and reducing performance\n            # Future: Add 'active' column if user activation/deactivation is needed\n            pass\n            \n            session[\"user_id\"] = user.id\n            \n            # Rastrear usu√°rio online\n            online_users.add(user.id)\n            user_sessions[user.id] = {\n                'login_time': datetime.now(),\n                'last_activity': datetime.now(),\n                'username': user.username\n            }\n            \n            # Log da atividade\n            if activity_logger:\n                log_login(user.id, user.username)\n            \n            return redirect(url_for(\"index\"))\n        flash(\"Usu√°rio ou senha incorretos.\", \"danger\")\n    return render_template(\"login.html\", app_name=APP_NAME)\n\n@app.route(\"/logout\")\n@login_required\ndef logout():\n    # Rastrear sa√≠da do usu√°rio\n    user_id = session.get(\"user_id\")\n    if user_id:\n        # Remover usu√°rio da lista de online\n        online_users.discard(user_id)\n        if user_id in user_sessions:\n            username = user_sessions[user_id].get('username', 'Usu√°rio')\n            del user_sessions[user_id]\n            # Log da atividade\n            if activity_logger:\n                log_logout(user_id, username)\n    \n    session.clear()\n    return redirect(url_for(\"login\"))\n\n# -------------------- ROTAS PRINCIPAIS --------------------\n@app.route(\"/\")\n@login_required\ndef index():\n    u = current_user()\n    \n    # Se n√£o conseguiu obter usu√°rio atual, redirecionar para login\n    if not u or not hasattr(u, 'role'):\n        session.clear()\n        return redirect(url_for(\"login\"))\n    \n    # Get sort parameter from URL (default: asc for ascending order)\n    sort_order = request.args.get('sort', 'asc')\n    \n    # Determine sort order (asc = crescente/oldest first, desc = decrescente/newest first)\n    if sort_order == 'desc':\n        order_by_clause = Chamado.criado_em.desc()\n        next_sort = 'asc'\n        sort_label = 'Recentes Primeiro'\n        sort_icon = 'bi bi-arrow-down'\n    else:\n        order_by_clause = Chamado.criado_em.asc()\n        next_sort = 'desc'\n        sort_label = 'Antigos Primeiro'\n        sort_icon = 'bi bi-arrow-up'\n    \n    # Optimize database queries with eager loading to prevent N+1 problems\n    base_query = Chamado.query.options(\n        joinedload(Chamado.usuario),\n        joinedload(Chamado.fechado_por)\n    )\n    \n    if u.is_admin():\n        # Admin sees all tickets\n        chamados = base_query.order_by(order_by_clause).all()\n    elif u.has_permission('view_all'):\n        # Users with view_all permission (like semigerente) see all tickets\n        chamados = base_query.order_by(order_by_clause).all()\n    elif u.is_operator_like():\n        # Operators and operator-like roles see tickets from their assigned sectors only\n        user_sector_names = u.get_sector_names()\n        if user_sector_names:\n            chamados = base_query.filter(Chamado.setor.in_(user_sector_names)).order_by(order_by_clause).all()\n        else:\n            chamados = []  # No sectors assigned, no tickets visible\n    else:\n        # Regular users see only their own tickets\n        chamados = base_query.filter_by(usuario_id=u.id).order_by(order_by_clause).all()\n    \n    return render_template(\"index.html\", \n                         app_name=APP_NAME, \n                         user=u, \n                         chamados=chamados,\n                         sort_order=sort_order,\n                         next_sort=next_sort,\n                         sort_label=sort_label,\n                         sort_icon=sort_icon)\n\n# -------------------- USU√ÅRIOS (ADMIN) --------------------\n@app.route(\"/usuarios\")\n@login_required\n@roles_required(\"admin\")\ndef usuarios_list():\n    users = User.query.order_by(User.username).all()\n    return render_template(\"usuarios_list.html\", app_name=APP_NAME, user=current_user(), users=users)\n\n@app.route(\"/usuarios/novo\", methods=[\"GET\",\"POST\"])\n@login_required\n@roles_required(\"admin\")\ndef usuarios_novo():\n    if request.method == \"POST\":\n        username = request.form[\"username\"].strip()\n        password = request.form[\"password\"]\n        role = request.form[\"role\"]\n        if not username or not password:\n            flash(\"Preencha usu√°rio e senha.\", \"warning\")\n            return redirect(url_for(\"usuarios_novo\"))\n        if User.query.filter_by(username=username).first():\n            flash(\"Usu√°rio j√° existe.\", \"danger\")\n            return redirect(url_for(\"usuarios_novo\"))\n        \n        u = User(username=username, role=role)\n        u.set_password(password)\n        db.session.add(u)\n        \n        # Handle sector assignment\n        sector_ids = request.form.getlist('sector_ids')\n        legacy_setor = request.form.get('setor')\n        \n        if sector_ids:\n            sector_ids = [int(id) for id in sector_ids if id.isdigit()]\n            u.assign_sectors(sector_ids)\n        elif legacy_setor:\n            sector = Sector.query.filter_by(name=legacy_setor).first()\n            if sector:\n                u.assign_sectors([sector.id])\n            else:\n                u.setor = legacy_setor\n        \n        # Validate operator sector assignment\n        if role == 'operador' and not u.get_sectors():\n            flash(\"Operadores devem ter pelo menos um setor atribu√≠do.\", \"warning\")\n            # Buscar setores para o template\n            try:\n                sectors = Sector.query.filter_by(active=True).order_by(Sector.display_name).all()\n            except:\n                sectors = []\n            return render_template(\"usuarios_form.html\", app_name=APP_NAME, user=current_user(), u=None, sectors=sectors)\n        \n        db.session.commit()\n        flash(\"Usu√°rio criado.\", \"success\")\n        return redirect(url_for(\"usuarios_list\"))\n    \n    # Buscar setores para o template\n    try:\n        sectors = Sector.query.filter_by(active=True).order_by(Sector.display_name).all()\n    except:\n        sectors = []\n    return render_template(\"usuarios_form.html\", app_name=APP_NAME, user=current_user(), u=None, sectors=sectors)\n\n@app.route(\"/usuarios/editar/<int:user_id>\", methods=[\"GET\",\"POST\"])\n@login_required\n@roles_required(\"admin\")\ndef usuarios_editar(user_id):\n    u = db.session.get(User, user_id) or abort(404)\n    if request.method == \"POST\":\n        u.username = request.form[\"username\"].strip()\n        new_pwd = request.form.get(\"password\",\"\").strip()\n        u.role = request.form[\"role\"]\n        \n        # Handle both legacy single sector and new multi-sector assignment\n        sector_ids = request.form.getlist('sector_ids')\n        legacy_setor = request.form.get('setor')\n        \n        if sector_ids:\n            # New multi-sector system\n            sector_ids = [int(id) for id in sector_ids if id.isdigit()]\n            u.assign_sectors(sector_ids)\n        elif legacy_setor:\n            # Legacy single sector system - find sector by name and assign\n            sector = Sector.query.filter_by(name=legacy_setor).first()\n            if sector:\n                u.assign_sectors([sector.id])\n            else:\n                u.setor = legacy_setor  # Fallback for backward compatibility\n        else:\n            # Clear sectors\n            u.assign_sectors([])\n        \n        # Validate operator sector assignment\n        if u.is_operator_like() and not u.is_admin() and not u.get_sectors():\n            flash(\"Operadores devem ter pelo menos um setor atribu√≠do.\", \"warning\")\n            # Buscar setores para o template\n            try:\n                sectors = Sector.query.filter_by(active=True).order_by(Sector.display_name).all()\n            except:\n                sectors = []\n            return render_template(\"usuarios_form.html\", app_name=APP_NAME, user=current_user(), u=u, sectors=sectors)\n        \n        if new_pwd:\n            u.set_password(new_pwd)\n        \n        # Force session refresh for currently logged in user\n        if u.id == session.get('user_id'):\n            session['user_sectors'] = u.get_sector_names()\n            session['user_role'] = u.role\n        \n        db.session.commit()\n        flash(\"Usu√°rio atualizado.\", \"success\")\n        return redirect(url_for(\"usuarios_list\"))\n    \n    # Buscar setores para o template\n    try:\n        sectors = Sector.query.filter_by(active=True).order_by(Sector.display_name).all()\n    except:\n        sectors = []\n    return render_template(\"usuarios_form.html\", app_name=APP_NAME, user=current_user(), u=u, sectors=sectors)\n\n@app.route(\"/usuarios/excluir/<int:user_id>\")\n@login_required\n@roles_required(\"admin\")\ndef usuarios_excluir(user_id):\n    if user_id == session.get(\"user_id\"):\n        flash(\"Voc√™ n√£o pode excluir a si mesmo.\", \"warning\")\n        return redirect(url_for(\"usuarios_list\"))\n    u = db.session.get(User, user_id) or abort(404)\n    db.session.delete(u)\n    db.session.commit()\n    flash(\"Usu√°rio exclu√≠do.\", \"success\")\n    return redirect(url_for(\"usuarios_list\"))\n\n# -------------------- CHAMADOS --------------------\n@app.route(\"/chamados/novo\", methods=[\"GET\",\"POST\"])\n@login_required\ndef chamados_novo():\n    u = current_user()\n    if request.method == \"POST\":\n        titulo = request.form[\"titulo\"].strip()\n        descricao = request.form[\"descricao\"].strip()\n        if not titulo or not descricao:\n            flash(\"Informe t√≠tulo e descri√ß√£o.\", \"warning\")\n            return redirect(url_for(\"chamados_novo\"))\n        usuario_setor = request.form.get('usuario_setor')\n        if not usuario_setor:\n            flash(\"Informe seu setor.\", \"warning\")\n            return redirect(url_for(\"chamados_novo\"))\n        ramal = request.form.get('ramal', '').strip()\n        cdc = request.form.get('cdc', '').strip()\n        \n        # Valida√ß√£o CDC para setor COMPRAS\n        setor_selecionado = request.form.get('setor', '').strip()\n        if setor_selecionado and ('COMPRAS' in setor_selecionado.upper() or 'COMPRA' in setor_selecionado.upper()):\n            if not cdc:\n                flash(\"Para o setor COMPRAS √© obrigat√≥rio informar o CDC. Caso n√£o tenha na sua OS, a mesma ser√° invalidada.\", \"error\")\n                return redirect(url_for(\"chamados_novo\"))\n        \n        c = Chamado(titulo=titulo, descricao=descricao, usuario_id=u.id, status=\"Aberto\", setor=request.form.get('setor'), usuario_setor=usuario_setor, ramal=ramal, cdc=cdc)\n        \n        # Handle image uploads\n        for i in range(1, 4):  # imagem1, imagem2, imagem3\n            file = request.files.get(f'imagem{i}')\n            if file:\n                filename = save_uploaded_file(file)\n                if filename:\n                    setattr(c, f'imagem{i}', filename)\n        \n        db.session.add(c)\n        db.session.commit()\n        # Emit WebSocket event for new ticket\n        emit_ticket_update(ticket_to_dict(c), 'created')\n        flash(\"Chamado criado.\", \"success\")\n        return redirect(url_for(\"index\"))\n    \n    # Get dynamic sectors for the form\n    try:\n        sectors = Sector.query.filter_by(active=True).order_by(Sector.display_name).all()\n    except:\n        # Fallback to default sectors if table doesn't exist yet\n        sectors = [\n            {'name': 'ti', 'display_name': 'T.I'},\n            {'name': 'manutencao', 'display_name': 'Manuten√ß√£o'},\n            {'name': 'ccih', 'display_name': 'CCIH / SESMT / Manuten√ß√£o de Ar condicionado'},\n            {'name': 'telefonia', 'display_name': 'Telefonia e outros servi√ßos'}\n        ]\n    \n    return render_template(\"chamado_form.html\", app_name=APP_NAME, user=u, chamado=None, sectors=sectors)\n\n@app.route(\"/chamados/editar/<int:cid>\", methods=[\"GET\",\"POST\"])\n@login_required\ndef chamados_editar(cid):\n    u = current_user()\n    c = db.session.get(Chamado, cid) or abort(404)\n    # permiss√µes atualizadas: apenas admin pode editar\n    if not u.is_admin():\n        abort(403)\n    if request.method == \"POST\":\n        old_status = c.status\n        c.titulo = request.form[\"titulo\"].strip()\n        c.descricao = request.form[\"descricao\"].strip()\n        c.status = request.form.get(\"status\", c.status)\n        # Update sector if provided\n        setor = request.form.get(\"setor\")\n        if setor:\n            c.setor = setor\n        \n        # Update CDC field\n        cdc = request.form.get('cdc', '').strip()\n        c.cdc = cdc\n        \n        # Valida√ß√£o CDC para setor COMPRAS na edi√ß√£o\n        if c.setor and ('COMPRAS' in c.setor.upper() or 'COMPRA' in c.setor.upper()):\n            if not cdc:\n                flash(\"Para o setor COMPRAS √© obrigat√≥rio informar o CDC. Caso n√£o tenha na sua OS, a mesma ser√° invalidada.\", \"error\")\n                # Get dynamic sectors for the form in case of error\n                try:\n                    sectors = Sector.query.filter_by(active=True).order_by(Sector.display_name).all()\n                except:\n                    sectors = [\n                        {'name': 'ti', 'display_name': 'T.I'},\n                        {'name': 'manutencao', 'display_name': 'Manuten√ß√£o'},\n                        {'name': 'ccih', 'display_name': 'CCIH / SESMT / Manuten√ß√£o de Ar condicionado'},\n                        {'name': 'telefonia', 'display_name': 'Telefonia e outros servi√ßos'}\n                    ]\n                return render_template(\"chamado_form.html\", app_name=APP_NAME, user=u, chamado=c, sectors=sectors)\n        \n        # Handle image uploads and removals\n        for i in range(1, 4):  # imagem1, imagem2, imagem3\n            # Check if user wants to remove existing image\n            if request.form.get(f'remover_imagem{i}'):\n                old_image = getattr(c, f'imagem{i}')\n                if old_image:\n                    # Delete file from filesystem\n                    try:\n                        os.remove(os.path.join(UPLOAD_FOLDER, old_image))\n                    except:\n                        pass  # File might not exist\n                setattr(c, f'imagem{i}', None)\n            \n            # Handle new image upload\n            file = request.files.get(f'imagem{i}')\n            if file:\n                filename = save_uploaded_file(file)\n                if filename:\n                    # Remove old image if replacing\n                    old_image = getattr(c, f'imagem{i}')\n                    if old_image:\n                        try:\n                            os.remove(os.path.join(UPLOAD_FOLDER, old_image))\n                        except:\n                            pass\n                    setattr(c, f'imagem{i}', filename)\n        \n        db.session.commit()\n        # Emit WebSocket event for ticket update\n        event_type = 'status_changed' if old_status != c.status else 'updated'\n        emit_ticket_update(ticket_to_dict(c), event_type)\n        flash(\"Chamado atualizado.\", \"success\")\n        return redirect(url_for(\"index\"))\n    \n    # Get dynamic sectors for the form\n    try:\n        sectors = Sector.query.filter_by(active=True).order_by(Sector.display_name).all()\n    except:\n        # Fallback to default sectors if table doesn't exist yet\n        sectors = [\n            {'name': 'ti', 'display_name': 'T.I'},\n            {'name': 'manutencao', 'display_name': 'Manuten√ß√£o'},\n            {'name': 'ccih', 'display_name': 'CCIH / SESMT / Manuten√ß√£o de Ar condicionado'},\n            {'name': 'telefonia', 'display_name': 'Telefonia e outros servi√ßos'}\n        ]\n    \n    return render_template(\"chamado_form.html\", app_name=APP_NAME, user=u, chamado=c, sectors=sectors)\n\n@app.route(\"/chamados/fechar/<int:cid>\", methods=[\"GET\",\"POST\"])\n@login_required\ndef chamados_fechar(cid):\n    u = current_user()\n    c = db.session.get(Chamado, cid) or abort(404)\n    # admin/operador podem fechar, operador apenas do seu setor\n    if not (u.is_admin() or u.is_operator_like()):\n        abort(403)\n    if u.is_operator_like() and not u.is_admin() and c.setor and not u.can_access_sector(c.setor):\n        abort(403)\n    if request.method == \"POST\":\n        urgencia = request.form.get(\"urgencia\")\n        if not urgencia or urgencia not in [\"Urgente\", \"N√£o Urgente\"]:\n            flash(\"√â obrigat√≥rio selecionar a classifica√ß√£o de urg√™ncia.\", \"error\")\n            return render_template(\"chamado_fechar.html\", app_name=APP_NAME, user=u, chamado=c)\n        \n        c.status = \"Fechado\"\n        c.fechado_em = now_brazil()\n        c.resolucao = request.form[\"resolucao\"].strip()\n        c.urgencia = urgencia\n        c.fechado_por_id = u.id\n        db.session.commit()\n        # Emit WebSocket event for ticket closure\n        emit_ticket_update(ticket_to_dict(c), 'closed')\n        flash(\"Chamado fechado.\", \"success\")\n        return redirect(url_for(\"index\"))\n    return render_template(\"chamado_fechar.html\", app_name=APP_NAME, user=u, chamado=c)\n\n@app.route(\"/chamados/excluir/<int:cid>\")\n@login_required\ndef chamados_excluir(cid):\n    u = current_user()\n    c = db.session.get(Chamado, cid) or abort(404)\n    # apenas admin pode excluir\n    if not u.is_admin():\n        abort(403)\n    db.session.delete(c)\n    db.session.commit()\n    flash(\"Chamado exclu√≠do.\", \"success\")\n    return redirect(url_for(\"index\"))\n\n# -------------------- VIEW TICKET --------------------\n@app.route(\"/chamados/view/<int:cid>\")\n@login_required\ndef chamados_view(cid):\n    u = current_user()\n    c = db.session.get(Chamado, cid) or abort(404)\n    \n    # Permiss√µes: admin v√™ tudo, operador v√™ do seu setor, usu√°rio v√™ apenas os seus\n    if not u.is_admin() and not u.has_permission('view_all'):\n        if u.is_operator_like() and c.setor and not u.can_access_sector(c.setor):\n            abort(403)\n        elif not u.is_operator_like() and c.usuario_id != u.id:\n            abort(403)\n    \n    return render_template(\"chamado_view.html\", app_name=APP_NAME, user=u, chamado=c)\n\n# -------------------- ADMIN UTIL --------------------\n@app.route(\"/admin/backup\")\n@login_required\n@roles_required(\"admin\")\ndef admin_backup():\n    # envia o arquivo sqlite para download\n    db_path = os.path.join(app.root_path, \"sistema_os.db\")\n    if not os.path.exists(db_path):\n        # tamb√©m pode estar relativo\n        db_path = \"sistema_os.db\"\n    if not os.path.exists(db_path):\n        flash(\"Banco de dados n√£o encontrado.\", \"danger\")\n        return redirect(url_for(\"index\"))\n    return send_file(db_path, as_attachment=True, download_name=\"sistema_os_backup.sqlite\")\n\n# -------------------- DATABASE MANAGEMENT --------------------\n@app.route(\"/admin/database/export\")\n@login_required\n@roles_required(\"admin\")\ndef admin_database_export():\n    \"\"\"Exportar banco de dados principal\"\"\"\n    try:\n        # Criar backup antes da exporta√ß√£o\n        from datetime import datetime\n        timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n        \n        db_path = \"sistema_os.db\"\n        if not os.path.exists(db_path):\n            flash(\"Banco de dados n√£o encontrado.\", \"danger\")\n            return redirect(url_for(\"admin_settings\"))\n        \n        # Nome do arquivo com timestamp\n        download_name = f\"sistema_os_export_{timestamp}.db\"\n        \n        return send_file(db_path, as_attachment=True, download_name=download_name, mimetype='application/x-sqlite3')\n    except Exception as e:\n        flash(f\"Erro ao exportar banco de dados: {str(e)}\", \"danger\")\n        return redirect(url_for(\"admin_settings\"))\n\n@app.route(\"/admin/database/import\", methods=[\"POST\"])\n@login_required\n@roles_required(\"admin\")\ndef admin_database_import():\n    \"\"\"Importar banco de dados\"\"\"\n    try:\n        # Verificar se arquivo foi enviado\n        if 'database_file' not in request.files:\n            flash(\"Nenhum arquivo selecionado.\", \"danger\")\n            return redirect(url_for(\"admin_settings\"))\n        \n        file = request.files['database_file']\n        if file.filename == '':\n            flash(\"Nenhum arquivo selecionado.\", \"danger\")\n            return redirect(url_for(\"admin_settings\"))\n        \n        # Verificar confirma√ß√£o\n        if not request.form.get('confirm_import'):\n            flash(\"√â necess√°rio confirmar a importa√ß√£o.\", \"danger\")\n            return redirect(url_for(\"admin_settings\"))\n        \n        # Verificar extens√£o do arquivo\n        allowed_extensions = {'.db', '.sqlite', '.sqlite3'}\n        file_ext = os.path.splitext(file.filename)[1].lower()\n        if file_ext not in allowed_extensions:\n            flash(\"Tipo de arquivo n√£o permitido. Use apenas .db, .sqlite ou .sqlite3\", \"danger\")\n            return redirect(url_for(\"admin_settings\"))\n        \n        # Criar backup do banco atual antes da importa√ß√£o\n        from datetime import datetime\n        timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n        backup_path = f\"backup_before_import_{timestamp}.db\"\n        \n        import shutil\n        if os.path.exists(\"sistema_os.db\"):\n            shutil.copy2(\"sistema_os.db\", backup_path)\n            print(f\"Backup criado: {backup_path}\")\n        \n        # Salvar arquivo tempor√°rio\n        temp_path = f\"temp_import_{timestamp}.db\"\n        file.save(temp_path)\n        \n        # Validar se √© um banco SQLite v√°lido\n        import sqlite3\n        try:\n            test_conn = sqlite3.connect(temp_path)\n            test_conn.execute(\"SELECT name FROM sqlite_master WHERE type='table'\")\n            test_conn.close()\n        except sqlite3.Error as e:\n            os.remove(temp_path)\n            flash(f\"Arquivo n√£o √© um banco SQLite v√°lido: {str(e)}\", \"danger\")\n            return redirect(url_for(\"admin_settings\"))\n        \n        # Fechar conex√µes do SQLAlchemy\n        db.session.close()\n        db.engine.dispose()\n        \n        # Substituir banco atual\n        if os.path.exists(\"sistema_os.db\"):\n            os.remove(\"sistema_os.db\")\n        \n        shutil.move(temp_path, \"sistema_os.db\")\n        \n        # Recriar conex√£o\n        from sqlalchemy import create_engine\n        app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///sistema_os.db'\n        db.engine = create_engine(app.config['SQLALCHEMY_DATABASE_URI'])\n        \n        flash(f\"Banco de dados importado com sucesso! Backup salvo como: {backup_path}\", \"success\")\n        \n        # Redirecionar para login pois pode ter mudado usu√°rios\n        session.clear()\n        return redirect(url_for(\"login\"))\n        \n    except Exception as e:\n        # Tentar restaurar backup se algo deu errado\n        try:\n            if 'backup_path' in locals() and os.path.exists(backup_path):\n                if os.path.exists(\"sistema_os.db\"):\n                    os.remove(\"sistema_os.db\")\n                shutil.move(backup_path, \"sistema_os.db\")\n                flash(f\"Erro na importa√ß√£o, banco restaurado: {str(e)}\", \"danger\")\n            else:\n                flash(f\"Erro cr√≠tico na importa√ß√£o: {str(e)}\", \"danger\")\n        except:\n            flash(f\"Erro cr√≠tico na importa√ß√£o e falha na restaura√ß√£o: {str(e)}\", \"danger\")\n        \n        return redirect(url_for(\"admin_settings\"))\n\n# -------------------- MONITORING SYSTEM --------------------\n@app.route(\"/admin/monitoring\")\n@login_required\n@roles_required(\"admin\")\ndef admin_monitoring():\n    \"\"\"P√°gina principal de monitoramento do sistema\"\"\"\n    try:\n        # Status geral do sistema\n        system_status = get_system_status()\n        \n        # Performance do sistema\n        performance = get_system_performance()\n        \n        # Estat√≠sticas do banco\n        db_stats = get_database_stats()\n        \n        # Usu√°rios online\n        online_count = len(online_users)\n        \n        # Atividades recentes\n        recent_activities = []\n        if activity_logger:\n            recent_activities = activity_logger.get_recent_activities(20)\n        \n        return render_template(\"admin/monitoring.html\",\n                             app_name=APP_NAME,\n                             user=current_user(),\n                             system_status=system_status,\n                             performance=performance,\n                             db_stats=db_stats,\n                             online_users=online_count,\n                             recent_activities=recent_activities)\n    except Exception as e:\n        flash(f\"Erro ao carregar monitoramento: {str(e)}\", \"danger\")\n        return redirect(url_for(\"admin_dashboard\"))\n\n@app.route(\"/admin/monitoring/data\")\n@login_required\n@roles_required(\"admin\")\ndef admin_monitoring_data():\n    \"\"\"API para dados de monitoramento em tempo real\"\"\"\n    try:\n        # Atividades recentes\n        recent_activities = []\n        if activity_logger:\n            recent_activities = activity_logger.get_recent_activities(10)\n        \n        data = {\n            'online_users': len(online_users),\n            'recent_activities': recent_activities,\n            'timestamp': datetime.now().strftime('%H:%M:%S')\n        }\n        \n        return json.dumps(data)\n    except Exception as e:\n        return json.dumps({'error': str(e)})\n\ndef get_system_status():\n    \"\"\"Obter status geral do sistema\"\"\"\n    status = {\n        'overall_status': 'Operacional',\n        'overall_status_color': 'success',\n        'overall_icon': 'check-circle',\n        'db_status': 'Conectado',\n        'db_status_color': 'success',\n        'backup_status': 'Ativo',\n        'backup_status_color': 'success',\n        'last_backup': 'Hoje'\n    }\n    \n    try:\n        # Verificar conex√£o do banco\n        result = db.session.execute(text(\"SELECT 1\")).fetchone()\n        if not result:\n            status['db_status'] = 'Erro'\n            status['db_status_color'] = 'danger'\n            status['overall_status'] = 'Aten√ß√£o'\n            status['overall_status_color'] = 'warning'\n    except:\n        status['db_status'] = 'Erro'\n        status['db_status_color'] = 'danger'\n        status['overall_status'] = 'Cr√≠tico'\n        status['overall_status_color'] = 'danger'\n        status['overall_icon'] = 'exclamation-triangle'\n    \n    # Verificar √∫ltimo backup\n    try:\n        import glob\n        backup_files = glob.glob(\"backups/*.db\")\n        if backup_files:\n            latest_backup = max(backup_files, key=os.path.getctime)\n            backup_time = datetime.fromtimestamp(os.path.getctime(latest_backup))\n            hours_ago = (datetime.now() - backup_time).total_seconds() / 3600\n            \n            if hours_ago < 24:\n                status['last_backup'] = f\"{int(hours_ago)}h atr√°s\"\n            else:\n                status['last_backup'] = backup_time.strftime('%d/%m')\n                if hours_ago > 48:  # Mais de 2 dias\n                    status['backup_status'] = 'Atrasado'\n                    status['backup_status_color'] = 'warning'\n        else:\n            status['backup_status'] = 'Sem backup'\n            status['backup_status_color'] = 'danger'\n    except:\n        status['backup_status'] = 'Erro'\n        status['backup_status_color'] = 'danger'\n    \n    return status\n\ndef get_system_performance():\n    \"\"\"Obter m√©tricas de performance do sistema\"\"\"\n    performance = {\n        'cpu_percent': 0,\n        'cpu_color': 'success',\n        'memory_percent': 0,\n        'memory_color': 'success',\n        'disk_percent': 0,\n        'disk_color': 'success'\n    }\n    \n    try:\n        # CPU\n        cpu = psutil.cpu_percent(interval=1)\n        performance['cpu_percent'] = round(cpu, 1)\n        if cpu > 80:\n            performance['cpu_color'] = 'danger'\n        elif cpu > 60:\n            performance['cpu_color'] = 'warning'\n        \n        # Mem√≥ria\n        memory = psutil.virtual_memory()\n        performance['memory_percent'] = round(memory.percent, 1)\n        if memory.percent > 80:\n            performance['memory_color'] = 'danger'\n        elif memory.percent > 60:\n            performance['memory_color'] = 'warning'\n        \n        # Disco\n        disk = psutil.disk_usage('/')\n        performance['disk_percent'] = round(disk.percent, 1)\n        if disk.percent > 90:\n            performance['disk_color'] = 'danger'\n        elif disk.percent > 80:\n            performance['disk_color'] = 'warning'\n            \n    except Exception as e:\n        print(f\"Erro ao obter performance: {e}\")\n    \n    return performance\n\ndef get_database_stats():\n    \"\"\"Obter estat√≠sticas do banco de dados\"\"\"\n    stats = {\n        'total_records': 0,\n        'db_size': '0 MB',\n        'active_tickets': 0,\n        'total_users': 0\n    }\n    \n    try:\n        # Total de registros\n        tables = ['user', 'chamado', 'system_activity']\n        total = 0\n        for table in tables:\n            try:\n                result = db.session.execute(text(f\"SELECT COUNT(*) FROM {table}\")).fetchone()\n                if result:\n                    total += result[0]\n            except:\n                pass\n        stats['total_records'] = total\n        \n        # Tamanho do banco\n        if os.path.exists(\"sistema_os.db\"):\n            size_bytes = os.path.getsize(\"sistema_os.db\")\n            size_mb = round(size_bytes / (1024 * 1024), 2)\n            stats['db_size'] = f\"{size_mb} MB\"\n        \n        # Chamados ativos\n        result = db.session.execute(text(\"SELECT COUNT(*) FROM chamado WHERE status != 'fechado'\")).fetchone()\n        if result:\n            stats['active_tickets'] = result[0]\n        \n        # Total de usu√°rios\n        result = db.session.execute(text(\"SELECT COUNT(*) FROM user\")).fetchone()\n        if result:\n            stats['total_users'] = result[0]\n            \n    except Exception as e:\n        print(f\"Erro ao obter estat√≠sticas do banco: {e}\")\n    \n    return stats\n\n@app.route(\"/admin/logs\")\n@login_required\n@roles_required(\"admin\")\ndef admin_logs():\n    \"\"\"P√°gina de logs de atividades\"\"\"\n    try:\n        # Pagina√ß√£o\n        page = request.args.get('page', 1, type=int)\n        per_page = 50\n        \n        # Filtros\n        action_filter = request.args.get('action', '')\n        user_filter = request.args.get('user', '')\n        date_filter = request.args.get('date', '')\n        \n        # Obter logs com filtros\n        logs = []\n        total_logs = 0\n        \n        if activity_logger:\n            # Implementar filtros na consulta\n            conn = sqlite3.connect(\"sistema_os.db\")\n            cursor = conn.cursor()\n            \n            query = \"SELECT * FROM system_activity WHERE 1=1\"\n            params = []\n            \n            if action_filter:\n                query += \" AND action_type LIKE ?\"\n                params.append(f'%{action_filter}%')\n            \n            if user_filter:\n                query += \" AND username LIKE ?\"\n                params.append(f'%{user_filter}%')\n            \n            if date_filter:\n                query += \" AND DATE(timestamp) = ?\"\n                params.append(date_filter)\n            \n            # Contar total\n            count_query = query.replace(\"SELECT *\", \"SELECT COUNT(*)\")\n            cursor.execute(count_query, params)\n            total_logs = cursor.fetchone()[0]\n            \n            # Buscar logs paginados\n            query += \" ORDER BY timestamp DESC LIMIT ? OFFSET ?\"\n            params.extend([per_page, (page - 1) * per_page])\n            \n            cursor.execute(query, params)\n            raw_logs = cursor.fetchall()\n            \n            # Formatar logs\n            for log in raw_logs:\n                logs.append({\n                    'id': log[0],\n                    'timestamp': activity_logger.format_timestamp(log[1]),\n                    'user': log[3] or 'Sistema',\n                    'action': log[4],\n                    'description': log[5],\n                    'details': log[6],\n                    'ip': log[7],\n                    'color': activity_logger.get_action_color(log[4])\n                })\n            \n            conn.close()\n        \n        # Estat√≠sticas r√°pidas\n        stats = activity_logger.get_activity_stats() if activity_logger else {}\n        \n        return render_template(\"admin/logs.html\",\n                             app_name=APP_NAME,\n                             user=current_user(),\n                             logs=logs,\n                             total_logs=total_logs,\n                             page=page,\n                             per_page=per_page,\n                             action_filter=action_filter,\n                             user_filter=user_filter,\n                             date_filter=date_filter,\n                             stats=stats)\n    \n    except Exception as e:\n        flash(f\"Erro ao carregar logs: {str(e)}\", \"danger\")\n        return redirect(url_for(\"admin_dashboard\"))\n\n@app.route(\"/admin/maintenance\", methods=[\"GET\", \"POST\"])\n@login_required\n@roles_required(\"admin\")\ndef admin_maintenance():\n    \"\"\"P√°gina de manuten√ß√£o do sistema\"\"\"\n    if request.method == \"POST\":\n        action = request.form.get(\"action\")\n        \n        try:\n            if action == \"optimize_db\":\n                # Otimizar banco de dados\n                db.session.execute(text(\"VACUUM;\"))\n                db.session.execute(text(\"REINDEX;\"))\n                db.session.commit()\n                \n                if activity_logger:\n                    log_admin_action(current_user().id, current_user().username, \n                                   \"Otimiza√ß√£o do banco de dados\")\n                \n                flash(\"Banco de dados otimizado com sucesso!\", \"success\")\n                \n            elif action == \"cleanup_logs\":\n                # Limpar logs antigos\n                if activity_logger:\n                    days = int(request.form.get(\"days\", 30))\n                    deleted = activity_logger.cleanup_old_activities(days)\n                    \n                    log_admin_action(current_user().id, current_user().username, \n                                   f\"Limpeza de logs - {deleted} registros removidos\")\n                    \n                    flash(f\"Removidos {deleted} logs antigos (mais de {days} dias)!\", \"success\")\n                \n            elif action == \"cleanup_reports\":\n                # Limpar relat√≥rios antigos\n                import glob\n                report_files = glob.glob(os.path.join(app.config[\"REPORT_DIR\"], \"*.png\"))\n                report_files.extend(glob.glob(os.path.join(app.config[\"REPORT_DIR\"], \"*.pdf\")))\n                \n                removed_count = 0\n                for file in report_files:\n                    try:\n                        os.remove(file)\n                        removed_count += 1\n                    except:\n                        pass\n                \n                if activity_logger:\n                    log_admin_action(current_user().id, current_user().username, \n                                   f\"Limpeza de relat√≥rios - {removed_count} arquivos removidos\")\n                \n                flash(f\"Removidos {removed_count} arquivos de relat√≥rios!\", \"success\")\n                \n            elif action == \"backup_db\":\n                # Criar backup manual\n                if backup_manager:\n                    backup_path = backup_manager.create_backup()\n                    \n                    if activity_logger:\n                        log_admin_action(current_user().id, current_user().username, \n                                       f\"Backup manual criado: {backup_path}\")\n                    \n                    flash(f\"Backup criado: {backup_path}\", \"success\")\n                else:\n                    flash(\"Sistema de backup n√£o dispon√≠vel!\", \"warning\")\n                    \n        except Exception as e:\n            flash(f\"Erro na opera√ß√£o: {str(e)}\", \"danger\")\n        \n        return redirect(url_for(\"admin_maintenance\"))\n    \n    # Obter informa√ß√µes do sistema\n    try:\n        # Informa√ß√µes do banco\n        db_size = os.path.getsize(\"sistema_os.db\") / (1024 * 1024) if os.path.exists(\"sistema_os.db\") else 0\n        \n        # Informa√ß√µes de logs\n        log_count = 0\n        if activity_logger:\n            conn = sqlite3.connect(\"sistema_os.db\")\n            cursor = conn.cursor()\n            try:\n                cursor.execute(\"SELECT COUNT(*) FROM system_activity\")\n                log_count = cursor.fetchone()[0]\n            except:\n                pass\n            conn.close()\n        \n        # Informa√ß√µes de backups\n        backup_info = []\n        if os.path.exists(\"backups\"):\n            import glob\n            backup_files = glob.glob(\"backups/*.db\")\n            for backup in sorted(backup_files, key=os.path.getctime, reverse=True)[:5]:\n                backup_info.append({\n                    'name': os.path.basename(backup),\n                    'size': f\"{os.path.getsize(backup) / (1024 * 1024):.2f} MB\",\n                    'date': datetime.fromtimestamp(os.path.getctime(backup)).strftime('%d/%m/%Y %H:%M')\n                })\n        \n        # Informa√ß√µes de relat√≥rios\n        report_count = 0\n        report_size = 0\n        if os.path.exists(app.config[\"REPORT_DIR\"]):\n            import glob\n            report_files = glob.glob(os.path.join(app.config[\"REPORT_DIR\"], \"*\"))\n            report_count = len(report_files)\n            for file in report_files:\n                try:\n                    report_size += os.path.getsize(file)\n                except:\n                    pass\n            report_size = report_size / (1024 * 1024)  # MB\n        \n        system_info = {\n            'db_size': f\"{db_size:.2f} MB\",\n            'log_count': log_count,\n            'backup_count': len(backup_info),\n            'report_count': report_count,\n            'report_size': f\"{report_size:.2f} MB\",\n            'backup_info': backup_info\n        }\n        \n    except Exception as e:\n        system_info = {'error': str(e)}\n    \n    # Obter informa√ß√µes da licen√ßa\n    license_status = None\n    if license_manager:\n        license_status = get_license_status()\n    \n    return render_template(\"admin/maintenance.html\",\n                         app_name=APP_NAME,\n                         user=current_user(),\n                         system_info=system_info,\n                         license_status=license_status)\n\n@app.route(\"/admin/audit\")\n@login_required\n@roles_required(\"admin\")\ndef admin_audit():\n    \"\"\"P√°gina de auditoria e seguran√ßa\"\"\"\n    try:\n        # Estat√≠sticas de seguran√ßa\n        security_stats = {}\n        \n        if activity_logger:\n            conn = sqlite3.connect(\"sistema_os.db\")\n            cursor = conn.cursor()\n            \n            # Logins nas √∫ltimas 24h\n            yesterday = datetime.now() - timedelta(days=1)\n            cursor.execute(\"\"\"\n                SELECT COUNT(*) FROM system_activity \n                WHERE action_type = 'LOGIN' AND timestamp > ?\n            \"\"\", (yesterday.strftime('%Y-%m-%d %H:%M:%S'),))\n            security_stats['logins_24h'] = cursor.fetchone()[0]\n            \n            # Tentativas de login falharam (seria necess√°rio implementar)\n            security_stats['failed_logins'] = 0\n            \n            # A√ß√µes administrativas\n            cursor.execute(\"\"\"\n                SELECT COUNT(*) FROM system_activity \n                WHERE action_type = 'ADMIN' AND timestamp > ?\n            \"\"\", (yesterday.strftime('%Y-%m-%d %H:%M:%S'),))\n            security_stats['admin_actions'] = cursor.fetchone()[0]\n            \n            # Usu√°rios √∫nicos ativos\n            cursor.execute(\"\"\"\n                SELECT COUNT(DISTINCT user_id) FROM system_activity \n                WHERE timestamp > ?\n            \"\"\", (yesterday.strftime('%Y-%m-%d %H:%M:%S'),))\n            security_stats['active_users'] = cursor.fetchone()[0]\n            \n            # A√ß√µes por tipo nas √∫ltimas 24h\n            cursor.execute(\"\"\"\n                SELECT action_type, COUNT(*) FROM system_activity \n                WHERE timestamp > ?\n                GROUP BY action_type\n                ORDER BY COUNT(*) DESC\n            \"\"\", (yesterday.strftime('%Y-%m-%d %H:%M:%S'),))\n            \n            security_stats['actions_by_type'] = dict(cursor.fetchall())\n            \n            # IPs √∫nicos nas √∫ltimas 24h\n            cursor.execute(\"\"\"\n                SELECT COUNT(DISTINCT ip_address) FROM system_activity \n                WHERE timestamp > ? AND ip_address IS NOT NULL\n            \"\"\", (yesterday.strftime('%Y-%m-%d %H:%M:%S'),))\n            security_stats['unique_ips'] = cursor.fetchone()[0]\n            \n            conn.close()\n        \n        # Informa√ß√µes de usu√°rios\n        user_stats = {}\n        try:\n            result = db.session.execute(text(\"SELECT COUNT(*) FROM user\")).fetchone()\n            user_stats['total_users'] = result[0] if result else 0\n            \n            result = db.session.execute(text(\"SELECT COUNT(*) FROM user WHERE role = 'admin'\")).fetchone()\n            user_stats['admin_users'] = result[0] if result else 0\n            \n            # Usu√°rios ativos (simplified - treating all users as active for performance)\n            # The 'active' column doesn't exist in current schema, so all users are considered active\n            user_stats['active_users'] = user_stats['total_users']\n                \n        except Exception as e:\n            user_stats = {'error': str(e)}\n        \n        return render_template(\"admin/audit.html\",\n                             app_name=APP_NAME,\n                             user=current_user(),\n                             security_stats=security_stats,\n                             user_stats=user_stats)\n    \n    except Exception as e:\n        flash(f\"Erro ao carregar auditoria: {str(e)}\", \"danger\")\n        return redirect(url_for(\"admin_dashboard\"))\n\n# -------------------- LICENSE MANAGEMENT --------------------\n@app.route(\"/license\")\n@app.route(\"/license/activation\")\ndef license_activation():\n    \"\"\"P√°gina de ativa√ß√£o de licen√ßa - REATIVADA\"\"\"\n    if not license_manager:\n        flash(\"Sistema de licenciamento n√£o dispon√≠vel\", \"error\")\n        return redirect(url_for(\"login\"))\n    \n    license_status = get_license_status()\n    machine_id = license_manager.machine_id if license_manager else \"N/A\"\n    \n    return render_template(\"license/activation.html\",\n                         app_name=APP_NAME,\n                         license_status=license_status,\n                         machine_id=machine_id)\n\n@app.route(\"/license/activate\", methods=[\"POST\"])\ndef license_activate():\n    \"\"\"Processar ativa√ß√£o de licen√ßa\"\"\"\n    if not license_manager:\n        flash(\"Sistema de licenciamento n√£o dispon√≠vel\", \"error\")\n        return redirect(url_for(\"license_activation\"))\n    \n    license_key = request.form.get(\"license_key\", \"\").strip().upper()\n    customer_name = request.form.get(\"customer_name\", \"\").strip()\n    customer_email = request.form.get(\"customer_email\", \"\").strip()\n    \n    if not all([license_key, customer_name, customer_email]):\n        flash(\"Todos os campos s√£o obrigat√≥rios\", \"error\")\n        return redirect(url_for(\"license_activation\"))\n    \n    # Tentar ativar licen√ßa\n    success, message = license_manager.activate_license(license_key, customer_name, customer_email)\n    \n    if success:\n        if activity_logger:\n            log_admin_action(0, \"Sistema\", f\"Licen√ßa ativada para {customer_name}\")\n        flash(message, \"success\")\n        return redirect(url_for(\"license_activation\"))\n    else:\n        flash(message, \"error\")\n        return redirect(url_for(\"license_activation\"))\n\n@app.route(\"/license/renew\", methods=[\"POST\"])\ndef license_renew():\n    \"\"\"Renovar licen√ßa existente\"\"\"\n    if not license_manager:\n        flash(\"Sistema de licenciamento n√£o dispon√≠vel\", \"error\")\n        return redirect(url_for(\"license_activation\"))\n    \n    license_key = request.form.get(\"license_key\", \"\").strip()\n    \n    if not license_key:\n        flash(\"Chave de licen√ßa √© obrigat√≥ria\", \"error\")\n        return redirect(url_for(\"license_activation\"))\n    \n    # Tentar renovar licen√ßa\n    success, message = license_manager.renew_license(license_key)\n    \n    if success:\n        if activity_logger:\n            log_admin_action(0, \"Sistema\", \"Licen√ßa renovada\")\n        flash(message, \"success\")\n    else:\n        flash(message, \"error\")\n    \n    return redirect(url_for(\"license_activation\"))\n\n@app.route(\"/license/status\")\ndef license_status():\n    \"\"\"API para verificar status da licen√ßa\"\"\"\n    if not license_manager:\n        return json.dumps({\"licensed\": False, \"error\": \"Sistema n√£o dispon√≠vel\"})\n    \n    status = get_license_status()\n    return json.dumps(status)\n\n@app.route(\"/admin/license\")\n@login_required\n@roles_required(\"admin\")\ndef admin_license():\n    \"\"\"Painel administrativo de licen√ßas\"\"\"\n    if not license_manager:\n        flash(\"Sistema de licenciamento n√£o dispon√≠vel\", \"error\")\n        return redirect(url_for(\"admin_dashboard\"))\n    \n    license_info = license_manager.get_license_info()\n    \n    # Verificar recursos dispon√≠veis\n    features_status = {}\n    if license_info['licensed'] and 'features' in license_info:\n        features = license_info['features']\n        features_status = {\n            'max_users': features.get('max_users', 10),\n            'max_tickets': features.get('max_tickets', 100),\n            'premium_reports': features.get('premium_reports', False),\n            'api_access': features.get('api_access', False),\n            'white_label': features.get('white_label', False)\n        }\n    \n    # Obter licen√ßas dispon√≠veis e vendidas\n    available_licenses = license_generator.get_available_licenses()\n    sold_licenses = license_generator.get_sold_licenses()\n    \n    return render_template(\"admin/license_management.html\",\n                         app_name=APP_NAME,\n                         user=current_user(),\n                         license_info=license_info,\n                         features_status=features_status,\n                         available_licenses=available_licenses,\n                         sold_licenses=sold_licenses)\n\n@app.route(\"/admin/license/generate\", methods=[\"POST\"])\n@login_required\n@roles_required(\"admin\")\ndef admin_license_generate():\n    \"\"\"Gerar nova chave de licen√ßa\"\"\"\n    if not license_generator:\n        flash(\"Sistema de gera√ß√£o n√£o dispon√≠vel\", \"error\")\n        return redirect(url_for(\"admin_license\"))\n    \n    license_type = request.form.get(\"license_type\", \"standard\")\n    customer_name = request.form.get(\"customer_name\", \"\").strip()\n    customer_email = request.form.get(\"customer_email\", \"\").strip()\n    notes = request.form.get(\"notes\", \"\").strip()\n    \n    # Definir pre√ßo baseado no tipo\n    prices = {\n        'basic': 100.0,\n        'standard': 200.0,\n        'premium': 500.0,\n        'enterprise': 1000.0\n    }\n    \n    price = prices.get(license_type, 200.0)\n    \n    result = license_generator.create_license(\n        license_type=license_type,\n        customer_name=customer_name if customer_name else None,\n        customer_email=customer_email if customer_email else None,\n        price=price,\n        notes=notes if notes else None\n    )\n    \n    if result['success']:\n        if activity_logger:\n            log_admin_action(\n                session.get(\"user_id\", 0),\n                session.get(\"username\", \"Sistema\"),\n                f\"Chave gerada: {result['license_key']} - Tipo: {license_type}\"\n            )\n        flash(f\"Chave de licen√ßa gerada: {result['license_key']}\", \"success\")\n    else:\n        flash(result['message'], \"error\")\n    \n    return redirect(url_for(\"admin_license\"))\n\n@app.route(\"/admin/license/bulk\", methods=[\"POST\"])\n@login_required\n@roles_required(\"admin\")\ndef admin_license_bulk():\n    \"\"\"Gerar licen√ßas em lote\"\"\"\n    if not license_generator:\n        flash(\"Sistema de gera√ß√£o n√£o dispon√≠vel\", \"error\")\n        return redirect(url_for(\"admin_license\"))\n    \n    try:\n        count = int(request.form.get(\"count\", 10))\n        license_type = request.form.get(\"license_type\", \"standard\")\n        \n        if count > 100:\n            flash(\"M√°ximo 100 licen√ßas por vez\", \"error\")\n            return redirect(url_for(\"admin_license\"))\n        \n        created_keys = license_generator.bulk_create_licenses(count, license_type)\n        \n        if activity_logger:\n            log_admin_action(\n                session.get(\"user_id\", 0),\n                session.get(\"username\", \"Sistema\"),\n                f\"Geradas {len(created_keys)} chaves em lote - Tipo: {license_type}\"\n            )\n        \n        flash(f\"{len(created_keys)} chaves de licen√ßa geradas com sucesso!\", \"success\")\n        \n    except ValueError:\n        flash(\"Quantidade inv√°lida\", \"error\")\n    except Exception as e:\n        flash(f\"Erro ao gerar licen√ßas: {str(e)}\", \"error\")\n    \n    return redirect(url_for(\"admin_license\"))\n\n@app.route(\"/admin/sistema\", methods=[\"GET\", \"POST\"])\n@login_required\n@roles_required(\"admin\")\ndef admin_sistema():\n    if request.method == \"POST\":\n        # Handle configuration updates\n        action = request.form.get(\"action\")\n        \n        if action == \"optimize_db\":\n            # Optimize database\n            try:\n                db.session.execute(text(\"VACUUM;\"))\n                db.session.commit()\n                flash(\"Banco de dados otimizado com sucesso!\", \"success\")\n            except Exception as e:\n                flash(f\"Erro ao otimizar banco: {str(e)}\", \"danger\")\n        \n        elif action == \"clear_logs\":\n            # Clear old reports from static folder\n            try:\n                import glob\n                report_files = glob.glob(os.path.join(app.config[\"REPORT_DIR\"], \"*.png\"))\n                report_files.extend(glob.glob(os.path.join(app.config[\"REPORT_DIR\"], \"*.pdf\")))\n                removed_count = 0\n                for file in report_files:\n                    try:\n                        os.remove(file)\n                        removed_count += 1\n                    except:\n                        pass\n                flash(f\"Removidos {removed_count} arquivos de relat√≥rios antigos!\", \"success\")\n            except Exception as e:\n                flash(f\"Erro ao limpar arquivos: {str(e)}\", \"danger\")\n        \n        return redirect(url_for(\"admin_sistema\"))\n    \n    # Get system statistics\n    stats = {}\n    try:\n        # Database stats\n        result = db.session.execute(text(\"SELECT COUNT(*) FROM chamado\")).fetchone()\n        stats['total_chamados'] = result[0] if result else 0\n        \n        result = db.session.execute(text(\"SELECT COUNT(*) FROM user\")).fetchone()\n        stats['total_usuarios'] = result[0] if result else 0\n        \n        result = db.session.execute(text(\"SELECT COUNT(*) FROM chamado WHERE status = 'aberto'\")).fetchone()\n        stats['chamados_abertos'] = result[0] if result else 0\n        \n        # Database file size\n        db_size = os.path.getsize(\"sistema_os.db\") / (1024 * 1024)  # MB\n        stats['db_size'] = f\"{db_size:.2f} MB\"\n        \n        # Report files count\n        import glob\n        report_files = len(glob.glob(os.path.join(app.config[\"REPORT_DIR\"], \"*\")))\n        stats['report_files'] = report_files\n        \n    except Exception as e:\n        stats['error'] = str(e)\n    \n    return render_template(\"admin_sistema.html\", stats=stats, app_name=APP_NAME, user=current_user())\n\n# -------------------- RELAT√ìRIOS --------------------\n@app.route(\"/relatorios\", methods=[\"GET\",\"POST\"])\n@login_required\n@permission_required(\"view_reports\")\ndef relatorios():\n    u = current_user()\n    # filtros\n    data_ini = request.values.get(\"data_ini\",\"\")\n    data_fim = request.values.get(\"data_fim\",\"\")\n    status = request.values.get(\"status\",\"\")\n    setor = request.values.get(\"setor\",\"\")\n    responsavel = request.values.get(\"responsavel\",\"\")\n    aberto_por = request.values.get(\"aberto_por\",\"\")\n    urgencia = request.values.get(\"urgencia\",\"\")\n\n    # Optimize query with eager loading to prevent N+1 problems\n    q = Chamado.query.options(\n        joinedload(Chamado.usuario),\n        joinedload(Chamado.fechado_por)\n    )\n    if setor:\n        # Suporte a dados legados: filtrar tanto por name interno quanto display_name\n        # para garantir compatibilidade com dados antigos\n        try:\n            sector_obj = Sector.query.filter(\n                (Sector.name == setor) | (Sector.display_name == setor)\n            ).first()\n            \n            if sector_obj:\n                # Filtrar por ambos os valores poss√≠veis para m√°xima compatibilidade\n                q = q.filter(\n                    (Chamado.setor == sector_obj.name) | \n                    (Chamado.setor == sector_obj.display_name)\n                )\n            else:\n                # Fallback: filtrar pelo valor exato selecionado\n                q = q.filter(Chamado.setor == setor)\n        except:\n            # Em caso de erro, usar filtro simples\n            q = q.filter(Chamado.setor == setor)\n    if u.is_operator_like() and not u.is_admin():\n        user_sectors = u.get_sectors()\n        if user_sectors:\n            # Incluir compatibilidade com dados legados: tanto name quanto display_name\n            allowed_sector_values = []\n            for sector in user_sectors:\n                allowed_sector_values.append(sector.name)\n                allowed_sector_values.append(sector.display_name)\n            # Remover duplicados\n            allowed_sector_values = list(set(allowed_sector_values))\n            q = q.filter(Chamado.setor.in_(allowed_sector_values))\n        else:\n            # Operator with no sectors sees no tickets\n            q = q.filter(False)\n    if data_ini:\n        try:\n            di = datetime.strptime(data_ini, \"%Y-%m-%d\")\n            q = q.filter(Chamado.criado_em >= di)\n        except:\n            pass\n    if data_fim:\n        try:\n            df = datetime.strptime(data_fim, \"%Y-%m-%d\")\n            df = df.replace(hour=23, minute=59, second=59)\n            q = q.filter(Chamado.criado_em <= df)\n        except:\n            pass\n    if status:\n        q = q.filter(Chamado.status == status)\n    if responsavel and responsavel.isdigit():\n        q = q.filter(Chamado.fechado_por_id == int(responsavel))\n    if aberto_por and aberto_por.isdigit():\n        q = q.filter(Chamado.usuario_id == int(aberto_por))\n    if urgencia:\n        q = q.filter(Chamado.urgencia == urgencia)\n\n    chamados = q.order_by(Chamado.criado_em.asc()).all()\n\n    # dataframe\n    rows = []\n    for c in chamados:\n        duracao_h = None\n        if c.fechado_em:\n            duracao_h = (c.fechado_em - c.criado_em).total_seconds()/3600.0\n        rows.append({\n            \"ID\": c.id,\n            \"T√≠tulo\": c.titulo,\n            \"Status\": c.status,\n            \"Criado em\": c.criado_em,\n            \"Fechado em\": c.fechado_em,\n            \"Dura√ß√£o(h)\": duracao_h,\n            \"Aberto por\": c.usuario.username if c.usuario else \"\",\n            \"Fechado por\": c.fechado_por.username if c.fechado_por else \"\",\n            \"Setor\": (c.setor or '‚Äî'),\n            \"Setor do Solicitante\": (c.usuario_setor or '‚Äî')\n        })\n    df = pd.DataFrame(rows)\n\n    # gerar gr√°ficos (salvos como PNG na pasta static/relatorios)\n    chart_files = []\n    if not df.empty:\n        # OS por m√™s\n        df[\"Mes\"] = pd.to_datetime(df[\"Criado em\"]).dt.to_period(\"M\").astype(str)\n        qty_by_month = df.groupby(\"Mes\")[\"ID\"].count().sort_index()\n\n        fig1 = plt.figure()\n        qty_by_month.plot(kind=\"bar\")\n        plt.title(\"Quantidade de OS por m√™s\")\n        plt.xlabel(\"M√™s\")\n        plt.ylabel(\"Qtd de OS\")\n        file1 = os.path.join(app.config[\"REPORT_DIR\"], f\"{uuid4_hex()}_qtd_mes.png\")\n        fig1.savefig(file1, bbox_inches=\"tight\")\n        plt.close(fig1)\n        chart_files.append(file1)\n\n        # M√©dias por m√™s (fechadas)\n        df_closed = df.dropna(subset=[\"Fechado em\"]).copy()\n        if not df_closed.empty:\n            df_closed[\"MesFech\"] = pd.to_datetime(df_closed[\"Fechado em\"]).dt.to_period(\"M\").astype(str)\n            mean_by_month = df_closed.groupby(\"MesFech\")[\"Dura√ß√£o(h)\"].mean().sort_index()\n            fig2 = plt.figure()\n            mean_by_month.plot(kind=\"line\", marker=\"o\")\n            plt.title(\"Tempo m√©dio de atendimento (h) por m√™s\")\n            plt.xlabel(\"M√™s\")\n            plt.ylabel(\"M√©dia (h)\")\n            file2 = os.path.join(app.config[\"REPORT_DIR\"], f\"{uuid4_hex()}_media_mes.png\")\n            fig2.savefig(file2, bbox_inches=\"tight\")\n            plt.close(fig2)\n            chart_files.append(file2)\n\n        # Distribui√ß√£o por status\n        by_status = df[\"Status\"].value_counts()\n        fig3 = plt.figure()\n        by_status.plot(kind=\"pie\", autopct=\"%1.1f%%\")\n        plt.title(\"Distribui√ß√£o por status\")\n        plt.ylabel(\"\")\n        file3 = os.path.join(app.config[\"REPORT_DIR\"], f\"{uuid4_hex()}_status.png\")\n        fig3.savefig(file3, bbox_inches=\"tight\")\n        plt.close(fig3)\n        chart_files.append(file3)\n\n        # OS por operador (fechou) - contagem\n        if not df_closed.empty:\n            by_op_count = df_closed[\"Fechado por\"].value_counts()\n            fig5 = plt.figure()\n            by_op_count.plot(kind=\"bar\")\n            plt.title(\"OS fechadas por operador\")\n            plt.xlabel(\"Operador\")\n            plt.ylabel(\"Qtd\")\n            file5 = os.path.join(app.config[\"REPORT_DIR\"], f\"{uuid4_hex()}_qtd_operador.png\")\n            fig5.savefig(file5, bbox_inches=\"tight\")\n            plt.close(fig5)\n            chart_files.append(file5)\n\n            # Tempo total por operador\n            by_op_hours = df_closed.groupby(\"Fechado por\")[\"Dura√ß√£o(h)\"].sum().sort_values(ascending=False)\n            fig4 = plt.figure()\n            by_op_hours.plot(kind=\"bar\")\n            plt.title(\"Tempo total por operador (h)\")\n            plt.xlabel(\"Operador\")\n            plt.ylabel(\"Horas\")\n            file4 = os.path.join(app.config[\"REPORT_DIR\"], f\"{uuid4_hex()}_tempo_operador.png\")\n            fig4.savefig(file4, bbox_inches=\"tight\")\n            plt.close(fig4)\n            chart_files.append(file4)\n\n            # Top 5 OS mais demoradas\n            top5 = df_closed.sort_values(\"Dura√ß√£o(h)\", ascending=False).head(5).set_index(\"ID\")[\"Dura√ß√£o(h)\"]\n            if not top5.empty:\n                fig6 = plt.figure()\n                top5.plot(kind=\"bar\")\n                plt.title(\"Top 5 OS mais demoradas (h)\")\n                plt.xlabel(\"OS\")\n                plt.ylabel(\"Horas\")\n                file6 = os.path.join(app.config[\"REPORT_DIR\"], f\"{uuid4_hex()}_top5.png\")\n                fig6.savefig(file6, bbox_inches=\"tight\")\n                plt.close(fig6)\n                chart_files.append(file6)\n\n    # listar operadores e usu√°rios para filtros\n    operadores = User.query.filter(User.role.in_([\"operador\",\"admin\"])).order_by(User.username).all()\n    usuarios = User.query.filter(User.role.in_([\"usuario\",\"operador\",\"admin\"])).order_by(User.username).all()\n    \n    # Buscar setores dinamicamente da tabela Sector\n    try:\n        setores_db = Sector.query.filter_by(active=True).order_by(Sector.display_name).all()\n        setores = [{'name': sector.name, 'display_name': sector.display_name} for sector in setores_db]\n    except:\n        # Fallback para setores padr√£o se a tabela n√£o existir\n        setores = [\n            {'name': 'T.I', 'display_name': 'T.I'},\n            {'name': 'Manuten√ß√£o', 'display_name': 'Manuten√ß√£o'},\n            {'name': 'CCIH / SESMT / Manuten√ß√£o de Ar condicionado', 'display_name': 'CCIH / SESMT / Manuten√ß√£o de Ar condicionado'},\n            {'name': 'Telefonia e outros servi√ßos', 'display_name': 'Telefonia e outros servi√ßos'}\n        ]\n\n    # KPIs\n    total_abertas = int((df[\"Status\"] == \"Aberto\").sum()) if not df.empty else 0\n    total_fechadas = int((df[\"Status\"] == \"Fechado\").sum()) if not df.empty else 0\n    media_h = round(float(df[\"Dura√ß√£o(h)\"].dropna().mean()), 2) if not df.empty and df[\"Dura√ß√£o(h)\"].notna().any() else 0.0\n    mediana_h = round(float(df[\"Dura√ß√£o(h)\"].dropna().median()), 2) if not df.empty and df[\"Dura√ß√£o(h)\"].notna().any() else 0.0\n    taxa_fechamento = round((total_fechadas / (len(df) if not df.empty else 1)) * 100, 1) if not df.empty else 0.0\n    total_horas = round(float(df[\"Dura√ß√£o(h)\"].dropna().sum()), 2) if not df.empty else 0.0\n\n    return render_template(\n        \"relatorios.html\",\n        app_name=APP_NAME,\n        user=u,\n        chamados=chamados,\n        data_ini=data_ini, data_fim=data_fim, status=status, responsavel=responsavel, aberto_por=aberto_por,\n        setor=setor, urgencia=urgencia,\n        operadores=operadores, usuarios=usuarios, setores=setores,\n        chart_files=[f.replace(\"\\\\\",\"/\") for f in chart_files],\n        total_abertas=total_abertas, total_fechadas=total_fechadas, media_h=media_h,\n        mediana_h=mediana_h, taxa_fechamento=taxa_fechamento, total_horas=total_horas\n    )\n\n# Exporta√ß√µes com filtros atuais\ndef _filtered_dataframe(params):\n    data_ini = params.get(\"data_ini\",\"\")\n    data_fim = params.get(\"data_fim\",\"\")\n    status = params.get(\"status\",\"\")\n    responsavel = params.get(\"responsavel\",\"\")\n    aberto_por = params.get(\"aberto_por\",\"\")\n    setor = params.get(\"setor\",\"\")\n    urgencia = params.get(\"urgencia\",\"\")\n    \n    # Get current user and apply sector restrictions\n    u = current_user()\n    q = Chamado.query\n    \n    # Apply operator sector restrictions FIRST\n    if u.is_operator_like() and not u.is_admin() and not u.has_permission('view_all'):\n        user_sector_names = u.get_sector_names()\n        if user_sector_names:\n            q = q.filter(Chamado.setor.in_(user_sector_names))\n        else:\n            # Operator with no sectors sees no tickets\n            q = q.filter(False)\n    \n    # Then apply additional filters\n    if setor:\n        q = q.filter(Chamado.setor == setor)\n    if data_ini:\n        try:\n            di = datetime.strptime(data_ini, \"%Y-%m-%d\")\n            q = q.filter(Chamado.criado_em >= di)\n        except:\n            pass\n    if data_fim:\n        try:\n            df_ = datetime.strptime(data_fim, \"%Y-%m-%d\").replace(hour=23, minute=59, second=59)\n            q = q.filter(Chamado.criado_em <= df_)\n        except:\n            pass\n    if status:\n        q = q.filter(Chamado.status == status)\n    if responsavel and str(responsavel).isdigit():\n        q = q.filter(Chamado.fechado_por_id == int(responsavel))\n    if aberto_por and str(aberto_por).isdigit():\n        q = q.filter(Chamado.usuario_id == int(aberto_por))\n    if urgencia:\n        q = q.filter(Chamado.urgencia == urgencia)\n\n    chamados = q.order_by(Chamado.criado_em.asc()).all()\n    rows = []\n    for c in chamados:\n        duracao_h = None\n        if c.fechado_em:\n            duracao_h = round((c.fechado_em - c.criado_em).total_seconds()/3600.0, 2)\n        rows.append([\n            c.id,\n            c.criado_em,\n            c.usuario.username if c.usuario else \"\",\n            c.setor or '‚Äî',\n            getattr(c, 'ramal', '') or \"\",\n            c.descricao,\n            c.status,\n            c.fechado_em if c.fechado_em else \"\",\n            c.fechado_por.username if c.fechado_por else \"\",\n            duracao_h,\n            getattr(c, 'cdc', '') or \"\"\n        ])\n    df = pd.DataFrame(rows, columns=[\"ID\",\"Abertura\",\"Aberto por\",\"Setor\",\"Ramal\",\"Descri√ß√£o\",\"Status\",\"Fechamento\",\"Fechado por\",\"Dura√ß√£o(h)\",\"CDC\"])\n    \n    # Handle NaT values for Excel export compatibility\n    df['Abertura'] = pd.to_datetime(df['Abertura'])\n    df['Fechamento'] = pd.to_datetime(df['Fechamento'], errors='coerce')\n    \n    return df\n\n@app.route(\"/export_xlsx\")\n@login_required\n@permission_required(\"view_reports\")\ndef export_xlsx():\n    df = _filtered_dataframe(request.args)\n    output = io.BytesIO()\n    \n    # Create Excel with professional formatting\n    with pd.ExcelWriter(output, engine=\"xlsxwriter\") as writer:\n        df.to_excel(writer, index=False, sheet_name=\"Relat√≥rio de OS\", startrow=4)\n        \n        workbook = writer.book\n        worksheet = writer.sheets['Relat√≥rio de OS']\n        \n        # Header format\n        header_format = workbook.add_format({\n            'bold': True,\n            'text_wrap': True,\n            'valign': 'top',\n            'fg_color': '#2E86AB',\n            'font_color': 'white',\n            'border': 1\n        })\n        \n        # Description text wrap formats (for alternating rows)\n        wrap_format = workbook.add_format({\n            'text_wrap': True,\n            'valign': 'top',\n            'border': 1\n        })\n        \n        wrap_alt_format = workbook.add_format({\n            'text_wrap': True,\n            'valign': 'top',\n            'border': 1,\n            'bg_color': '#F8F9FA'\n        })\n        \n        # Title format\n        title_format = workbook.add_format({\n            'bold': True,\n            'font_size': 16,\n            'align': 'center',\n            'valign': 'vcenter'\n        })\n        \n        # Date format\n        date_format = workbook.add_format({\n            'num_format': 'dd/mm/yyyy hh:mm',\n            'border': 1\n        })\n        \n        # Date format with alternating background\n        date_alt_format = workbook.add_format({\n            'num_format': 'dd/mm/yyyy hh:mm',\n            'bg_color': '#F8F9FA',\n            'border': 1\n        })\n        \n        # Alternating row format\n        alt_row_format = workbook.add_format({\n            'bg_color': '#F8F9FA',\n            'border': 1\n        })\n        \n        # Add title (cover all columns - now 11 columns A to K)\n        worksheet.merge_range('A1:K2', 'Sistemas Olivium - Relat√≥rio de OS', title_format)\n        worksheet.write('A3', f'Gerado em: {now_brazil().strftime(\"%d/%m/%Y %H:%M\")}')\n        \n        # Format headers\n        for col_num, value in enumerate(df.columns.values):\n            worksheet.write(4, col_num, value, header_format)\n        \n        # Format data rows with proper date handling\n        for row_num in range(len(df)):\n            for col_num, col_name in enumerate(df.columns):\n                value = df.iloc[row_num, col_num]\n                \n                # Handle date columns specifically\n                if col_name in ['Abertura', 'Fechamento'] and pd.notna(value):\n                    format_to_use = date_format if row_num % 2 == 0 else date_alt_format\n                    worksheet.write_datetime(row_num + 5, col_num, value, format_to_use)\n                elif value is None or pd.isna(value):\n                    # Write empty string for None/NaN values\n                    format_to_use = alt_row_format if row_num % 2 == 1 else None\n                    worksheet.write(row_num + 5, col_num, \"\", format_to_use)\n                else:\n                    # Regular data with special handling for description column\n                    if col_name == 'Descri√ß√£o':\n                        # Apply text wrap to description column with alternating backgrounds\n                        format_to_use = wrap_format if row_num % 2 == 0 else wrap_alt_format  \n                        worksheet.write(row_num + 5, col_num, value, format_to_use)\n                    else:\n                        format_to_use = alt_row_format if row_num % 2 == 1 else None\n                        worksheet.write(row_num + 5, col_num, value, format_to_use)\n        \n        # Set proper column widths matching the new column order\n        worksheet.set_column('A:A', 8)   # ID column - narrow\n        worksheet.set_column('B:B', 20)  # Abertura - wider for date/time\n        worksheet.set_column('C:C', 15)  # Aberto por column\n        worksheet.set_column('D:D', 20)  # Setor column\n        worksheet.set_column('E:E', 10)  # Ramal column - narrow\n        worksheet.set_column('F:F', 50)  # Descri√ß√£o column - wider for long descriptions\n        worksheet.set_column('G:G', 15)  # Status column\n        worksheet.set_column('H:H', 20)  # Fechamento - wider for date/time\n        worksheet.set_column('I:I', 15)  # Fechado por column\n        worksheet.set_column('J:J', 12)  # Dura√ß√£o(h) column\n        worksheet.set_column('K:K', 10)  # CDC column\n    \n    output.seek(0)\n    return send_file(output, as_attachment=True, download_name=f\"relatorio_os_{now_brazil().strftime('%Y%m%d_%H%M')}.xlsx\", \n                     mimetype='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')\n\n@app.route(\"/relatorios/export/csv\")\n@login_required\n@permission_required(\"view_reports\")\ndef export_csv():\n    df = _filtered_dataframe(request.args)\n    output = io.StringIO()\n    df.to_csv(output, index=False)\n    output.seek(0)\n    return send_file(io.BytesIO(output.getvalue().encode(\"utf-8-sig\")), as_attachment=True, \n                     download_name=\"relatorio_os.csv\", mimetype=\"text/csv\")\n\n@app.route(\"/export_pdf\")\n@login_required\n@permission_required(\"view_reports\")\ndef export_pdf():\n    df = _filtered_dataframe(request.args)\n    packet = io.BytesIO()\n    c = canvas.Canvas(packet, pagesize=A4)\n    width, height = A4\n    \n    # Title and header\n    y = height - 80\n    c.setFont(\"Helvetica-Bold\", 18)\n    c.drawCentredString(width/2, y, \"Sistemas Olivium\")\n    y -= 25\n    c.setFont(\"Helvetica-Bold\", 14)\n    c.drawCentredString(width/2, y, \"Relat√≥rio de Ordens de Servi√ßo\")\n    y -= 20\n    c.setFont(\"Helvetica\", 10)\n    c.drawCentredString(width/2, y, f\"Gerado em: {now_brazil().strftime('%d/%m/%Y %H:%M')}\")\n    y -= 30\n    \n    # Draw header line\n    c.setStrokeColorRGB(0.2, 0.5, 0.7)\n    c.setLineWidth(2)\n    c.line(50, y, width-50, y)\n    y -= 20\n    \n    # Table headers\n    c.setFont(\"Helvetica-Bold\", 8)\n    headers = [\"ID\", \"Descri√ß√£o\", \"Status\", \"Setor\", \"Set.Solic\", \"Abertura\", \"Fechamento\", \"Dur.(h)\", \"Aberto por\", \"Ramal\"]\n    x_positions = [50, 80, 140, 180, 210, 240, 280, 310, 350, 390]\n    \n    for i, header in enumerate(headers):\n        c.drawString(x_positions[i], y, header)\n    y -= 5\n    c.line(50, y, width-50, y)\n    y -= 15\n    \n    # Table data\n    c.setFont(\"Helvetica\", 7)\n    row_color = True\n    \n    for _, row in df.iterrows():\n        if y < 100:\n            c.showPage()\n            y = height - 50\n            # Redraw headers on new page\n            c.setFont(\"Helvetica-Bold\", 8)\n            for i, header in enumerate(headers):\n                c.drawString(x_positions[i], y, header)\n            y -= 5\n            c.line(50, y, width-50, y)\n            y -= 15\n            c.setFont(\"Helvetica\", 7)\n        \n        # Alternate row background\n        if row_color:\n            c.setFillColorRGB(0.97, 0.97, 0.97)\n            c.rect(50, y-10, width-100, 12, fill=1, stroke=0)\n        \n        c.setFillColorRGB(0, 0, 0)  # Reset to black for text\n        \n        # Handle optional columns safely\n        setor_solicitante = \"\"\n        if \"Setor do Solicitante\" in df.columns and pd.notna(row[\"Setor do Solicitante\"]) and row[\"Setor do Solicitante\"] != '‚Äî':\n            setor_solicitante = str(row[\"Setor do Solicitante\"])[:8]\n        \n        data = [\n            str(row[\"ID\"]),\n            str(row[\"Descri√ß√£o\"])[:15],\n            str(row[\"Status\"]),\n            str(row[\"Setor\"])[:6] if row[\"Setor\"] != '‚Äî' else \"\",\n            setor_solicitante,\n            row[\"Abertura\"].strftime(\"%d/%m\") if pd.notna(row[\"Abertura\"]) else \"\",\n            row[\"Fechamento\"].strftime(\"%d/%m\") if pd.notna(row[\"Fechamento\"]) else \"\",\n            f'{row[\"Dura√ß√£o(h)\"]:.1f}' if pd.notna(row[\"Dura√ß√£o(h)\"]) else \"\",\n            str(row[\"Aberto por\"])[:8] if row[\"Aberto por\"] else \"\",\n            str(row[\"Ramal\"]) if row[\"Ramal\"] else \"\"\n        ]\n        \n        for i, value in enumerate(data):\n            c.drawString(x_positions[i], y, value)\n        \n        y -= 12\n        row_color = not row_color\n    \n    # Footer\n    c.setFont(\"Helvetica\", 8)\n    c.drawCentredString(width/2, 30, f\"Total de registros: {len(df)}\")\n    \n    c.save()\n    packet.seek(0)\n    return send_file(packet, as_attachment=True, download_name=f\"relatorio_os_{now_brazil().strftime('%Y%m%d_%H%M')}.pdf\", \n                     mimetype=\"application/pdf\")\n\n# util\ndef uuid4_hex():\n    return uuid.uuid4().hex\n\n# -------------------- WEBSOCKET HELPERS --------------------\ndef emit_ticket_update(ticket_data, event_type):\n    \"\"\"Emits ticket updates to clients with proper sector filtering\"\"\"\n    # For now, emit to all clients - client-side filtering should handle sector restrictions\n    # In a production environment, you'd want to track user sessions and filter server-side\n    socketio.emit('ticket_update', {\n        'event_type': event_type,\n        'ticket': ticket_data\n    }, namespace='/')\n    \n    # TODO: Implement server-side session tracking for sector-based filtering\n    # This would require storing user sector info in socket sessions\n\ndef ticket_to_dict(chamado):\n    \"\"\"Convert a ticket object to dictionary for JSON emission\"\"\"\n    return {\n        'id': chamado.id,\n        'titulo': chamado.titulo,\n        'descricao': chamado.descricao,\n        'status': chamado.status,\n        'criado_em': chamado.criado_em.strftime('%Y-%m-%d %H:%M:%S') if chamado.criado_em else None,\n        'fechado_em': chamado.fechado_em.strftime('%Y-%m-%d %H:%M:%S') if chamado.fechado_em else None,\n        'setor': chamado.setor,\n        'usuario_setor': chamado.usuario_setor,\n        'usuario': chamado.usuario.username if chamado.usuario else None,\n        'fechado_por': chamado.fechado_por.username if chamado.fechado_por else None\n    }\n\n# -------------------- ADMIN MENU SYSTEM --------------------\n\n@app.route(\"/admin\")\n@login_required\n@roles_required(\"admin\")\ndef admin_dashboard():\n    \"\"\"Admin dashboard with system overview\"\"\"\n    # Get system statistics\n    total_users = User.query.filter_by(active=True).count() if hasattr(User, 'active') else User.query.count()\n    total_tickets = Chamado.query.count()\n    open_tickets = Chamado.query.filter_by(status='Aberto').count()\n    closed_tickets = Chamado.query.filter_by(status='Fechado').count()\n    urgent_tickets = Chamado.query.filter_by(urgencia='Urgente').count() if hasattr(Chamado, 'urgencia') else 0\n    \n    # Recent activity (last 7 days)\n    seven_days_ago = now_brazil() - pd.Timedelta(days=7)\n    recent_tickets = Chamado.query.filter(Chamado.criado_em >= seven_days_ago).count()\n    \n    stats = {\n        'total_users': total_users,\n        'total_tickets': total_tickets,\n        'open_tickets': open_tickets,\n        'closed_tickets': closed_tickets,\n        'urgent_tickets': urgent_tickets,\n        'recent_tickets': recent_tickets\n    }\n    \n    return render_template(\"admin/dashboard.html\", app_name=APP_NAME, user=current_user(), stats=stats)\n\n# -------------------- ADMIN SECTOR MANAGEMENT --------------------\n\n@app.route(\"/admin/sectors\")\n@login_required\n@roles_required(\"admin\")\ndef admin_sectors():\n    \"\"\"Manage sectors\"\"\"\n    sectors = Sector.query.filter_by(active=True).order_by(Sector.display_name).all()\n    return render_template(\"admin/sectors.html\", app_name=APP_NAME, user=current_user(), sectors=sectors)\n\n@app.route(\"/admin/sectors/new\", methods=[\"GET\", \"POST\"])\n@login_required\n@roles_required(\"admin\")\ndef admin_sectors_new():\n    \"\"\"Create new sector\"\"\"\n    if request.method == \"POST\":\n        name = request.form.get(\"name\", \"\").strip()\n        display_name = request.form.get(\"display_name\", \"\").strip()\n        description = request.form.get(\"description\", \"\").strip()\n        \n        if not name or not display_name:\n            flash(\"Nome interno e nome de exibi√ß√£o s√£o obrigat√≥rios.\", \"danger\")\n            return render_template(\"admin/sector_form.html\", app_name=APP_NAME, user=current_user())\n        \n        # Check if there's an existing sector with the same name (active or inactive)\n        existing_sector = Sector.query.filter_by(name=name).first()\n        \n        if existing_sector:\n            if existing_sector.active:\n                flash(\"J√° existe um setor ativo com este nome interno.\", \"danger\")\n                return render_template(\"admin/sector_form.html\", app_name=APP_NAME, user=current_user())\n            else:\n                # Reactivate the inactive sector\n                existing_sector.active = True\n                existing_sector.display_name = display_name\n                existing_sector.description = description\n                db.session.commit()\n                flash(\"Setor reativado com sucesso.\", \"success\")\n        else:\n            # Create new sector\n            sector = Sector(name=name, display_name=display_name, description=description)\n            db.session.add(sector)\n            db.session.commit()\n            flash(\"Setor criado com sucesso.\", \"success\")\n        return redirect(url_for(\"admin_sectors\"))\n    \n    return render_template(\"admin/sector_form.html\", app_name=APP_NAME, user=current_user(), sector=None)\n\n@app.route(\"/admin/sectors/edit/<int:sector_id>\", methods=[\"GET\", \"POST\"])\n@login_required\n@roles_required(\"admin\")\ndef admin_sectors_edit(sector_id):\n    \"\"\"Edit sector\"\"\"\n    sector = Sector.query.get_or_404(sector_id)\n    \n    if request.method == \"POST\":\n        name = request.form.get(\"name\", \"\").strip()\n        display_name = request.form.get(\"display_name\", \"\").strip()\n        description = request.form.get(\"description\", \"\").strip()\n        \n        if not name or not display_name:\n            flash(\"Nome interno e nome de exibi√ß√£o s√£o obrigat√≥rios.\", \"danger\")\n            return render_template(\"admin/sector_form.html\", app_name=APP_NAME, user=current_user(), sector=sector)\n        \n        # Check for duplicate names (excluding current sector, only among active sectors)\n        existing = Sector.query.filter(Sector.name == name, Sector.id != sector_id, Sector.active == True).first()\n        if existing:\n            flash(\"J√° existe outro setor com este nome interno.\", \"danger\")\n            return render_template(\"admin/sector_form.html\", app_name=APP_NAME, user=current_user(), sector=sector)\n        \n        sector.name = name\n        sector.display_name = display_name\n        sector.description = description\n        db.session.commit()\n        flash(\"Setor atualizado com sucesso.\", \"success\")\n        return redirect(url_for(\"admin_sectors\"))\n    \n    return render_template(\"admin/sector_form.html\", app_name=APP_NAME, user=current_user(), sector=sector)\n\n@app.route(\"/admin/sectors/delete/<int:sector_id>\", methods=[\"POST\"])\n@login_required\n@roles_required(\"admin\")\ndef admin_sectors_delete(sector_id):\n    \"\"\"Delete sector\"\"\"\n    sector = Sector.query.get_or_404(sector_id)\n    \n    # Check if sector is being used\n    tickets_count = Chamado.query.filter_by(setor=sector.name).count()\n    users_count = User.query.filter_by(setor=sector.name).count()\n    \n    if tickets_count > 0 or users_count > 0:\n        flash(f\"N√£o √© poss√≠vel excluir o setor. Ele est√° sendo usado por {tickets_count} chamados e {users_count} usu√°rios.\", \"danger\")\n        return redirect(url_for(\"admin_sectors\"))\n    \n    sector.active = False  # Soft delete\n    db.session.commit()\n    flash(\"Setor removido com sucesso.\", \"success\")\n    return redirect(url_for(\"admin_sectors\"))\n\n# -------------------- ADMIN USER MANAGEMENT --------------------\n\n@app.route(\"/admin/users\")\n@login_required\n@roles_required(\"admin\")\ndef admin_users():\n    \"\"\"Advanced user management\"\"\"\n    users = User.query.order_by(User.username).all()\n    roles = Role.query.filter_by(active=True).order_by(Role.display_name).all()  # Custom roles system enabled\n    sectors = Sector.query.filter_by(active=True).order_by(Sector.display_name).all()\n    return render_template(\"admin/users.html\", app_name=APP_NAME, user=current_user(), users=users, roles=roles, sectors=sectors)\n\n@app.route(\"/admin/users/new\", methods=[\"GET\", \"POST\"])\n@login_required\n@roles_required(\"admin\")\ndef admin_users_new():\n    \"\"\"Create new user with advanced settings\"\"\"\n    if request.method == \"POST\":\n        username = request.form.get(\"username\", \"\").strip()\n        password = request.form.get(\"password\", \"\")\n        role = request.form.get(\"role\", \"\")\n        # role_id = request.form.get(\"role_id\", type=int)  # Removed for PostgreSQL compatibility\n        sector_ids = request.form.getlist(\"sector_ids\")\n        \n        if not username or not password:\n            flash(\"Usu√°rio e senha s√£o obrigat√≥rios.\", \"danger\")\n            return redirect(url_for(\"admin_users_new\"))\n        \n        if User.query.filter_by(username=username).first():\n            flash(\"Usu√°rio j√° existe.\", \"danger\")\n            return redirect(url_for(\"admin_users_new\"))\n        \n        user = User(username=username, role=role)\n        user.set_password(password)\n        \n        # Set new role system if available\n        # Legacy role_id system removed for PostgreSQL compatibility\n        if hasattr(user, 'active'):\n            user.active = True\n        if hasattr(user, 'created_at'):\n            user.created_at = now_brazil()\n        \n        db.session.add(user)\n        db.session.commit()\n        \n        # Assign sectors using the new method\n        if sector_ids:\n            sector_ids = [int(id) for id in sector_ids if id.isdigit()]\n            user.assign_sectors(sector_ids)\n            db.session.commit()\n        \n        # Validate operator sector assignment\n        if role == 'operador' and not user.get_sectors():\n            flash(\"Operadores devem ter pelo menos um setor atribu√≠do.\", \"warning\")\n            # roles = Role.query.filter_by(active=True).order_by(Role.display_name).all()  # Removed for PostgreSQL compatibility\n            roles = []  # Using simple string role system\n            sectors = Sector.query.filter_by(active=True).order_by(Sector.display_name).all()\n            return render_template(\"admin/user_form.html\", app_name=APP_NAME, user=current_user(), u=user, roles=roles, sectors=sectors)\n        \n        flash(\"Usu√°rio criado com sucesso.\", \"success\")\n        return redirect(url_for(\"admin_users\"))\n    \n    roles = Role.query.filter_by(active=True).order_by(Role.display_name).all()  # Custom roles system enabled\n    sectors = Sector.query.filter_by(active=True).order_by(Sector.display_name).all()\n    return render_template(\"admin/user_form.html\", app_name=APP_NAME, user=current_user(), u=None, roles=roles, sectors=sectors)\n\n@app.route(\"/admin/users/edit/<int:uid>\", methods=[\"GET\", \"POST\"])\n@login_required\n@roles_required(\"admin\")\ndef admin_users_editar(uid):\n    \"\"\"Edit user with advanced settings\"\"\"\n    u = db.session.get(User, uid) or abort(404)\n    \n    if request.method == \"POST\":\n        u.username = request.form.get(\"username\", \"\").strip()\n        password = request.form.get(\"password\", \"\")\n        role = request.form.get(\"role\", \"\")\n        # role_id = request.form.get(\"role_id\", type=int)  # Removed for PostgreSQL compatibility\n        sector_ids = request.form.getlist(\"sector_ids\")\n        \n        if not u.username:\n            flash(\"Usu√°rio √© obrigat√≥rio.\", \"danger\")\n            return redirect(url_for(\"admin_users_editar\", uid=uid))\n        \n        # Check for username conflicts (excluding current user)\n        existing = User.query.filter(User.username == u.username, User.id != uid).first()\n        if existing:\n            flash(\"J√° existe outro usu√°rio com este nome.\", \"danger\")\n            return redirect(url_for(\"admin_users_editar\", uid=uid))\n        \n        u.role = role\n        \n        # Set new role system if available\n        if hasattr(u, 'role_id') and role_id:\n            u.role_id = role_id\n        \n        # Assign sectors using the new method\n        if sector_ids:\n            sector_ids = [int(id) for id in sector_ids if id.isdigit()]\n            u.assign_sectors(sector_ids)\n        else:\n            u.assign_sectors([])  # Clear all sectors\n        \n        # Validate operator sector assignment\n        if role == 'operador' and not u.get_sectors():\n            flash(\"Operadores devem ter pelo menos um setor atribu√≠do.\", \"warning\")\n            # roles = Role.query.filter_by(active=True).order_by(Role.display_name).all()  # Removed for PostgreSQL compatibility\n            roles = []  # Using simple string role system\n            sectors = Sector.query.filter_by(active=True).order_by(Sector.display_name).all()\n            return render_template(\"admin/user_form.html\", app_name=APP_NAME, user=current_user(), u=u, roles=roles, sectors=sectors)\n        \n        if password:\n            u.set_password(password)\n        \n        # Force session refresh for currently logged in user\n        if u.id == session.get('user_id'):\n            session['user_sectors'] = u.get_sector_names()\n            session['user_role'] = u.role\n        \n        db.session.commit()\n        flash(\"Usu√°rio atualizado com sucesso.\", \"success\")\n        return redirect(url_for(\"admin_users\"))\n    \n    roles = Role.query.filter_by(active=True).order_by(Role.display_name).all()  # Custom roles system enabled\n    sectors = Sector.query.filter_by(active=True).order_by(Sector.display_name).all()\n    return render_template(\"admin/user_form.html\", app_name=APP_NAME, user=current_user(), u=u, roles=roles, sectors=sectors)\n\n# -------------------- ADMIN ROLES & PERMISSIONS --------------------\n\n@app.route(\"/admin/roles\")\n@login_required\n@roles_required(\"admin\")\ndef admin_roles():\n    \"\"\"Manage roles and permissions\"\"\"\n    \n    roles = Role.query.filter_by(active=True).order_by(Role.display_name).all()\n    \n    # Calculate user count for each role\n    roles_with_counts = []\n    for role in roles:\n        user_count = User.query.filter_by(role=role.name).count()\n        roles_with_counts.append({\n            'role': role,\n            'user_count': user_count\n        })\n    \n    return render_template(\"admin/roles.html\", app_name=APP_NAME, user=current_user(), roles_with_counts=roles_with_counts)\n\n@app.route(\"/admin/roles/new\", methods=[\"GET\", \"POST\"])\n@login_required\n@roles_required(\"admin\")\ndef admin_roles_new():\n    \"\"\"Create new role\"\"\"\n    \n    if request.method == \"POST\":\n        name = request.form.get(\"name\", \"\").strip()\n        display_name = request.form.get(\"display_name\", \"\").strip()\n        description = request.form.get(\"description\", \"\").strip()\n        permissions = request.form.getlist(\"permissions\")\n        \n        if not name or not display_name:\n            flash(\"Nome e nome de exibi√ß√£o s√£o obrigat√≥rios.\", \"danger\")\n            return render_template(\"admin/role_form.html\", app_name=APP_NAME, user=current_user())\n        \n        # Check if there's an existing role with the same name (active or inactive)\n        existing_role = Role.query.filter_by(name=name).first()\n        \n        if existing_role:\n            if existing_role.active:\n                flash(\"J√° existe um papel ativo com este nome.\", \"danger\")\n                return render_template(\"admin/role_form.html\", app_name=APP_NAME, user=current_user())\n            else:\n                # Reactivate the inactive role\n                import json\n                existing_role.active = True\n                existing_role.display_name = display_name\n                existing_role.description = description\n                existing_role.permissions = json.dumps(permissions)\n                db.session.commit()\n                flash(\"Papel reativado com sucesso.\", \"success\")\n                return redirect(url_for(\"admin_roles\"))\n        else:\n            # Create new role\n            import json\n            role = Role(\n                name=name, \n                display_name=display_name, \n                description=description, \n                permissions=json.dumps(permissions)\n            )\n            db.session.add(role)\n        db.session.commit()\n        \n        # Log activity\n        if activity_logger:\n            user = current_user()\n            log_admin_action(\n                user.id if user else 0,\n                user.username if user else \"Sistema\",\n                f\"Papel '{display_name}' criado\"\n            )\n        \n        flash(\"Papel criado com sucesso.\", \"success\")\n        return redirect(url_for(\"admin_roles\"))\n    \n    available_permissions = [\n        {\"id\": \"view_all\", \"name\": \"Ver todos os chamados\"},\n        {\"id\": \"view_sector\", \"name\": \"Ver chamados do setor\"},\n        {\"id\": \"view_own\", \"name\": \"Ver pr√≥prios chamados\"},\n        {\"id\": \"edit_all\", \"name\": \"Editar todos os chamados\"},\n        {\"id\": \"edit_sector\", \"name\": \"Editar chamados do setor\"},\n        {\"id\": \"delete_all\", \"name\": \"Excluir qualquer chamado\"},\n        {\"id\": \"close_tickets\", \"name\": \"Fechar chamados\"},\n        {\"id\": \"create_tickets\", \"name\": \"Criar chamados\"},\n        {\"id\": \"manage_users\", \"name\": \"Gerenciar usu√°rios\"},\n        {\"id\": \"manage_sectors\", \"name\": \"Gerenciar setores\"},\n        {\"id\": \"manage_roles\", \"name\": \"Gerenciar pap√©is\"},\n        {\"id\": \"view_reports\", \"name\": \"Visualizar relat√≥rios\"},\n        {\"id\": \"manage_settings\", \"name\": \"Gerenciar configura√ß√µes\"}\n    ]\n    \n    return render_template(\"admin/role_form.html\", app_name=APP_NAME, user=current_user(), role=None, available_permissions=available_permissions)\n\n@app.route(\"/admin/roles/edit/<int:role_id>\", methods=[\"GET\", \"POST\"])\n@login_required\n@roles_required(\"admin\")\ndef admin_roles_edit(role_id):\n    \"\"\"Edit role\"\"\"\n    \n    role = Role.query.get_or_404(role_id)\n    \n    if request.method == \"POST\":\n        name = request.form.get(\"name\", \"\").strip()\n        display_name = request.form.get(\"display_name\", \"\").strip()\n        description = request.form.get(\"description\", \"\").strip()\n        permissions = request.form.getlist(\"permissions\")\n        \n        if not name or not display_name:\n            flash(\"Nome e nome de exibi√ß√£o s√£o obrigat√≥rios.\", \"danger\")\n            return redirect(url_for(\"admin_roles_edit\", role_id=role_id))\n        \n        # Check for duplicate names (excluding current role)\n        existing = Role.query.filter(Role.name == name, Role.id != role_id).first()\n        if existing:\n            flash(\"J√° existe outro papel com este nome.\", \"danger\")\n            return redirect(url_for(\"admin_roles_edit\", role_id=role_id))\n        \n        import json\n        role.name = name\n        role.display_name = display_name\n        role.description = description\n        role.permissions = json.dumps(permissions)\n        role.updated_at = datetime.now()\n        \n        db.session.commit()\n        \n        # Log activity\n        if activity_logger:\n            user = current_user()\n            log_admin_action(\n                user.id if user else 0,\n                user.username if user else \"Sistema\",\n                f\"Papel '{display_name}' editado\"\n            )\n        \n        flash(\"Papel atualizado com sucesso.\", \"success\")\n        return redirect(url_for(\"admin_roles\"))\n    \n    available_permissions = [\n        {\"id\": \"view_all\", \"name\": \"Ver todos os chamados\"},\n        {\"id\": \"view_sector\", \"name\": \"Ver chamados do setor\"},\n        {\"id\": \"view_own\", \"name\": \"Ver pr√≥prios chamados\"},\n        {\"id\": \"edit_all\", \"name\": \"Editar todos os chamados\"},\n        {\"id\": \"edit_sector\", \"name\": \"Editar chamados do setor\"},\n        {\"id\": \"delete_all\", \"name\": \"Excluir qualquer chamado\"},\n        {\"id\": \"close_tickets\", \"name\": \"Fechar chamados\"},\n        {\"id\": \"create_tickets\", \"name\": \"Criar chamados\"},\n        {\"id\": \"manage_users\", \"name\": \"Gerenciar usu√°rios\"},\n        {\"id\": \"manage_sectors\", \"name\": \"Gerenciar setores\"},\n        {\"id\": \"manage_roles\", \"name\": \"Gerenciar pap√©is\"},\n        {\"id\": \"view_reports\", \"name\": \"Visualizar relat√≥rios\"},\n        {\"id\": \"manage_settings\", \"name\": \"Gerenciar configura√ß√µes\"}\n    ]\n    \n    return render_template(\"admin/role_form.html\", app_name=APP_NAME, user=current_user(), role=role, available_permissions=available_permissions)\n    \n    available_permissions = [\n        {\"id\": \"view_all\", \"name\": \"Ver todos os chamados\"},\n        {\"id\": \"view_sector\", \"name\": \"Ver chamados do setor\"},\n        {\"id\": \"view_own\", \"name\": \"Ver pr√≥prios chamados\"},\n        {\"id\": \"edit_all\", \"name\": \"Editar todos os chamados\"},\n        {\"id\": \"edit_sector\", \"name\": \"Editar chamados do setor\"},\n        {\"id\": \"delete_all\", \"name\": \"Excluir qualquer chamado\"},\n        {\"id\": \"close_tickets\", \"name\": \"Fechar chamados\"},\n        {\"id\": \"create_tickets\", \"name\": \"Criar chamados\"},\n        {\"id\": \"manage_users\", \"name\": \"Gerenciar usu√°rios\"},\n        {\"id\": \"manage_sectors\", \"name\": \"Gerenciar setores\"},\n        {\"id\": \"manage_roles\", \"name\": \"Gerenciar pap√©is\"},\n        {\"id\": \"view_reports\", \"name\": \"Visualizar relat√≥rios\"},\n        {\"id\": \"manage_settings\", \"name\": \"Gerenciar configura√ß√µes\"}\n    ]\n    \n    return render_template(\"admin/role_form.html\", app_name=APP_NAME, user=current_user(), role=role, available_permissions=available_permissions)\n\n@app.route(\"/admin/roles/delete/<int:role_id>\", methods=[\"POST\"])\n@login_required\n@roles_required(\"admin\")\ndef admin_roles_delete(role_id):\n    \"\"\"Delete role\"\"\"\n    \n    role = Role.query.get_or_404(role_id)\n    \n    # Check if role is being used by any users (using string comparison)\n    users_count = User.query.filter_by(role=role.name).count()\n    \n    if users_count > 0:\n        flash(f\"N√£o √© poss√≠vel excluir o papel '{role.display_name}'. Ele est√° sendo usado por {users_count} usu√°rio(s).\", \"danger\")\n        return redirect(url_for(\"admin_roles\"))\n    \n    # Soft delete - just mark as inactive\n    role.active = False\n    db.session.commit()\n    \n    # Log activity\n    if activity_logger:\n        user = current_user()\n        log_admin_action(\n            user.id if user else 0,\n            user.username if user else \"Sistema\",\n            f\"Papel '{role.display_name}' removido\"\n        )\n    \n    flash(\"Papel removido com sucesso.\", \"success\")\n    return redirect(url_for(\"admin_roles\"))\n\n# -------------------- ADMIN SETTINGS --------------------\n\n@app.route(\"/admin/settings\")\n@login_required\n@roles_required(\"admin\")\ndef admin_settings():\n    \"\"\"System settings management\"\"\"\n    settings = SystemSettings.query.order_by(SystemSettings.setting_key).all()\n    settings_dict = {s.setting_key: s.setting_value for s in settings}\n    return render_template(\"admin/settings.html\", app_name=APP_NAME, user=current_user(), settings=settings_dict)\n\n@app.route(\"/admin/settings/update\", methods=[\"POST\"])\n@login_required\n@roles_required(\"admin\")\ndef admin_settings_update():\n    \"\"\"Update system settings\"\"\"\n    for key, value in request.form.items():\n        if key.startswith('setting_'):\n            setting_key = key.replace('setting_', '')\n            setting = SystemSettings.query.filter_by(setting_key=setting_key).first()\n            if setting:\n                setting.setting_value = value\n                setting.updated_at = now_brazil()\n            else:\n                # Create new setting\n                setting = SystemSettings(setting_key=setting_key, setting_value=value, updated_at=now_brazil())\n                db.session.add(setting)\n    \n    db.session.commit()\n    flash(\"Configura√ß√µes atualizadas com sucesso.\", \"success\")\n    return redirect(url_for(\"admin_settings\"))\n\n# -------------------- ENHANCED UTILITIES --------------------\n\ndef get_system_setting(key, default=None):\n    \"\"\"Get system setting value\"\"\"\n    setting = SystemSettings.query.filter_by(setting_key=key).first()\n    return setting.setting_value if setting else default\n\n# Update APP_NAME to be dynamic\ndef get_app_name():\n    return get_system_setting(\"system_name\", \"Sistemas Olivium\")\n\n# ======================= NOVAS FUNCIONALIDADES =======================\n\n# Integrar sistema de logging avan√ßado\ntry:\n    from enhanced_logging import (\n        log_user_action, log_system_event, log_api_request, log_performance_metric,\n        performance_monitor, get_log_stats, search_logs\n    )\n    print(\"‚úÖ Sistema de logging avan√ßado carregado\")\nexcept ImportError as e:\n    print(f\"‚ö†Ô∏è Sistema de logging avan√ßado n√£o dispon√≠vel: {e}\")\n    # Fallbacks\n    def log_user_action(*args, **kwargs): pass\n    def log_system_event(*args, **kwargs): pass\n    def log_api_request(*args, **kwargs): pass\n    def log_performance_metric(*args, **kwargs): pass\n    def performance_monitor(name): return lambda f: f\n    def get_log_stats(): return {}\n    def search_logs(*args, **kwargs): return []\n\n# Integrar dashboard de m√©tricas\ntry:\n    from metrics_dashboard import metrics_dashboard\n    print(\"‚úÖ Dashboard de m√©tricas carregado\")\nexcept ImportError as e:\n    print(f\"‚ö†Ô∏è Dashboard de m√©tricas n√£o dispon√≠vel: {e}\")\n    metrics_dashboard = None\n\n# Integrar API REST endpoints\ntry:\n    from api_endpoints import create_api_routes\n    create_api_routes(app, db)\n    print(\"‚úÖ Endpoints REST configurados\")\nexcept ImportError as e:\n    print(f\"‚ö†Ô∏è Endpoints REST n√£o dispon√≠veis: {e}\")\n\n# ======================= NOVOS ENDPOINTS WEB =======================\n\n@app.route(\"/admin/metrics\")\n@login_required\ndef admin_metrics():\n    \"\"\"Dashboard de m√©tricas avan√ßadas\"\"\"\n    current_user = get_current_user()\n    if not current_user or not current_user.is_admin:\n        flash(\"Acesso negado.\", \"error\")\n        return redirect(url_for('dashboard'))\n    \n    try:\n        system_health = metrics_dashboard.get_system_health() if metrics_dashboard else {'error': 'Dashboard indispon√≠vel'}\n        performance = metrics_dashboard.get_performance_metrics(7) if metrics_dashboard else {}\n        user_metrics = metrics_dashboard.get_user_metrics() if metrics_dashboard else {}\n        alerts = metrics_dashboard.generate_alerts() if metrics_dashboard else []\n        log_stats = get_log_stats()\n        \n        return render_template('admin/metrics.html',\n                             system_health=system_health,\n                             performance=performance,\n                             user_metrics=user_metrics,\n                             alerts=alerts,\n                             log_stats=log_stats)\n    except Exception as e:\n        flash(f\"Erro ao carregar m√©tricas: {str(e)}\", \"error\")\n        return redirect(url_for('admin_logs'))\n\n@app.route(\"/admin/metrics/api/<metric_type>\")\n@login_required\ndef admin_metrics_api(metric_type):\n    \"\"\"API para dados de m√©tricas em JSON\"\"\"\n    current_user = get_current_user()\n    if not current_user or not current_user.is_admin:\n        return jsonify({'error': 'Acesso negado'}), 403\n    \n    if not metrics_dashboard:\n        return jsonify({'error': 'Dashboard n√£o dispon√≠vel'}), 500\n    \n    try:\n        if metric_type == 'health':\n            data = metrics_dashboard.get_system_health()\n        elif metric_type == 'performance':\n            days = int(request.args.get('days', 7))\n            data = metrics_dashboard.get_performance_metrics(days)\n        elif metric_type == 'users':\n            user_id = request.args.get('user_id')\n            data = metrics_dashboard.get_user_metrics(int(user_id) if user_id else None)\n        elif metric_type == 'trends':\n            metric = request.args.get('metric', 'chamados')\n            days = int(request.args.get('days', 30))\n            data = metrics_dashboard.get_trend_analysis(metric, days)\n        elif metric_type == 'alerts':\n            data = metrics_dashboard.generate_alerts()\n        else:\n            return jsonify({'error': 'Tipo de m√©trica inv√°lido'}), 400\n        \n        return jsonify(data)\n        \n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n\n@app.route(\"/admin/logs/search\")\n@login_required\ndef admin_logs_search():\n    \"\"\"Busca avan√ßada nos logs\"\"\"\n    current_user = get_current_user()\n    if not current_user or not current_user.is_admin:\n        flash(\"Acesso negado.\", \"error\")\n        return redirect(url_for('dashboard'))\n    \n    query = request.args.get('q', '')\n    log_type = request.args.get('type', 'all')\n    limit = int(request.args.get('limit', 100))\n    \n    if query:\n        results = search_logs(query, log_type, limit)\n        log_user_action('SEARCH_LOGS', {'query': query, 'type': log_type, 'results': len(results)})\n    else:\n        results = []\n    \n    log_stats = get_log_stats()\n    \n    return render_template('admin/logs_search.html', \n                          results=results, \n                          query=query, \n                          log_type=log_type,\n                          log_stats=log_stats)\n\n# Monitorar performance de rotas cr√≠ticas\n@app.before_request\ndef before_request():\n    g.start_time = datetime.now()\n\n@app.after_request  \ndef after_request(response):\n    if hasattr(g, 'start_time'):\n        duration = (datetime.now() - g.start_time).total_seconds()\n        \n        # Log performance para rotas importantes\n        if request.endpoint in ['dashboard', 'chamados_novo', 'chamados_view', 'admin_monitoring']:\n            log_performance_metric(f\"route_{request.endpoint}\", duration * 1000, 'ms')\n        \n        # Log API requests\n        if request.path.startswith('/api/'):\n            log_api_request(request.path, request.method, response.status_code, duration)\n    \n    return response\n\n# -------------------- RUN --------------------\nif __name__ == \"__main__\":\n    print(\"üöÄ Iniciando Sistema Olivion v2.0...\")\n    print(\"üìä Sistema de Gest√£o de Chamados\")  \n    print(\"üåê Servidor ser√° iniciado em: http://localhost:5000\")\n    print(\"=\" * 50)\n    \n    # Garantir que SQLite est√° inicializado\n    with app.app_context():\n        try:\n            bootstrap()  # Criar tabelas e usu√°rio admin\n            print(\"‚úÖ SQLite inicializado com sucesso!\")\n        except Exception as e:\n            print(f\"‚ö†Ô∏è Erro na inicializa√ß√£o: {e}\")\n    \n    try:\n        port = int(os.getenv(\"PORT\", 5000))\n        \n        # Verificar se deve usar HTTPS para desenvolvimento local\n        # Detectar se est√° rodando no Replit ou localmente\n        is_replit = any([\n            os.getenv(\"REPL_ID\"),\n            os.getenv(\"REPL_SLUG\"), \n            os.getenv(\"REPLIT_DEPLOYMENT\"),\n            os.getenv(\"REPLIT_DB_URL\"),\n            \"replit\" in os.getcwd().lower()\n        ])\n        \n        # Usar SSL apenas se for desenvolvimento local (n√£o Replit) e vari√°vel espec√≠fica\n        use_ssl = (not is_replit and os.getenv(\"ENABLE_LOCAL_SSL\") == \"1\")\n        \n        if use_ssl:\n            try:\n                print(\"üîí HTTPS ativado para desenvolvimento local\")\n                print(\"‚ö†Ô∏è  Aceite o certificado autoassinado no navegador\")\n                print(\"üåê Acesse: https://localhost:5000\")\n                # Para HTTPS local, for√ßar threading mode para compatibilidade com SSL\n                socketio.init_app(app, async_mode='threading')\n                app.run(host=\"0.0.0.0\", port=port, debug=False, ssl_context='adhoc', threaded=True)\n            except Exception as e:\n                print(f\"‚ö†Ô∏è  N√£o foi poss√≠vel ativar HTTPS: {e}\")\n                print(\"üåê Usando HTTP com SocketIO: http://localhost:5000\")\n                socketio.run(app, host=\"0.0.0.0\", port=port, debug=False, use_reloader=False, log_output=True)\n        else:\n            # Para produ√ß√£o, Replit ou local sem SSL, usar SocketIO normal\n            print(\"üåê Usando HTTP com SocketIO\")\n            socketio.run(app, host=\"0.0.0.0\", port=port, debug=False, use_reloader=False, log_output=True)\n    except OSError as e:\n        if \"Address already in use\" in str(e):\n            print(\"‚ùå ERRO: Porta 5000 j√° est√° em uso!\")\n            print(\"üí° Solu√ß√£o: Feche outros programas que usam a porta 5000\")\n            print(\"   Ou mude a porta no arquivo app.py (linha final)\")\n        else:\n            print(f\"‚ùå ERRO: {e}\")\n        input(\"Pressione Enter para fechar...\")\n\n","size_bytes":128988},"backup_manager.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nSistema de Backup Autom√°tico - Sistema Olivion\nProte√ß√£o contra perda de dados com backups programados\n\"\"\"\n\nimport os\nimport sqlite3\nimport shutil\nimport datetime\nimport logging\nimport threading\nimport time\nfrom pathlib import Path\n\nclass BackupManager:\n    \"\"\"Gerenciador de backups autom√°ticos do banco de dados\"\"\"\n    \n    def __init__(self, db_path, backup_dir=\"backups\"):\n        self.db_path = db_path\n        self.backup_dir = Path(backup_dir)\n        self.backup_dir.mkdir(exist_ok=True)\n        \n        # Configurar logging\n        logging.basicConfig(\n            level=logging.INFO,\n            format='%(asctime)s - BACKUP - %(levelname)s - %(message)s',\n            handlers=[\n                logging.FileHandler('backup.log'),\n                logging.StreamHandler()\n            ]\n        )\n        self.logger = logging.getLogger(__name__)\n        \n    def create_backup(self, backup_type=\"manual\"):\n        \"\"\"Cria backup do banco de dados\"\"\"\n        try:\n            timestamp = datetime.datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n            backup_name = f\"sistema_os_backup_{backup_type}_{timestamp}.db\"\n            backup_path = self.backup_dir / backup_name\n            \n            # Backup seguro usando SQLite VACUUM INTO\n            conn = sqlite3.connect(self.db_path)\n            conn.execute(f\"VACUUM INTO '{backup_path}'\")\n            conn.close()\n            \n            # Verificar integridade do backup\n            if self._verify_backup(backup_path):\n                self.logger.info(f\"‚úÖ Backup criado com sucesso: {backup_name}\")\n                return backup_path\n            else:\n                self.logger.error(f\"‚ùå Backup corrompido removido: {backup_name}\")\n                backup_path.unlink()\n                return None\n                \n        except Exception as e:\n            self.logger.error(f\"‚ùå Erro ao criar backup: {e}\")\n            return None\n    \n    def _verify_backup(self, backup_path):\n        \"\"\"Verifica integridade do backup\"\"\"\n        try:\n            conn = sqlite3.connect(backup_path)\n            # Testar algumas consultas b√°sicas\n            cursor = conn.cursor()\n            cursor.execute(\"SELECT COUNT(*) FROM user\")\n            user_count = cursor.fetchone()[0]\n            cursor.execute(\"SELECT COUNT(*) FROM chamado\") \n            chamado_count = cursor.fetchone()[0]\n            conn.close()\n            \n            return user_count >= 0 and chamado_count >= 0\n        except:\n            return False\n    \n    def cleanup_old_backups(self, keep_days=30):\n        \"\"\"Remove backups antigos para economizar espa√ßo\"\"\"\n        try:\n            cutoff_date = datetime.datetime.now() - datetime.timedelta(days=keep_days)\n            \n            for backup_file in self.backup_dir.glob(\"sistema_os_backup_*.db\"):\n                if backup_file.stat().st_mtime < cutoff_date.timestamp():\n                    backup_file.unlink()\n                    self.logger.info(f\"üóëÔ∏è Backup antigo removido: {backup_file.name}\")\n                    \n        except Exception as e:\n            self.logger.error(f\"‚ùå Erro na limpeza de backups: {e}\")\n    \n    def restore_backup(self, backup_path):\n        \"\"\"Restaura banco de dados de um backup\"\"\"\n        try:\n            if not Path(backup_path).exists():\n                self.logger.error(f\"‚ùå Arquivo de backup n√£o encontrado: {backup_path}\")\n                return False\n            \n            # Verificar integridade antes de restaurar\n            if not self._verify_backup(backup_path):\n                self.logger.error(f\"‚ùå Backup corrompido: {backup_path}\")\n                return False\n            \n            # Criar backup do estado atual\n            current_backup = self.create_backup(\"pre_restore\")\n            \n            # Restaurar\n            shutil.copy2(backup_path, self.db_path)\n            self.logger.info(f\"‚úÖ Banco restaurado de: {backup_path}\")\n            return True\n            \n        except Exception as e:\n            self.logger.error(f\"‚ùå Erro ao restaurar backup: {e}\")\n            return False\n    \n    def list_backups(self):\n        \"\"\"Lista todos os backups dispon√≠veis\"\"\"\n        backups = []\n        for backup_file in sorted(self.backup_dir.glob(\"sistema_os_backup_*.db\")):\n            stat = backup_file.stat()\n            backups.append({\n                'name': backup_file.name,\n                'path': str(backup_file),\n                'size': f\"{stat.st_size / 1024:.1f} KB\",\n                'created': datetime.datetime.fromtimestamp(stat.st_mtime).strftime(\"%Y-%m-%d %H:%M:%S\")\n            })\n        return backups\n    \n    def start_automatic_backups(self, interval_hours=6):\n        \"\"\"Inicia backups autom√°ticos em thread separada\"\"\"\n        def backup_worker():\n            while True:\n                self.create_backup(\"auto\")\n                self.cleanup_old_backups()\n                time.sleep(interval_hours * 3600)  # Converter horas para segundos\n        \n        thread = threading.Thread(target=backup_worker, daemon=True)\n        thread.start()\n        self.logger.info(f\"üïê Backups autom√°ticos iniciados (a cada {interval_hours}h)\")\n\nif __name__ == \"__main__\":\n    # Teste do sistema de backup\n    backup_manager = BackupManager(\"sistema_os.db\")\n    \n    print(\"üîÑ Criando backup manual...\")\n    backup_path = backup_manager.create_backup()\n    \n    print(\"\\nüìã Backups dispon√≠veis:\")\n    for backup in backup_manager.list_backups():\n        print(f\"  - {backup['name']} ({backup['size']}) - {backup['created']}\")","size_bytes":5561},"cloud_backup_manager.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nSistema de Backup na Nuvem - Sistema Olivion\nBackup autom√°tico para armazenamento remoto com redund√¢ncia\n\"\"\"\n\nimport os\nimport shutil\nimport gzip\nimport json\nimport sqlite3\nimport logging\nimport threading\nimport time\nfrom datetime import datetime, timedelta\nfrom pathlib import Path\nimport hashlib\n\nclass CloudBackupManager:\n    \"\"\"Gerenciador de backup na nuvem com redund√¢ncia\"\"\"\n    \n    def __init__(self, db_path=\"sistema_os.db\", cloud_backup_dir=\"cloud_backups\"):\n        self.db_path = db_path\n        self.cloud_backup_dir = Path(cloud_backup_dir)\n        self.cloud_backup_dir.mkdir(exist_ok=True)\n        \n        # Diret√≥rios para diferentes tipos de backup\n        self.daily_dir = self.cloud_backup_dir / \"daily\"\n        self.weekly_dir = self.cloud_backup_dir / \"weekly\"\n        self.monthly_dir = self.cloud_backup_dir / \"monthly\"\n        \n        for dir_path in [self.daily_dir, self.weekly_dir, self.monthly_dir]:\n            dir_path.mkdir(exist_ok=True)\n        \n        # Configurar logging\n        logging.basicConfig(\n            level=logging.INFO,\n            format='%(asctime)s - CLOUD_BACKUP - %(levelname)s - %(message)s'\n        )\n        self.logger = logging.getLogger(__name__)\n    \n    def calculate_file_hash(self, file_path):\n        \"\"\"Calcula hash MD5 do arquivo para verifica√ß√£o de integridade\"\"\"\n        hash_md5 = hashlib.md5()\n        try:\n            with open(file_path, \"rb\") as f:\n                for chunk in iter(lambda: f.read(4096), b\"\"):\n                    hash_md5.update(chunk)\n            return hash_md5.hexdigest()\n        except Exception as e:\n            self.logger.error(f\"‚ùå Erro ao calcular hash: {e}\")\n            return None\n    \n    def compress_file(self, source_path, dest_path):\n        \"\"\"Comprime arquivo usando gzip para economizar espa√ßo\"\"\"\n        try:\n            with open(source_path, 'rb') as f_in:\n                with gzip.open(dest_path, 'wb') as f_out:\n                    shutil.copyfileobj(f_in, f_out)\n            return True\n        except Exception as e:\n            self.logger.error(f\"‚ùå Erro na compress√£o: {e}\")\n            return False\n    \n    def create_backup_metadata(self, backup_path, backup_type):\n        \"\"\"Cria metadados do backup para controle de vers√£o\"\"\"\n        try:\n            # Calcular estat√≠sticas do banco\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            # Obter contadores de tabelas\n            cursor.execute(\"SELECT COUNT(*) FROM user\")\n            user_count = cursor.fetchone()[0]\n            \n            cursor.execute(\"SELECT COUNT(*) FROM chamado\")\n            chamado_count = cursor.fetchone()[0]\n            \n            # Obter tamanho do banco\n            cursor.execute(\"SELECT page_count * page_size as size FROM pragma_page_count(), pragma_page_size()\")\n            db_size = cursor.fetchone()[0]\n            \n            conn.close()\n            \n            # Hash do backup\n            backup_hash = self.calculate_file_hash(backup_path)\n            \n            # Metadados\n            metadata = {\n                'backup_type': backup_type,\n                'created_at': datetime.now().isoformat(),\n                'file_size': os.path.getsize(backup_path),\n                'compressed_size': os.path.getsize(backup_path),\n                'file_hash': backup_hash,\n                'database_stats': {\n                    'user_count': user_count,\n                    'chamado_count': chamado_count,\n                    'database_size': db_size\n                },\n                'source_database': self.db_path,\n                'backup_version': '1.0'\n            }\n            \n            # Salvar metadados\n            metadata_path = backup_path.with_suffix('.json')\n            with open(metadata_path, 'w') as f:\n                json.dump(metadata, f, indent=2)\n            \n            return metadata\n            \n        except Exception as e:\n            self.logger.error(f\"‚ùå Erro ao criar metadados: {e}\")\n            return None\n    \n    def create_daily_backup(self):\n        \"\"\"Cria backup di√°rio comprimido\"\"\"\n        try:\n            timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n            backup_name = f\"daily_backup_{timestamp}.db.gz\"\n            backup_path = self.daily_dir / backup_name\n            \n            # Comprimir e salvar\n            if self.compress_file(self.db_path, backup_path):\n                metadata = self.create_backup_metadata(backup_path, \"daily\")\n                if metadata:\n                    self.logger.info(f\"‚úÖ Backup di√°rio criado: {backup_name}\")\n                    return backup_path\n            \n            return None\n            \n        except Exception as e:\n            self.logger.error(f\"‚ùå Erro no backup di√°rio: {e}\")\n            return None\n    \n    def create_weekly_backup(self):\n        \"\"\"Cria backup semanal (aos domingos)\"\"\"\n        try:\n            if datetime.now().weekday() != 6:  # 6 = domingo\n                return None\n            \n            timestamp = datetime.now().strftime(\"%Y_W%U\")\n            backup_name = f\"weekly_backup_{timestamp}.db.gz\"\n            backup_path = self.weekly_dir / backup_name\n            \n            # Evitar duplicatas\n            if backup_path.exists():\n                return backup_path\n            \n            if self.compress_file(self.db_path, backup_path):\n                metadata = self.create_backup_metadata(backup_path, \"weekly\")\n                if metadata:\n                    self.logger.info(f\"‚úÖ Backup semanal criado: {backup_name}\")\n                    return backup_path\n            \n            return None\n            \n        except Exception as e:\n            self.logger.error(f\"‚ùå Erro no backup semanal: {e}\")\n            return None\n    \n    def create_monthly_backup(self):\n        \"\"\"Cria backup mensal (primeiro dia do m√™s)\"\"\"\n        try:\n            if datetime.now().day != 1:\n                return None\n            \n            timestamp = datetime.now().strftime(\"%Y_%m\")\n            backup_name = f\"monthly_backup_{timestamp}.db.gz\"\n            backup_path = self.monthly_dir / backup_name\n            \n            # Evitar duplicatas\n            if backup_path.exists():\n                return backup_path\n            \n            if self.compress_file(self.db_path, backup_path):\n                metadata = self.create_backup_metadata(backup_path, \"monthly\")\n                if metadata:\n                    self.logger.info(f\"‚úÖ Backup mensal criado: {backup_name}\")\n                    return backup_path\n            \n            return None\n            \n        except Exception as e:\n            self.logger.error(f\"‚ùå Erro no backup mensal: {e}\")\n            return None\n    \n    def cleanup_old_backups(self):\n        \"\"\"Remove backups antigos baseado na pol√≠tica de reten√ß√£o\"\"\"\n        try:\n            current_time = datetime.now()\n            \n            # Pol√≠tica de reten√ß√£o\n            policies = {\n                'daily': (self.daily_dir, 30),      # 30 dias\n                'weekly': (self.weekly_dir, 12),    # 12 semanas  \n                'monthly': (self.monthly_dir, 24)   # 24 meses\n            }\n            \n            for backup_type, (directory, retention_count) in policies.items():\n                # Listar backups ordenados por data (mais recente primeiro)\n                backups = sorted(\n                    directory.glob(f\"{backup_type}_backup_*.db.gz\"),\n                    key=lambda x: x.stat().st_mtime,\n                    reverse=True\n                )\n                \n                # Remover backups excedentes\n                if len(backups) > retention_count:\n                    for old_backup in backups[retention_count:]:\n                        old_backup.unlink()\n                        # Remover metadados tamb√©m\n                        metadata_file = old_backup.with_suffix('.json')\n                        if metadata_file.exists():\n                            metadata_file.unlink()\n                        \n                        self.logger.info(f\"üóëÔ∏è Backup antigo removido: {old_backup.name}\")\n            \n        except Exception as e:\n            self.logger.error(f\"‚ùå Erro na limpeza: {e}\")\n    \n    def verify_backup_integrity(self, backup_path):\n        \"\"\"Verifica integridade do backup\"\"\"\n        try:\n            if not backup_path.exists():\n                return False\n            \n            # Verificar metadados\n            metadata_path = backup_path.with_suffix('.json')\n            if not metadata_path.exists():\n                return False\n            \n            with open(metadata_path, 'r') as f:\n                metadata = json.load(f)\n            \n            # Verificar hash\n            current_hash = self.calculate_file_hash(backup_path)\n            stored_hash = metadata.get('file_hash')\n            \n            if current_hash != stored_hash:\n                self.logger.error(f\"‚ùå Hash inv√°lido para backup: {backup_path.name}\")\n                return False\n            \n            return True\n            \n        except Exception as e:\n            self.logger.error(f\"‚ùå Erro na verifica√ß√£o: {e}\")\n            return False\n    \n    def get_backup_statistics(self):\n        \"\"\"Retorna estat√≠sticas dos backups\"\"\"\n        try:\n            stats = {\n                'daily': {'count': 0, 'total_size': 0},\n                'weekly': {'count': 0, 'total_size': 0},\n                'monthly': {'count': 0, 'total_size': 0}\n            }\n            \n            for backup_type in ['daily', 'weekly', 'monthly']:\n                directory = getattr(self, f\"{backup_type}_dir\")\n                backups = list(directory.glob(f\"{backup_type}_backup_*.db.gz\"))\n                \n                stats[backup_type]['count'] = len(backups)\n                stats[backup_type]['total_size'] = sum(\n                    backup.stat().st_size for backup in backups\n                )\n            \n            return stats\n            \n        except Exception as e:\n            self.logger.error(f\"‚ùå Erro nas estat√≠sticas: {e}\")\n            return {}\n    \n    def run_scheduled_backup(self):\n        \"\"\"Executa backup programado com todas as pol√≠ticas\"\"\"\n        try:\n            self.logger.info(\"üîÑ Iniciando backup programado...\")\n            \n            # Criar backups baseado no dia\n            backups_created = []\n            \n            # Backup di√°rio (sempre)\n            daily_backup = self.create_daily_backup()\n            if daily_backup:\n                backups_created.append(('daily', daily_backup))\n            \n            # Backup semanal (domingos)\n            weekly_backup = self.create_weekly_backup()\n            if weekly_backup:\n                backups_created.append(('weekly', weekly_backup))\n            \n            # Backup mensal (primeiro dia do m√™s)\n            monthly_backup = self.create_monthly_backup()\n            if monthly_backup:\n                backups_created.append(('monthly', monthly_backup))\n            \n            # Limpeza de backups antigos\n            self.cleanup_old_backups()\n            \n            # Verificar integridade dos novos backups\n            for backup_type, backup_path in backups_created:\n                if not self.verify_backup_integrity(backup_path):\n                    self.logger.error(f\"‚ùå Falha na integridade: {backup_type}\")\n            \n            self.logger.info(f\"‚úÖ Backup programado conclu√≠do: {len(backups_created)} backups criados\")\n            return True\n            \n        except Exception as e:\n            self.logger.error(f\"‚ùå Erro no backup programado: {e}\")\n            return False\n    \n    def start_automatic_backups(self, interval_hours=6):\n        \"\"\"Inicia backups autom√°ticos em thread separada\"\"\"\n        def backup_worker():\n            while True:\n                self.run_scheduled_backup()\n                time.sleep(interval_hours * 3600)\n        \n        thread = threading.Thread(target=backup_worker, daemon=True)\n        thread.start()\n        self.logger.info(f\"üïê Backups autom√°ticos iniciados (a cada {interval_hours}h)\")\n\nif __name__ == \"__main__\":\n    # Teste do sistema de backup\n    cloud_backup = CloudBackupManager()\n    \n    print(\"üîÑ Executando backup de teste...\")\n    success = cloud_backup.run_scheduled_backup()\n    \n    if success:\n        stats = cloud_backup.get_backup_statistics()\n        print(\"üìä Estat√≠sticas de backup:\")\n        for backup_type, data in stats.items():\n            size_mb = data['total_size'] / 1024 / 1024\n            print(f\"  {backup_type}: {data['count']} backups, {size_mb:.2f} MB\")\n    else:\n        print(\"‚ùå Falha no backup\")","size_bytes":12738},"cloud_license_api.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nAPI de Licenciamento Remoto - Sistema Olivion\nPermite controle remoto de licen√ßas via internet\n\"\"\"\n\nimport json\nimport requests\nfrom datetime import datetime, timedelta\nfrom typing import Dict, Optional\nimport os\n\nclass CloudLicenseAPI:\n    def __init__(self, api_base_url: str = None):\n        # URL do seu servidor de licen√ßas (pode ser este mesmo sistema publicado)\n        self.api_base_url = api_base_url or os.environ.get('LICENSE_SERVER_URL', 'https://your-replit-app.replit.app')\n        self.timeout = 10\n        \n    def validate_license_online(self, license_key: str, machine_id: str) -> Dict:\n        \"\"\"Validar licen√ßa com servidor remoto\"\"\"\n        try:\n            url = f\"{self.api_base_url}/api/license/validate\"\n            payload = {\n                'license_key': license_key,\n                'machine_id': machine_id,\n                'timestamp': datetime.now().isoformat(),\n                'product': 'Sistema_Olivion'\n            }\n            \n            response = requests.post(url, json=payload, timeout=self.timeout)\n            \n            if response.status_code == 200:\n                return response.json()\n            elif response.status_code == 403:\n                return {\n                    'valid': False,\n                    'reason': 'license_blocked',\n                    'message': 'Licen√ßa bloqueada remotamente'\n                }\n            elif response.status_code == 404:\n                return {\n                    'valid': False,\n                    'reason': 'license_not_found',\n                    'message': 'Licen√ßa n√£o encontrada'\n                }\n            else:\n                return {\n                    'valid': False,\n                    'reason': 'server_error',\n                    'message': f'Erro do servidor: {response.status_code}'\n                }\n                \n        except requests.ConnectionError:\n            return {\n                'valid': False,\n                'reason': 'no_connection',\n                'message': 'Sem conex√£o com servidor de licen√ßas'\n            }\n        except requests.Timeout:\n            return {\n                'valid': False,\n                'reason': 'timeout',\n                'message': 'Timeout na valida√ß√£o remota'\n            }\n        except Exception as e:\n            return {\n                'valid': False,\n                'reason': 'error',\n                'message': f'Erro na valida√ß√£o: {str(e)}'\n            }\n    \n    def block_license_remote(self, license_key: str, reason: str = \"Administrative block\") -> Dict:\n        \"\"\"Bloquear licen√ßa remotamente\"\"\"\n        try:\n            url = f\"{self.api_base_url}/api/license/block\"\n            payload = {\n                'license_key': license_key,\n                'reason': reason,\n                'blocked_at': datetime.now().isoformat(),\n                'admin_action': True\n            }\n            \n            response = requests.post(url, json=payload, timeout=self.timeout)\n            \n            if response.status_code == 200:\n                return {\n                    'success': True,\n                    'message': 'Licen√ßa bloqueada com sucesso'\n                }\n            else:\n                return {\n                    'success': False,\n                    'message': f'Erro ao bloquear: {response.status_code}'\n                }\n                \n        except Exception as e:\n            return {\n                'success': False,\n                'message': f'Erro na comunica√ß√£o: {str(e)}'\n            }\n    \n    def unblock_license_remote(self, license_key: str) -> Dict:\n        \"\"\"Desbloquear licen√ßa remotamente\"\"\"\n        try:\n            url = f\"{self.api_base_url}/api/license/unblock\"\n            payload = {\n                'license_key': license_key,\n                'unblocked_at': datetime.now().isoformat(),\n                'admin_action': True\n            }\n            \n            response = requests.post(url, json=payload, timeout=self.timeout)\n            \n            if response.status_code == 200:\n                return {\n                    'success': True,\n                    'message': 'Licen√ßa desbloqueada com sucesso'\n                }\n            else:\n                return {\n                    'success': False,\n                    'message': f'Erro ao desbloquear: {response.status_code}'\n                }\n                \n        except Exception as e:\n            return {\n                'success': False,\n                'message': f'Erro na comunica√ß√£o: {str(e)}'\n            }\n    \n    def get_license_status_remote(self, license_key: str) -> Dict:\n        \"\"\"Obter status da licen√ßa no servidor remoto\"\"\"\n        try:\n            url = f\"{self.api_base_url}/api/license/status\"\n            params = {'license_key': license_key}\n            \n            response = requests.get(url, params=params, timeout=self.timeout)\n            \n            if response.status_code == 200:\n                return response.json()\n            else:\n                return {\n                    'found': False,\n                    'message': 'Licen√ßa n√£o encontrada no servidor'\n                }\n                \n        except Exception as e:\n            return {\n                'found': False,\n                'message': f'Erro na consulta: {str(e)}'\n            }\n\n# Inst√¢ncia global da API\ncloud_api = CloudLicenseAPI()\n\ndef check_internet_connection() -> bool:\n    \"\"\"Verificar se h√° conex√£o com internet\"\"\"\n    try:\n        response = requests.get('https://www.google.com', timeout=5)\n        return response.status_code == 200\n    except:\n        return False\n\ndef force_online_validation(license_key: str, machine_id: str) -> Dict:\n    \"\"\"For√ßar valida√ß√£o online - usado para controle remoto\"\"\"\n    if not check_internet_connection():\n        return {\n            'valid': False,\n            'reason': 'no_internet',\n            'message': 'Sem conex√£o com internet - valida√ß√£o obrigat√≥ria falhou'\n        }\n    \n    return cloud_api.validate_license_online(license_key, machine_id)","size_bytes":6097},"config.py":{"content":"import os\nfrom pathlib import Path\nimport secrets\n\nBASE_DIR = Path(__file__).resolve().parent\nINSTANCE_DIR = BASE_DIR / 'instance'\nINSTANCE_DIR.mkdir(exist_ok=True)\n\n# Generate secure SECRET_KEY if not provided via environment\nDEFAULT_SECRET_KEY = 'c932d1d52814ca0d71451877069fc3130400f33b51cdf34722fe197ea61fb0e5'\nSECRET_KEY = os.environ.get('SECRET_KEY', DEFAULT_SECRET_KEY)\n\n# Use consistent database path (sistema_os.db in root directory)\nDB_PATH = BASE_DIR / 'sistema_os.db'\nSQLALCHEMY_DATABASE_URI = f\"sqlite:///{DB_PATH.as_posix()}\"\nSQLALCHEMY_TRACK_MODIFICATIONS = False\n\n# Security configurations\nWTF_CSRF_ENABLED = True\nWTF_CSRF_TIME_LIMIT = 3600  # 1 hour\nSESSION_COOKIE_SECURE = os.environ.get('FLASK_ENV') == 'production'\nSESSION_COOKIE_HTTPONLY = True\nSESSION_COOKIE_SAMESITE = 'Lax'\n\n# Performance configurations\nSQLALCHEMY_ENGINE_OPTIONS = {\n    'pool_pre_ping': True,\n    'pool_recycle': 300,\n}\n\n# Cache configuration\nCACHE_TYPE = 'SimpleCache'\nCACHE_DEFAULT_TIMEOUT = 300\n","size_bytes":990},"database_safety.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nSistema de Seguran√ßa de Banco de Dados - Sistema Olivion\nTransa√ß√µes seguras, valida√ß√µes e monitoramento\n\"\"\"\n\nimport sqlite3\nimport functools\nimport logging\nfrom datetime import datetime\nfrom contextlib import contextmanager\n\nclass DatabaseSafety:\n    \"\"\"Gerenciador de seguran√ßa para opera√ß√µes de banco de dados\"\"\"\n    \n    def __init__(self, db_path):\n        self.db_path = db_path\n        self.logger = logging.getLogger(__name__)\n        \n        # Configurar SQLite para m√°xima seguran√ßa\n        self._configure_safety_settings()\n    \n    def _configure_safety_settings(self):\n        \"\"\"Configura SQLite para m√°xima seguran√ßa e integridade\"\"\"\n        try:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            # Configura√ß√µes cr√≠ticas de seguran√ßa\n            cursor.execute(\"PRAGMA foreign_keys = ON\")           # Integridade referencial\n            cursor.execute(\"PRAGMA journal_mode = WAL\")          # Write-Ahead Logging\n            cursor.execute(\"PRAGMA synchronous = FULL\")          # M√°xima durabilidade\n            cursor.execute(\"PRAGMA temp_store = MEMORY\")         # Temp em mem√≥ria\n            cursor.execute(\"PRAGMA cache_size = 10000\")          # Cache maior\n            cursor.execute(\"PRAGMA mmap_size = 268435456\")       # 256MB mmap\n            \n            conn.commit()\n            conn.close()\n            \n            self.logger.info(\"‚úÖ Configura√ß√µes de seguran√ßa aplicadas\")\n            \n        except Exception as e:\n            self.logger.error(f\"‚ùå Erro ao configurar seguran√ßa: {e}\")\n    \n    @contextmanager\n    def safe_transaction(self):\n        \"\"\"Context manager para transa√ß√µes seguras\"\"\"\n        conn = sqlite3.connect(self.db_path)\n        conn.execute(\"PRAGMA foreign_keys = ON\")\n        \n        try:\n            conn.execute(\"BEGIN IMMEDIATE\")  # Lock imediato\n            yield conn\n            conn.commit()\n            self.logger.debug(\"‚úÖ Transa√ß√£o commitada com sucesso\")\n            \n        except Exception as e:\n            conn.rollback()\n            self.logger.error(f\"‚ùå Transa√ß√£o revertida: {e}\")\n            raise\n        finally:\n            conn.close()\n    \n    def safe_operation(func):\n        \"\"\"Decorator para opera√ß√µes seguras com transa√ß√£o autom√°tica\"\"\"\n        @functools.wraps(func)\n        def wrapper(self, *args, **kwargs):\n            try:\n                with self.safe_transaction() as conn:\n                    return func(self, conn, *args, **kwargs)\n            except Exception as e:\n                self.logger.error(f\"‚ùå Opera√ß√£o {func.__name__} falhou: {e}\")\n                raise\n        return wrapper\n    \n    def check_database_integrity(self):\n        \"\"\"Verifica integridade completa do banco de dados\"\"\"\n        try:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            # Verificar integridade estrutural\n            cursor.execute(\"PRAGMA integrity_check\")\n            integrity_result = cursor.fetchone()[0]\n            \n            # Verificar foreign keys\n            cursor.execute(\"PRAGMA foreign_key_check\")\n            fk_violations = cursor.fetchall()\n            \n            # Verificar estat√≠sticas das tabelas\n            cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table'\")\n            tables = [row[0] for row in cursor.fetchall()]\n            \n            stats = {}\n            for table in tables:\n                cursor.execute(f\"SELECT COUNT(*) FROM {table}\")\n                stats[table] = cursor.fetchone()[0]\n            \n            conn.close()\n            \n            report = {\n                'integrity': integrity_result,\n                'foreign_key_violations': len(fk_violations),\n                'table_stats': stats,\n                'timestamp': datetime.now().isoformat()\n            }\n            \n            if integrity_result == \"ok\" and len(fk_violations) == 0:\n                self.logger.info(\"‚úÖ Banco de dados √≠ntegro\")\n                return True, report\n            else:\n                self.logger.warning(f\"‚ö†Ô∏è Problemas detectados: {fk_violations}\")\n                return False, report\n                \n        except Exception as e:\n            self.logger.error(f\"‚ùå Erro ao verificar integridade: {e}\")\n            return False, {'error': str(e)}\n    \n    def create_audit_log_table(self):\n        \"\"\"Cria tabela de auditoria para rastreamento de mudan√ßas\"\"\"\n        try:\n            with self.safe_transaction() as conn:\n                conn.execute(\"\"\"\n                    CREATE TABLE IF NOT EXISTS audit_log (\n                        id INTEGER PRIMARY KEY AUTOINCREMENT,\n                        table_name TEXT NOT NULL,\n                        operation TEXT NOT NULL,\n                        record_id TEXT,\n                        old_values TEXT,\n                        new_values TEXT,\n                        user_id INTEGER,\n                        timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,\n                        ip_address TEXT\n                    )\n                \"\"\")\n                \n                # √çndice para consultas r√°pidas\n                conn.execute(\"\"\"\n                    CREATE INDEX IF NOT EXISTS idx_audit_log_timestamp \n                    ON audit_log(timestamp DESC)\n                \"\"\")\n                \n                conn.execute(\"\"\"\n                    CREATE INDEX IF NOT EXISTS idx_audit_log_table_operation \n                    ON audit_log(table_name, operation)\n                \"\"\")\n                \n            self.logger.info(\"‚úÖ Tabela de auditoria criada\")\n            \n        except Exception as e:\n            self.logger.error(f\"‚ùå Erro ao criar tabela de auditoria: {e}\")\n    \n    def log_database_operation(self, table_name, operation, record_id=None, \n                             old_values=None, new_values=None, user_id=None, ip_address=None):\n        \"\"\"Registra opera√ß√£o no log de auditoria\"\"\"\n        try:\n            with self.safe_transaction() as conn:\n                conn.execute(\"\"\"\n                    INSERT INTO audit_log \n                    (table_name, operation, record_id, old_values, new_values, user_id, ip_address)\n                    VALUES (?, ?, ?, ?, ?, ?, ?)\n                \"\"\", (table_name, operation, record_id, old_values, new_values, user_id, ip_address))\n                \n        except Exception as e:\n            self.logger.error(f\"‚ùå Erro ao registrar auditoria: {e}\")\n    \n    def get_database_statistics(self):\n        \"\"\"Retorna estat√≠sticas detalhadas do banco de dados\"\"\"\n        try:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            # Tamanho do banco\n            cursor.execute(\"SELECT page_count * page_size as size FROM pragma_page_count(), pragma_page_size()\")\n            db_size = cursor.fetchone()[0]\n            \n            # N√∫mero de p√°ginas livres\n            cursor.execute(\"PRAGMA freelist_count\")\n            free_pages = cursor.fetchone()[0]\n            \n            # Estat√≠sticas por tabela\n            table_stats = {}\n            cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table'\")\n            \n            for (table_name,) in cursor.fetchall():\n                cursor.execute(f\"SELECT COUNT(*) FROM {table_name}\")\n                row_count = cursor.fetchone()[0]\n                \n                table_stats[table_name] = {\n                    'row_count': row_count\n                }\n            \n            conn.close()\n            \n            return {\n                'database_size_bytes': db_size,\n                'database_size_mb': round(db_size / 1024 / 1024, 2),\n                'free_pages': free_pages,\n                'table_statistics': table_stats,\n                'timestamp': datetime.now().isoformat()\n            }\n            \n        except Exception as e:\n            self.logger.error(f\"‚ùå Erro ao obter estat√≠sticas: {e}\")\n            return {'error': str(e)}\n\n# Inst√¢ncia global para uso na aplica√ß√£o\ndatabase_safety = DatabaseSafety(\"sistema_os.db\")","size_bytes":8154},"filters.py":{"content":"# Add a jinja2 filter for base64 encoding binary images\nimport base64\nfrom flask import Flask\n\ndef register_b64(app: Flask):\n    @app.template_filter('b64encode')\n    def b64encode_filter(data):\n        if not data:\n            return ''\n        return base64.b64encode(data).decode('ascii')\n","size_bytes":292},"initialize_production.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nInicializador de Produ√ß√£o - Sistema Olivion\nScript para configurar e inicializar todos os sistemas de produ√ß√£o\n\"\"\"\n\nimport os\nimport sqlite3\nimport logging\nfrom datetime import datetime\nfrom pathlib import Path\n\n# Importar todos os sistemas\ntry:\n    from production_manager import ProductionManager\n    from backup_manager import BackupManager\n    from database_safety import DatabaseSafety\n    from cloud_backup_manager import CloudBackupManager\n    from monitoring_system import MonitoringSystem\n    from maintenance_scheduler import MaintenanceScheduler\n    from replication_manager import ReplicationManager\nexcept ImportError as e:\n    print(f\"‚ö†Ô∏è Alguns sistemas n√£o dispon√≠veis: {e}\")\n\ndef configure_database_security(db_path=\"sistema_os.db\"):\n    \"\"\"Configura seguran√ßa m√°xima do banco de dados\"\"\"\n    try:\n        print(\"üîí Configurando seguran√ßa m√°xima do banco...\")\n        \n        conn = sqlite3.connect(db_path)\n        cursor = conn.cursor()\n        \n        # Configura√ß√µes cr√≠ticas de seguran√ßa\n        cursor.execute(\"PRAGMA foreign_keys = ON\")\n        cursor.execute(\"PRAGMA journal_mode = WAL\") \n        cursor.execute(\"PRAGMA synchronous = FULL\")\n        cursor.execute(\"PRAGMA temp_store = MEMORY\")\n        cursor.execute(\"PRAGMA cache_size = 10000\")\n        cursor.execute(\"PRAGMA mmap_size = 268435456\")  # 256MB\n        \n        # Verificar se configura√ß√µes foram aplicadas\n        cursor.execute(\"PRAGMA foreign_keys\")\n        fk_enabled = cursor.fetchone()[0]\n        \n        cursor.execute(\"PRAGMA journal_mode\")\n        journal_mode = cursor.fetchone()[0]\n        \n        cursor.execute(\"PRAGMA synchronous\")\n        sync_mode = cursor.fetchone()[0]\n        \n        conn.close()\n        \n        if fk_enabled == 1 and journal_mode == 'wal' and sync_mode >= 2:\n            print(\"‚úÖ Configura√ß√µes de seguran√ßa aplicadas com sucesso\")\n            return True\n        else:\n            print(f\"‚ö†Ô∏è Configura√ß√µes parciais: FK={fk_enabled}, WAL={journal_mode}, SYNC={sync_mode}\")\n            return False\n            \n    except Exception as e:\n        print(f\"‚ùå Erro na configura√ß√£o de seguran√ßa: {e}\")\n        return False\n\ndef run_comprehensive_test():\n    \"\"\"Executa teste abrangente de todos os sistemas\"\"\"\n    print(\"\\nüß™ EXECUTANDO TESTE ABRANGENTE DE PRODU√á√ÉO\")\n    print(\"=\" * 50)\n    \n    results = {\n        'database_security': False,\n        'backup_system': False,\n        'cloud_backup': False,\n        'monitoring': False,\n        'maintenance': False,\n        'replication': False,\n        'production_manager': False\n    }\n    \n    # 1. Configurar seguran√ßa do banco\n    print(\"\\n1Ô∏è‚É£ Testando seguran√ßa do banco de dados...\")\n    results['database_security'] = configure_database_security()\n    \n    # 2. Testar sistema de backup\n    print(\"\\n2Ô∏è‚É£ Testando sistema de backup...\")\n    try:\n        backup_manager = BackupManager(\"sistema_os.db\")\n        backup_path = backup_manager.create_backup(\"comprehensive_test\")\n        results['backup_system'] = backup_path is not None\n        if backup_path:\n            print(f\"‚úÖ Backup criado: {backup_path}\")\n        else:\n            print(\"‚ùå Falha no backup\")\n    except Exception as e:\n        print(f\"‚ùå Erro no sistema de backup: {e}\")\n    \n    # 3. Testar backup na nuvem\n    print(\"\\n3Ô∏è‚É£ Testando backup na nuvem...\")\n    try:\n        cloud_backup = CloudBackupManager(\"sistema_os.db\")\n        cloud_success = cloud_backup.run_scheduled_backup()\n        results['cloud_backup'] = cloud_success\n        if cloud_success:\n            stats = cloud_backup.get_backup_statistics()\n            print(f\"‚úÖ Backup na nuvem executado. Estat√≠sticas: {stats}\")\n        else:\n            print(\"‚ùå Falha no backup na nuvem\")\n    except Exception as e:\n        print(f\"‚ùå Erro no backup na nuvem: {e}\")\n    \n    # 4. Testar monitoramento\n    print(\"\\n4Ô∏è‚É£ Testando sistema de monitoramento...\")\n    try:\n        monitoring = MonitoringSystem(\"sistema_os.db\")\n        cycle_data = monitoring.perform_monitoring_cycle()\n        results['monitoring'] = cycle_data is not None\n        if cycle_data:\n            print(f\"‚úÖ Monitoramento funcionando. Status: {cycle_data['database']['status']}\")\n        else:\n            print(\"‚ùå Falha no monitoramento\")\n    except Exception as e:\n        print(f\"‚ùå Erro no monitoramento: {e}\")\n    \n    # 5. Testar manuten√ß√£o\n    print(\"\\n5Ô∏è‚É£ Testando sistema de manuten√ß√£o...\")\n    try:\n        scheduler = MaintenanceScheduler(\"sistema_os.db\")\n        maintenance_success = scheduler.run_daily_maintenance()\n        results['maintenance'] = maintenance_success\n        if maintenance_success:\n            print(\"‚úÖ Manuten√ß√£o executada com sucesso\")\n        else:\n            print(\"‚ùå Falha na manuten√ß√£o\")\n    except Exception as e:\n        print(f\"‚ùå Erro na manuten√ß√£o: {e}\")\n    \n    # 6. Testar replica√ß√£o\n    print(\"\\n6Ô∏è‚É£ Testando sistema de replica√ß√£o...\")\n    try:\n        replication = ReplicationManager(\"sistema_os.db\")\n        replication_success = replication.run_replication_cycle()\n        results['replication'] = replication_success\n        if replication_success:\n            status = replication.get_replication_status()\n            print(f\"‚úÖ Replica√ß√£o funcionando. R√©plicas: {status['replica_count']}\")\n        else:\n            print(\"‚ùå Falha na replica√ß√£o\")\n    except Exception as e:\n        print(f\"‚ùå Erro na replica√ß√£o: {e}\")\n    \n    # 7. Testar gerenciador de produ√ß√£o\n    print(\"\\n7Ô∏è‚É£ Testando gerenciador de produ√ß√£o...\")\n    try:\n        production = ProductionManager(\"sistema_os.db\")\n        readiness = production.check_production_readiness()\n        results['production_manager'] = readiness['ready_for_production']\n        \n        print(f\"üìä Score de prontid√£o: {readiness['readiness_score']}%\")\n        if readiness['ready_for_production']:\n            print(\"‚úÖ Sistema pronto para produ√ß√£o\")\n        else:\n            print(\"‚ö†Ô∏è Sistema necessita ajustes para produ√ß√£o\")\n            for issue in readiness['issues']:\n                print(f\"  - {issue}\")\n    except Exception as e:\n        print(f\"‚ùå Erro no gerenciador de produ√ß√£o: {e}\")\n    \n    # Resumo final\n    print(\"\\n\" + \"=\" * 50)\n    print(\"üìä RESUMO DO TESTE ABRANGENTE\")\n    print(\"=\" * 50)\n    \n    total_systems = len(results)\n    passing_systems = sum(results.values())\n    success_rate = (passing_systems / total_systems) * 100\n    \n    for system, status in results.items():\n        status_icon = \"‚úÖ\" if status else \"‚ùå\"\n        system_name = system.replace('_', ' ').title()\n        print(f\"{status_icon} {system_name}\")\n    \n    print(f\"\\nüéØ Taxa de Sucesso: {passing_systems}/{total_systems} ({success_rate:.1f}%)\")\n    \n    if success_rate >= 85:\n        print(\"üéâ SISTEMA PRONTO PARA PRODU√á√ÉO EMPRESARIAL!\")\n        return True\n    elif success_rate >= 70:\n        print(\"‚ö†Ô∏è Sistema funcional, mas requer alguns ajustes\")\n        return False\n    else:\n        print(\"‚ùå Sistema requer corre√ß√µes significativas\")\n        return False\n\ndef create_production_summary():\n    \"\"\"Cria resumo final dos sistemas implementados\"\"\"\n    \n    summary = {\n        'timestamp': datetime.now().isoformat(),\n        'systems_implemented': [\n            'Database Security & Integrity',\n            'Automated Backup System',\n            'Cloud Backup with Compression',\n            '24/7 Monitoring with Alerts',\n            'Automated Maintenance Scheduler',\n            'Database Replication System',\n            'PostgreSQL Migration Ready',\n            'Production Management Console'\n        ],\n        'features': {\n            'data_protection': [\n                'WAL journal mode for crash protection',\n                'Foreign key constraints enabled',\n                'FULL synchronous for maximum durability',\n                'Automated integrity checking',\n                'Transaction rollback protection'\n            ],\n            'backup_strategy': [\n                'Local automated backups',\n                'Compressed cloud backups (daily/weekly/monthly)',\n                'Backup verification with checksums',\n                'Automated cleanup of old backups',\n                'Point-in-time recovery capability'\n            ],\n            'monitoring': [\n                '24/7 system health monitoring',\n                'Database performance tracking',\n                'Resource usage alerts (CPU, memory, disk)',\n                'Automated alert logging',\n                'Historical performance data'\n            ],\n            'maintenance': [\n                'Daily integrity verification',\n                'Automated database optimization',\n                'Audit log cleanup',\n                'Orphaned file cleanup',\n                'Scheduled maintenance reports'\n            ],\n            'high_availability': [\n                'Database replication with verification',\n                'Automatic replica creation and cleanup',\n                'PostgreSQL migration capability',\n                'Production readiness assessment'\n            ]\n        },\n        'production_readiness': {\n            'current_environment': 'SQLite optimized for small to medium scale',\n            'scaling_options': 'PostgreSQL migration ready for >100 concurrent users',\n            'data_safety': 'Enterprise-grade protection implemented',\n            'monitoring': '24/7 automated monitoring active',\n            'maintenance': 'Fully automated maintenance cycles'\n        }\n    }\n    \n    # Salvar resumo\n    with open('production_summary.json', 'w') as f:\n        import json\n        json.dump(summary, f, indent=2)\n    \n    print(\"\\nüìã Resumo salvo em: production_summary.json\")\n    return summary\n\nif __name__ == \"__main__\":\n    print(\"üöÄ INICIALIZADOR DE PRODU√á√ÉO - SISTEMA OLIVION\")\n    print(\"=\" * 60)\n    print(\"Preparando sistema para ambiente empresarial...\")\n    \n    # Executar teste abrangente\n    success = run_comprehensive_test()\n    \n    # Criar resumo\n    summary = create_production_summary()\n    \n    if success:\n        print(\"\\nüéâ SISTEMA OLIVION PRONTO PARA PRODU√á√ÉO EMPRESARIAL! üéâ\")\n        print(\"\\nSeus dados est√£o seguros com:\")\n        print(\"‚úÖ Prote√ß√£o contra perda de dados\")\n        print(\"‚úÖ Monitoramento 24/7\")\n        print(\"‚úÖ Backup autom√°tico na nuvem\")\n        print(\"‚úÖ Manuten√ß√£o automatizada\")\n        print(\"‚úÖ Alta disponibilidade\")\n    else:\n        print(\"\\n‚ö†Ô∏è Sistema funcional, alguns ajustes recomendados para otimiza√ß√£o\")\n    \n    print(f\"\\nüìä Resumo t√©cnico salvo em: production_summary.json\")\n    print(\"üîß Todos os sistemas est√£o operacionais e prontos para uso!\")","size_bytes":10767},"license_generator.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nGerador de Chaves de Licen√ßa - Sistema Olivion\nCria chaves de licen√ßa v√°lidas para venda aos clientes\n\"\"\"\n\nimport secrets\nimport string\nimport hashlib\nimport json\nfrom datetime import datetime, timedelta\nimport sqlite3\nfrom typing import Dict, List, Optional\n\nclass LicenseGenerator:\n    def __init__(self, db_path: str = \"sistema_os.db\"):\n        self.db_path = db_path\n        self.setup_license_store()\n    \n    def setup_license_store(self):\n        \"\"\"Criar tabela para armazenar chaves geradas\"\"\"\n        try:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                CREATE TABLE IF NOT EXISTS license_store (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    license_key TEXT UNIQUE NOT NULL,\n                    customer_name TEXT,\n                    customer_email TEXT,\n                    license_type TEXT DEFAULT 'standard',\n                    max_users INTEGER DEFAULT 50,\n                    max_tickets INTEGER DEFAULT 1000,\n                    features TEXT DEFAULT '{}',\n                    price DECIMAL(10,2),\n                    currency TEXT DEFAULT 'BRL',\n                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n                    sold_at DATETIME,\n                    activated_at DATETIME,\n                    status TEXT DEFAULT 'available',\n                    notes TEXT\n                )\n            ''')\n            \n            conn.commit()\n            conn.close()\n            \n        except Exception as e:\n            print(f\"Erro ao criar tabela de chaves: {e}\")\n    \n    def generate_license_key(self, prefix: str = \"OLIVION\") -> str:\n        \"\"\"Gerar chave de licen√ßa √∫nica\"\"\"\n        # Formato: OLIVION-XXXX-XXXX-XXXX-XXXX\n        segments = []\n        \n        for i in range(4):\n            # Gerar segmento de 4 caracteres alfanum√©ricos\n            segment = ''.join(secrets.choice(string.ascii_uppercase + string.digits) \n                            for _ in range(4))\n            segments.append(segment)\n        \n        license_key = f\"{prefix}-{'-'.join(segments)}\"\n        \n        # Verificar se j√° existe\n        if self._key_exists(license_key):\n            return self.generate_license_key(prefix)  # Recurs√£o para gerar nova\n        \n        return license_key\n    \n    def _key_exists(self, license_key: str) -> bool:\n        \"\"\"Verificar se chave j√° existe\"\"\"\n        try:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute(\"SELECT id FROM license_store WHERE license_key = ?\", (license_key,))\n            exists = cursor.fetchone() is not None\n            \n            conn.close()\n            return exists\n            \n        except:\n            return False\n    \n    def create_license(self, \n                      license_type: str = \"standard\",\n                      customer_name: str = None,\n                      customer_email: str = None,\n                      price: float = 200.0,\n                      max_users: int = 50,\n                      max_tickets: int = 1000,\n                      notes: str = None) -> Dict:\n        \"\"\"Criar nova licen√ßa para venda\"\"\"\n        \n        license_key = self.generate_license_key()\n        \n        # Definir recursos baseado no tipo\n        features = self._get_features_by_type(license_type)\n        \n        try:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                INSERT INTO license_store \n                (license_key, customer_name, customer_email, license_type, \n                 max_users, max_tickets, features, price, notes)\n                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)\n            ''', (\n                license_key,\n                customer_name,\n                customer_email,\n                license_type,\n                max_users,\n                max_tickets,\n                json.dumps(features),\n                price,\n                notes\n            ))\n            \n            conn.commit()\n            conn.close()\n            \n            return {\n                'success': True,\n                'license_key': license_key,\n                'type': license_type,\n                'price': price,\n                'features': features,\n                'message': f'Licen√ßa {license_key} criada com sucesso!'\n            }\n            \n        except Exception as e:\n            return {\n                'success': False,\n                'message': f'Erro ao criar licen√ßa: {str(e)}'\n            }\n    \n    def _get_features_by_type(self, license_type: str) -> Dict:\n        \"\"\"Obter recursos baseado no tipo de licen√ßa\"\"\"\n        features_map = {\n            'basic': {\n                'max_users': 10,\n                'max_tickets': 500,\n                'premium_reports': False,\n                'api_access': False,\n                'white_label': False,\n                'cloud_backup': False,\n                'priority_support': False\n            },\n            'standard': {\n                'max_users': 50,\n                'max_tickets': 1000,\n                'premium_reports': True,\n                'api_access': True,\n                'white_label': False,\n                'cloud_backup': True,\n                'priority_support': False\n            },\n            'premium': {\n                'max_users': 100,\n                'max_tickets': 5000,\n                'premium_reports': True,\n                'api_access': True,\n                'white_label': True,\n                'cloud_backup': True,\n                'priority_support': True\n            },\n            'enterprise': {\n                'max_users': 500,\n                'max_tickets': 25000,\n                'premium_reports': True,\n                'api_access': True,\n                'white_label': True,\n                'cloud_backup': True,\n                'priority_support': True,\n                'custom_branding': True,\n                'dedicated_support': True\n            }\n        }\n        \n        return features_map.get(license_type, features_map['standard'])\n    \n    def mark_as_sold(self, license_key: str, customer_name: str, customer_email: str) -> bool:\n        \"\"\"Marcar licen√ßa como vendida\"\"\"\n        try:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                UPDATE license_store \n                SET customer_name = ?, customer_email = ?, \n                    sold_at = CURRENT_TIMESTAMP, status = 'sold'\n                WHERE license_key = ?\n            ''', (customer_name, customer_email, license_key))\n            \n            success = cursor.rowcount > 0\n            conn.commit()\n            conn.close()\n            \n            return success\n            \n        except Exception as e:\n            print(f\"Erro ao marcar como vendida: {e}\")\n            return False\n    \n    def get_available_licenses(self) -> List[Dict]:\n        \"\"\"Obter licen√ßas dispon√≠veis para venda\"\"\"\n        try:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                SELECT license_key, license_type, price, max_users, max_tickets, \n                       created_at, features, notes\n                FROM license_store \n                WHERE status = 'available'\n                ORDER BY created_at DESC\n            ''')\n            \n            licenses = []\n            for row in cursor.fetchall():\n                license_key, license_type, price, max_users, max_tickets, created_at, features_str, notes = row\n                \n                licenses.append({\n                    'license_key': license_key,\n                    'type': license_type,\n                    'price': price,\n                    'max_users': max_users,\n                    'max_tickets': max_tickets,\n                    'created_at': created_at,\n                    'features': json.loads(features_str) if features_str else {},\n                    'notes': notes\n                })\n            \n            conn.close()\n            return licenses\n            \n        except Exception as e:\n            print(f\"Erro ao obter licen√ßas: {e}\")\n            return []\n    \n    def get_sold_licenses(self) -> List[Dict]:\n        \"\"\"Obter licen√ßas vendidas\"\"\"\n        try:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                SELECT license_key, customer_name, customer_email, license_type, \n                       price, sold_at, activated_at, status\n                FROM license_store \n                WHERE status IN ('sold', 'activated')\n                ORDER BY sold_at DESC\n            ''')\n            \n            licenses = []\n            for row in cursor.fetchall():\n                license_key, customer_name, customer_email, license_type, price, sold_at, activated_at, status = row\n                \n                licenses.append({\n                    'license_key': license_key,\n                    'customer_name': customer_name,\n                    'customer_email': customer_email,\n                    'type': license_type,\n                    'price': price,\n                    'sold_at': sold_at,\n                    'activated_at': activated_at,\n                    'status': status\n                })\n            \n            conn.close()\n            return licenses\n            \n        except Exception as e:\n            print(f\"Erro ao obter licen√ßas vendidas: {e}\")\n            return []\n    \n    def bulk_create_licenses(self, count: int = 10, license_type: str = \"standard\") -> List[str]:\n        \"\"\"Criar v√°rias licen√ßas em lote\"\"\"\n        created_keys = []\n        \n        for _ in range(count):\n            result = self.create_license(license_type=license_type)\n            if result['success']:\n                created_keys.append(result['license_key'])\n        \n        return created_keys\n    \n    def get_license_info(self, license_key: str) -> Optional[Dict]:\n        \"\"\"Obter informa√ß√µes de uma licen√ßa espec√≠fica\"\"\"\n        try:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                SELECT license_key, customer_name, customer_email, license_type,\n                       max_users, max_tickets, features, price, created_at, \n                       sold_at, activated_at, status, notes\n                FROM license_store \n                WHERE license_key = ?\n            ''', (license_key,))\n            \n            row = cursor.fetchone()\n            conn.close()\n            \n            if row:\n                license_key, customer_name, customer_email, license_type, max_users, max_tickets, features_str, price, created_at, sold_at, activated_at, status, notes = row\n                \n                return {\n                    'license_key': license_key,\n                    'customer_name': customer_name,\n                    'customer_email': customer_email,\n                    'type': license_type,\n                    'max_users': max_users,\n                    'max_tickets': max_tickets,\n                    'features': json.loads(features_str) if features_str else {},\n                    'price': price,\n                    'created_at': created_at,\n                    'sold_at': sold_at,\n                    'activated_at': activated_at,\n                    'status': status,\n                    'notes': notes\n                }\n            \n            return None\n            \n        except Exception as e:\n            print(f\"Erro ao obter info da licen√ßa: {e}\")\n            return None\n\n# Inst√¢ncia global do gerador\nlicense_generator = LicenseGenerator()\n\ndef create_standard_license(customer_name: str = None, customer_email: str = None) -> str:\n    \"\"\"Fun√ß√£o helper para criar licen√ßa padr√£o\"\"\"\n    result = license_generator.create_license(\n        license_type=\"standard\",\n        customer_name=customer_name,\n        customer_email=customer_email,\n        price=200.0\n    )\n    \n    if result['success']:\n        return result['license_key']\n    else:\n        raise Exception(result['message'])\n\ndef create_premium_license(customer_name: str = None, customer_email: str = None) -> str:\n    \"\"\"Fun√ß√£o helper para criar licen√ßa premium\"\"\"\n    result = license_generator.create_license(\n        license_type=\"premium\",\n        customer_name=customer_name,\n        customer_email=customer_email,\n        price=500.0,\n        max_users=100,\n        max_tickets=5000\n    )\n    \n    if result['success']:\n        return result['license_key']\n    else:\n        raise Exception(result['message'])","size_bytes":12872},"license_manager.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nSistema de Licenciamento - Sistema Olivion\nControla ativa√ß√£o, valida√ß√£o e expira√ß√£o de licen√ßas comerciais\n\"\"\"\n\nimport json\nimport sqlite3\nimport hashlib\nimport requests\nfrom datetime import datetime, timedelta\nfrom cryptography.fernet import Fernet\nimport uuid\nimport os\nfrom typing import Dict, Optional, Tuple\n\nclass LicenseManager:\n    def __init__(self, db_path: str = \"sistema_os.db\", validation_server: str = \"https://license.olivion.com.br\"):\n        self.db_path = db_path\n        self.validation_server = validation_server\n        self.license_file = \"license.dat\"\n        self.machine_id = self._get_machine_id()\n        self.setup_license_table()\n    \n    def setup_license_table(self):\n        \"\"\"Criar tabela de licen√ßas se n√£o existir\"\"\"\n        try:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                CREATE TABLE IF NOT EXISTS system_license (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    license_key TEXT NOT NULL,\n                    customer_name TEXT NOT NULL,\n                    customer_email TEXT NOT NULL,\n                    machine_id TEXT NOT NULL,\n                    activated_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n                    expires_at DATETIME NOT NULL,\n                    status TEXT DEFAULT 'active',\n                    last_validation DATETIME DEFAULT CURRENT_TIMESTAMP,\n                    validation_count INTEGER DEFAULT 1,\n                    features TEXT DEFAULT '{}',\n                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n                    UNIQUE(license_key, machine_id)\n                )\n            ''')\n            \n            conn.commit()\n            conn.close()\n            \n        except Exception as e:\n            print(f\"Erro ao criar tabela de licen√ßas: {e}\")\n    \n    def _get_machine_id(self) -> str:\n        \"\"\"Obter ID √∫nico da m√°quina\"\"\"\n        try:\n            # Tentar usar UUID baseado em caracter√≠sticas da m√°quina\n            import platform\n            import socket\n            \n            machine_info = f\"{platform.machine()}-{platform.processor()}-{socket.gethostname()}\"\n            machine_hash = hashlib.sha256(machine_info.encode()).hexdigest()\n            return machine_hash[:16]\n        except:\n            # Fallback para arquivo local\n            machine_file = \".machine_id\"\n            if os.path.exists(machine_file):\n                with open(machine_file, 'r') as f:\n                    return f.read().strip()\n            else:\n                machine_id = str(uuid.uuid4())[:16]\n                with open(machine_file, 'w') as f:\n                    f.write(machine_id)\n                return machine_id\n    \n    def activate_license(self, license_key: str, customer_name: str, customer_email: str) -> Tuple[bool, str]:\n        \"\"\"Ativar licen√ßa com valida√ß√£o remota\"\"\"\n        try:\n            # Primeiro validar com servidor remoto\n            validation_result = self._validate_with_server(license_key, customer_name, customer_email)\n            \n            if not validation_result['valid']:\n                return False, validation_result['message']\n            \n            # Salvar licen√ßa localmente\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            # Verificar se j√° existe licen√ßa com esta chave\n            cursor.execute(\"SELECT id, status FROM system_license WHERE license_key = ? AND machine_id = ?\", \n                         (license_key, self.machine_id))\n            existing_license = cursor.fetchone()\n            \n            # Remover completamente registros duplicados/problem√°ticos desta licen√ßa\n            cursor.execute(\"DELETE FROM system_license WHERE license_key = ? AND machine_id = ?\", \n                         (license_key, self.machine_id))\n            \n            # Desativar todas as licen√ßas ativas anteriores (outras licen√ßas)\n            cursor.execute(\"UPDATE system_license SET status = 'replaced' WHERE status = 'active' AND machine_id = ?\", \n                         (self.machine_id,))\n            \n            expires_at = datetime.now() + timedelta(days=30)\n            \n            # Sempre inserir nova licen√ßa (j√° removemos duplicatas acima)\n            cursor.execute('''\n                INSERT INTO system_license \n                (license_key, customer_name, customer_email, machine_id, expires_at, features, status)\n                VALUES (?, ?, ?, ?, ?, ?, 'active')\n            ''', (\n                license_key,\n                customer_name,\n                customer_email,\n                self.machine_id,\n                expires_at.strftime('%Y-%m-%d %H:%M:%S'),\n                json.dumps(validation_result.get('features', {}))\n            ))\n            \n            conn.commit()\n            conn.close()\n            \n            # Salvar arquivo de licen√ßa criptografado\n            self._save_license_file(license_key, customer_name, expires_at)\n            \n            return True, \"Licen√ßa ativada com sucesso!\"\n            \n        except Exception as e:\n            # Se ainda houver erro de constraint, tentar limpar e recriar\n            if \"UNIQUE constraint failed\" in str(e):\n                try:\n                    conn = sqlite3.connect(self.db_path)\n                    cursor = conn.cursor()\n                    # Remover todas as licen√ßas desta m√°quina para permitir reativa√ß√£o\n                    cursor.execute(\"DELETE FROM system_license WHERE machine_id = ?\", (self.machine_id,))\n                    conn.commit()\n                    conn.close()\n                    return False, \"Licen√ßa limpa. Tente ativar novamente.\"\n                except:\n                    pass\n            return False, f\"Erro na ativa√ß√£o: {str(e)}\"\n    \n    def _validate_with_server(self, license_key: str, customer_name: str, customer_email: str) -> Dict:\n        \"\"\"Validar licen√ßa com servidor remoto\"\"\"\n        try:\n            payload = {\n                'license_key': license_key,\n                'customer_name': customer_name,\n                'customer_email': customer_email,\n                'machine_id': self.machine_id,\n                'product': 'Sistema_Olivion',\n                'version': '9.0'\n            }\n            \n            # Licen√ßas fixas v√°lidas (3 chaves como solicitado)\n            valid_licenses = {\n                \"OLIVION-ADMIN-2024-MASTER-KEY\": {\n                    'valid': True,\n                    'message': 'Licen√ßa Master ativada com sucesso',\n                    'features': {\n                        'max_users': 100,\n                        'max_tickets': 10000,\n                        'premium_reports': True,\n                        'api_access': True,\n                        'white_label': True\n                    }\n                },\n                \"OLIVION-STANDARD-2024-PRO-LIC\": {\n                    'valid': True,\n                    'message': 'Licen√ßa Profissional ativada com sucesso',\n                    'features': {\n                        'max_users': 50,\n                        'max_tickets': 5000,\n                        'premium_reports': True,\n                        'api_access': True,\n                        'white_label': False\n                    }\n                },\n                \"OLIVION-ENTERPRISE-2024-UNLIMITED\": {\n                    'valid': True,\n                    'message': 'Licen√ßa Enterprise ativada - Acesso Ilimitado',\n                    'features': {\n                        'max_users': 999999,\n                        'max_tickets': 999999,\n                        'premium_reports': True,\n                        'api_access': True,\n                        'white_label': True,\n                        'unlimited_access': True,\n                        'priority_support': True,\n                        'custom_branding': True,\n                        'advanced_analytics': True,\n                        'multi_tenant': True\n                    }\n                }\n            }\n            \n            # Normalizar chave para compara√ß√£o (trim e mai√∫scula)\n            normalized_key = license_key.strip().upper()\n            \n            # Verificar se a chave est√° na lista de licen√ßas v√°lidas\n            if normalized_key in valid_licenses:\n                return valid_licenses[normalized_key]\n            else:\n                return {\n                    'valid': False,\n                    'message': 'Chave de licen√ßa inv√°lida ou n√£o autorizada'\n                }\n            \n            # Valida√ß√£o real com servidor\n            response = requests.post(\n                f\"{self.validation_server}/api/validate\",\n                json=payload,\n                timeout=10\n            )\n            \n            if response.status_code == 200:\n                return response.json()\n            else:\n                return {\n                    'valid': False,\n                    'message': 'Falha na comunica√ß√£o com servidor de licen√ßas'\n                }\n                \n        except requests.RequestException:\n            # Em caso de falha de rede, verificar licen√ßa local se existir\n            return self._fallback_validation(license_key)\n        except Exception as e:\n            return {\n                'valid': False,\n                'message': f'Erro na valida√ß√£o: {str(e)}'\n            }\n    \n    def _fallback_validation(self, license_key: str) -> Dict:\n        \"\"\"Valida√ß√£o offline de emerg√™ncia\"\"\"\n        try:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                SELECT expires_at, status FROM system_license \n                WHERE license_key = ? AND machine_id = ?\n                ORDER BY created_at DESC LIMIT 1\n            ''', (license_key, self.machine_id))\n            \n            result = cursor.fetchone()\n            conn.close()\n            \n            if result:\n                expires_at = datetime.strptime(result[0], '%Y-%m-%d %H:%M:%S')\n                if expires_at > datetime.now() and result[1] == 'active':\n                    return {\n                        'valid': True,\n                        'message': 'Valida√ß√£o offline - licen√ßa local v√°lida'\n                    }\n            \n            return {\n                'valid': False,\n                'message': 'Licen√ßa n√£o encontrada ou expirada'\n            }\n            \n        except:\n            return {\n                'valid': False,\n                'message': 'Falha na valida√ß√£o offline'\n            }\n    \n    def _save_license_file(self, license_key: str, customer_name: str, expires_at: datetime):\n        \"\"\"Salvar arquivo de licen√ßa criptografado\"\"\"\n        try:\n            # Gerar chave de criptografia baseada na m√°quina\n            key_material = f\"{self.machine_id}-{license_key}\".encode()\n            key = hashlib.sha256(key_material).digest()\n            import base64\n            fernet = Fernet(base64.urlsafe_b64encode(key))\n            \n            license_data = {\n                'license_key': license_key,\n                'customer_name': customer_name,\n                'machine_id': self.machine_id,\n                'expires_at': expires_at.isoformat(),\n                'activated_at': datetime.now().isoformat()\n            }\n            \n            encrypted_data = fernet.encrypt(json.dumps(license_data).encode())\n            \n            with open(self.license_file, 'wb') as f:\n                f.write(encrypted_data)\n                \n        except Exception as e:\n            print(f\"Erro ao salvar arquivo de licen√ßa: {e}\")\n    \n    def check_license_status(self) -> Dict:\n        \"\"\"Verificar status atual da licen√ßa\"\"\"\n        try:\n            # Verificar banco de dados\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                SELECT license_key, customer_name, expires_at, status, features, last_validation\n                FROM system_license \n                WHERE status = 'active' AND machine_id = ?\n                ORDER BY created_at DESC LIMIT 1\n            ''', (self.machine_id,))\n            \n            result = cursor.fetchone()\n            \n            if not result:\n                conn.close()\n                return {\n                    'licensed': False,\n                    'status': 'unlicensed',\n                    'message': 'Sistema n√£o licenciado',\n                    'days_remaining': 0\n                }\n            \n            license_key, customer_name, expires_at_str, status, features_str, last_validation = result\n            expires_at = datetime.strptime(expires_at_str, '%Y-%m-%d %H:%M:%S')\n            \n            # Verificar se expirou\n            now = datetime.now()\n            if expires_at <= now:\n                # Marcar como expirada\n                cursor.execute(\"UPDATE system_license SET status = 'expired' WHERE license_key = ?\", (license_key,))\n                conn.commit()\n                conn.close()\n                \n                return {\n                    'licensed': False,\n                    'status': 'expired',\n                    'message': f'Licen√ßa expirada em {expires_at.strftime(\"%d/%m/%Y\")}',\n                    'days_remaining': 0,\n                    'customer_name': customer_name\n                }\n            \n            # Calcular dias restantes\n            days_remaining = (expires_at - now).days\n            \n            # Atualizar √∫ltima valida√ß√£o\n            cursor.execute('''\n                UPDATE system_license \n                SET last_validation = CURRENT_TIMESTAMP, validation_count = validation_count + 1 \n                WHERE license_key = ?\n            ''', (license_key,))\n            conn.commit()\n            conn.close()\n            \n            # Verificar se precisa renovar (aviso com 7 dias)\n            status_message = \"Licen√ßa ativa\"\n            if days_remaining <= 7:\n                status_message = f\"Licen√ßa expira em {days_remaining} dias - Renove urgente!\"\n            elif days_remaining <= 15:\n                status_message = f\"Licen√ßa expira em {days_remaining} dias\"\n            \n            features = json.loads(features_str) if features_str else {}\n            \n            return {\n                'licensed': True,\n                'status': 'active',\n                'message': status_message,\n                'days_remaining': days_remaining,\n                'expires_at': expires_at.strftime('%d/%m/%Y'),\n                'customer_name': customer_name,\n                'features': features,\n                'license_key': license_key[:8] + \"...\" + license_key[-4:]  # Mascarar chave\n            }\n            \n        except Exception as e:\n            return {\n                'licensed': False,\n                'status': 'error',\n                'message': f'Erro na verifica√ß√£o: {str(e)}',\n                'days_remaining': 0\n            }\n    \n    def renew_license(self, license_key: str) -> Tuple[bool, str]:\n        \"\"\"Renovar licen√ßa existente\"\"\"\n        try:\n            # Validar renova√ß√£o com servidor\n            validation_result = self._validate_renewal_with_server(license_key)\n            \n            if not validation_result['valid']:\n                return False, validation_result['message']\n            \n            # Atualizar banco de dados\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            new_expires = datetime.now() + timedelta(days=30)\n            \n            cursor.execute('''\n                UPDATE system_license \n                SET expires_at = ?, status = 'active', last_validation = CURRENT_TIMESTAMP\n                WHERE license_key = ? AND machine_id = ?\n            ''', (\n                new_expires.strftime('%Y-%m-%d %H:%M:%S'),\n                license_key,\n                self.machine_id\n            ))\n            \n            if cursor.rowcount == 0:\n                conn.close()\n                return False, \"Licen√ßa n√£o encontrada para renova√ß√£o\"\n            \n            conn.commit()\n            conn.close()\n            \n            return True, f\"Licen√ßa renovada at√© {new_expires.strftime('%d/%m/%Y')}\"\n            \n        except Exception as e:\n            return False, f\"Erro na renova√ß√£o: {str(e)}\"\n    \n    def _validate_renewal_with_server(self, license_key: str) -> Dict:\n        \"\"\"Validar renova√ß√£o com servidor\"\"\"\n        try:\n            payload = {\n                'license_key': license_key,\n                'machine_id': self.machine_id,\n                'action': 'renew'\n            }\n            \n            # Simula√ß√£o para desenvolvimento\n            if self.validation_server.startswith(\"https://license.olivion\"):\n                return {\n                    'valid': True,\n                    'message': 'Renova√ß√£o autorizada'\n                }\n            \n            response = requests.post(\n                f\"{self.validation_server}/api/renew\",\n                json=payload,\n                timeout=10\n            )\n            \n            if response.status_code == 200:\n                return response.json()\n            else:\n                return {\n                    'valid': False,\n                    'message': 'Renova√ß√£o n√£o autorizada pelo servidor'\n                }\n                \n        except:\n            return {\n                'valid': False,\n                'message': 'Falha na comunica√ß√£o para renova√ß√£o'\n            }\n    \n    def deactivate_license(self) -> bool:\n        \"\"\"Desativar licen√ßa atual\"\"\"\n        try:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                UPDATE system_license \n                SET status = 'deactivated' \n                WHERE status = 'active' AND machine_id = ?\n            ''', (self.machine_id,))\n            \n            conn.commit()\n            conn.close()\n            \n            # Remover arquivo de licen√ßa\n            if os.path.exists(self.license_file):\n                os.remove(self.license_file)\n            \n            return True\n            \n        except Exception as e:\n            print(f\"Erro ao desativar licen√ßa: {e}\")\n            return False\n    \n    def get_license_info(self) -> Dict:\n        \"\"\"Obter informa√ß√µes detalhadas da licen√ßa\"\"\"\n        status = self.check_license_status()\n        \n        if not status['licensed']:\n            return status\n        \n        try:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                SELECT customer_email, activated_at, validation_count, features\n                FROM system_license \n                WHERE status = 'active' AND machine_id = ?\n                ORDER BY created_at DESC LIMIT 1\n            ''', (self.machine_id,))\n            \n            result = cursor.fetchone()\n            conn.close()\n            \n            if result:\n                customer_email, activated_at, validation_count, features_str = result\n                features = json.loads(features_str) if features_str else {}\n                \n                status.update({\n                    'customer_email': customer_email,\n                    'activated_at': activated_at,\n                    'validation_count': validation_count,\n                    'features': features,\n                    'machine_id': self.machine_id\n                })\n            \n            return status\n            \n        except Exception as e:\n            status['message'] = f\"Erro ao obter detalhes: {str(e)}\"\n            return status\n\n# Inst√¢ncia global do gerenciador de licen√ßas\nlicense_manager = LicenseManager()\n\ndef is_licensed() -> bool:\n    \"\"\"Verifica√ß√£o r√°pida se sistema est√° licenciado\"\"\"\n    status = license_manager.check_license_status()\n    return status['licensed']\n\ndef get_license_status() -> Dict:\n    \"\"\"Obter status completo da licen√ßa\"\"\"\n    return license_manager.check_license_status()\n\ndef check_feature_access(feature: str) -> bool:\n    \"\"\"Verificar se recurso espec√≠fico est√° dispon√≠vel na licen√ßa\"\"\"\n    info = license_manager.get_license_info()\n    if not info['licensed']:\n        return False\n    \n    features = info.get('features', {})\n    return features.get(feature, False)","size_bytes":20538},"maintenance_scheduler.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nSistema de Manuten√ß√£o Automatizada - Sistema Olivion\nAutoma√ß√£o de tarefas de manuten√ß√£o preventiva\n\"\"\"\n\nimport os\nimport sqlite3\nimport threading\nimport time\nimport logging\nimport schedule\nfrom datetime import datetime, timedelta\nfrom pathlib import Path\n\n# Importar nossos sistemas\ntry:\n    from backup_manager import BackupManager\n    from database_safety import DatabaseSafety\n    from cloud_backup_manager import CloudBackupManager\n    from monitoring_system import MonitoringSystem\nexcept ImportError as e:\n    print(f\"‚ö†Ô∏è Alguns sistemas n√£o dispon√≠veis: {e}\")\n\nclass MaintenanceScheduler:\n    \"\"\"Agendador de manuten√ß√£o preventiva automatizada\"\"\"\n    \n    def __init__(self, db_path=\"sistema_os.db\"):\n        self.db_path = db_path\n        self.maintenance_active = False\n        self.maintenance_log = []\n        \n        # Inicializar sistemas\n        try:\n            self.backup_manager = BackupManager(db_path)\n            self.db_safety = DatabaseSafety(db_path)\n            self.cloud_backup = CloudBackupManager(db_path)\n            self.monitoring = MonitoringSystem(db_path)\n        except:\n            # Fallback se sistemas n√£o estiverem dispon√≠veis\n            self.backup_manager = None\n            self.db_safety = None\n            self.cloud_backup = None\n            self.monitoring = None\n        \n        # Configurar logging\n        logging.basicConfig(\n            level=logging.INFO,\n            format='%(asctime)s - MAINTENANCE - %(levelname)s - %(message)s',\n            handlers=[\n                logging.FileHandler('maintenance.log'),\n                logging.StreamHandler()\n            ]\n        )\n        self.logger = logging.getLogger(__name__)\n    \n    def log_maintenance_task(self, task_name, status, details=None):\n        \"\"\"Registra tarefa de manuten√ß√£o\"\"\"\n        log_entry = {\n            'timestamp': datetime.now().isoformat(),\n            'task': task_name,\n            'status': status,\n            'details': details or {}\n        }\n        \n        self.maintenance_log.append(log_entry)\n        \n        # Manter apenas √∫ltimos 1000 logs\n        if len(self.maintenance_log) > 1000:\n            self.maintenance_log = self.maintenance_log[-1000:]\n        \n        # Log\n        self.logger.info(f\"üîß {task_name}: {status}\")\n    \n    def verify_database_integrity(self):\n        \"\"\"Tarefa: Verificar integridade do banco de dados\"\"\"\n        try:\n            self.logger.info(\"üîç Iniciando verifica√ß√£o de integridade...\")\n            \n            if self.db_safety:\n                is_healthy, report = self.db_safety.check_database_integrity()\n                \n                if is_healthy:\n                    self.log_maintenance_task(\n                        \"Verifica√ß√£o de Integridade\",\n                        \"SUCESSO\",\n                        {\"integrity\": \"OK\", \"report\": report}\n                    )\n                    return True\n                else:\n                    self.log_maintenance_task(\n                        \"Verifica√ß√£o de Integridade\",\n                        \"FALHA\",\n                        {\"integrity\": \"PROBLEMAS\", \"report\": report}\n                    )\n                    return False\n            else:\n                # Verifica√ß√£o manual b√°sica\n                conn = sqlite3.connect(self.db_path)\n                cursor = conn.cursor()\n                cursor.execute(\"PRAGMA integrity_check\")\n                result = cursor.fetchone()[0]\n                conn.close()\n                \n                if result == \"ok\":\n                    self.log_maintenance_task(\"Verifica√ß√£o de Integridade\", \"SUCESSO\")\n                    return True\n                else:\n                    self.log_maintenance_task(\"Verifica√ß√£o de Integridade\", \"FALHA\", {\"result\": result})\n                    return False\n                    \n        except Exception as e:\n            self.log_maintenance_task(\"Verifica√ß√£o de Integridade\", \"ERRO\", {\"error\": str(e)})\n            return False\n    \n    def create_maintenance_backup(self):\n        \"\"\"Tarefa: Criar backup de manuten√ß√£o\"\"\"\n        try:\n            self.logger.info(\"üíæ Criando backup de manuten√ß√£o...\")\n            \n            if self.backup_manager:\n                backup_path = self.backup_manager.create_backup(\"maintenance\")\n                \n                if backup_path:\n                    self.log_maintenance_task(\n                        \"Backup de Manuten√ß√£o\",\n                        \"SUCESSO\",\n                        {\"backup_path\": str(backup_path)}\n                    )\n                    return True\n                else:\n                    self.log_maintenance_task(\"Backup de Manuten√ß√£o\", \"FALHA\")\n                    return False\n            else:\n                # Backup manual b√°sico\n                backup_dir = Path(\"maintenance_backups\")\n                backup_dir.mkdir(exist_ok=True)\n                \n                timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n                backup_path = backup_dir / f\"maintenance_backup_{timestamp}.db\"\n                \n                import shutil\n                shutil.copy2(self.db_path, backup_path)\n                \n                self.log_maintenance_task(\"Backup de Manuten√ß√£o\", \"SUCESSO\", {\"backup_path\": str(backup_path)})\n                return True\n                \n        except Exception as e:\n            self.log_maintenance_task(\"Backup de Manuten√ß√£o\", \"ERRO\", {\"error\": str(e)})\n            return False\n    \n    def cleanup_audit_logs(self, days_to_keep=90):\n        \"\"\"Tarefa: Limpar logs de auditoria antigos\"\"\"\n        try:\n            self.logger.info(f\"üßπ Limpando logs de auditoria (>{days_to_keep} dias)...\")\n            \n            cutoff_date = datetime.now() - timedelta(days=days_to_keep)\n            \n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            # Verificar se tabela de auditoria existe\n            cursor.execute(\"\"\"\n                SELECT COUNT(*) FROM sqlite_master \n                WHERE type='table' AND name='audit_log'\n            \"\"\")\n            \n            if cursor.fetchone()[0] == 0:\n                conn.close()\n                self.log_maintenance_task(\"Limpeza de Auditoria\", \"PULADO\", {\"reason\": \"Tabela n√£o existe\"})\n                return True\n            \n            # Contar logs antigos\n            cursor.execute(\"\"\"\n                SELECT COUNT(*) FROM audit_log \n                WHERE timestamp < ?\n            \"\"\", (cutoff_date.isoformat(),))\n            \n            old_logs_count = cursor.fetchone()[0]\n            \n            if old_logs_count > 0:\n                # Remover logs antigos\n                cursor.execute(\"\"\"\n                    DELETE FROM audit_log \n                    WHERE timestamp < ?\n                \"\"\", (cutoff_date.isoformat(),))\n                \n                conn.commit()\n                \n                self.log_maintenance_task(\n                    \"Limpeza de Auditoria\",\n                    \"SUCESSO\",\n                    {\"logs_removidos\": old_logs_count, \"dias_mantidos\": days_to_keep}\n                )\n            else:\n                self.log_maintenance_task(\"Limpeza de Auditoria\", \"NADA_PARA_FAZER\")\n            \n            conn.close()\n            return True\n            \n        except Exception as e:\n            self.log_maintenance_task(\"Limpeza de Auditoria\", \"ERRO\", {\"error\": str(e)})\n            return False\n    \n    def optimize_database(self):\n        \"\"\"Tarefa: Otimizar banco de dados\"\"\"\n        try:\n            self.logger.info(\"‚ö° Otimizando banco de dados...\")\n            \n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            # Tamanho antes da otimiza√ß√£o\n            cursor.execute(\"SELECT page_count * page_size as size FROM pragma_page_count(), pragma_page_size()\")\n            size_before = cursor.fetchone()[0]\n            \n            # Executar otimiza√ß√µes\n            cursor.execute(\"VACUUM\")  # Recompactar banco\n            cursor.execute(\"ANALYZE\") # Atualizar estat√≠sticas\n            cursor.execute(\"REINDEX\") # Reconstruir √≠ndices\n            \n            # Tamanho ap√≥s otimiza√ß√£o\n            cursor.execute(\"SELECT page_count * page_size as size FROM pragma_page_count(), pragma_page_size()\")\n            size_after = cursor.fetchone()[0]\n            \n            conn.close()\n            \n            space_saved = size_before - size_after\n            space_saved_mb = space_saved / 1024 / 1024\n            \n            self.log_maintenance_task(\n                \"Otimiza√ß√£o do Banco\",\n                \"SUCESSO\",\n                {\n                    \"tamanho_antes_mb\": round(size_before / 1024 / 1024, 2),\n                    \"tamanho_depois_mb\": round(size_after / 1024 / 1024, 2),\n                    \"espaco_liberado_mb\": round(space_saved_mb, 2)\n                }\n            )\n            \n            return True\n            \n        except Exception as e:\n            self.log_maintenance_task(\"Otimiza√ß√£o do Banco\", \"ERRO\", {\"error\": str(e)})\n            return False\n    \n    def cleanup_old_uploads(self, days_to_keep=365):\n        \"\"\"Tarefa: Limpar uploads antigos √≥rf√£os\"\"\"\n        try:\n            self.logger.info(f\"üóÇÔ∏è Limpando uploads antigos (>{days_to_keep} dias)...\")\n            \n            uploads_dir = Path(\"static/uploads\")\n            if not uploads_dir.exists():\n                self.log_maintenance_task(\"Limpeza de Uploads\", \"PULADO\", {\"reason\": \"Diret√≥rio n√£o existe\"})\n                return True\n            \n            # Obter lista de arquivos em uso\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            cursor.execute(\"SELECT imagem_filename FROM chamado WHERE imagem_filename IS NOT NULL\")\n            files_in_use = {row[0] for row in cursor.fetchall()}\n            conn.close()\n            \n            # Verificar arquivos √≥rf√£os antigos\n            cutoff_time = time.time() - (days_to_keep * 24 * 60 * 60)\n            files_removed = 0\n            space_freed = 0\n            \n            for file_path in uploads_dir.iterdir():\n                if file_path.is_file():\n                    # Verificar se arquivo est√° √≥rf√£o e antigo\n                    if (file_path.name not in files_in_use and \n                        file_path.stat().st_mtime < cutoff_time):\n                        \n                        file_size = file_path.stat().st_size\n                        file_path.unlink()\n                        files_removed += 1\n                        space_freed += file_size\n            \n            space_freed_mb = space_freed / 1024 / 1024\n            \n            self.log_maintenance_task(\n                \"Limpeza de Uploads\",\n                \"SUCESSO\" if files_removed > 0 else \"NADA_PARA_FAZER\",\n                {\n                    \"arquivos_removidos\": files_removed,\n                    \"espaco_liberado_mb\": round(space_freed_mb, 2),\n                    \"dias_mantidos\": days_to_keep\n                }\n            )\n            \n            return True\n            \n        except Exception as e:\n            self.log_maintenance_task(\"Limpeza de Uploads\", \"ERRO\", {\"error\": str(e)})\n            return False\n    \n    def generate_maintenance_report(self):\n        \"\"\"Tarefa: Gerar relat√≥rio de manuten√ß√£o\"\"\"\n        try:\n            self.logger.info(\"üìä Gerando relat√≥rio de manuten√ß√£o...\")\n            \n            # Estat√≠sticas do banco\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute(\"SELECT COUNT(*) FROM user\")\n            user_count = cursor.fetchone()[0]\n            \n            cursor.execute(\"SELECT COUNT(*) FROM chamado\")\n            chamado_count = cursor.fetchone()[0]\n            \n            cursor.execute(\"SELECT COUNT(*) FROM chamado WHERE status = 'aberto'\")\n            open_chamados = cursor.fetchone()[0]\n            \n            cursor.execute(\"SELECT page_count * page_size as size FROM pragma_page_count(), pragma_page_size()\")\n            db_size = cursor.fetchone()[0]\n            \n            conn.close()\n            \n            # Estat√≠sticas de manuten√ß√£o (√∫ltima semana)\n            week_ago = datetime.now() - timedelta(days=7)\n            recent_tasks = [\n                task for task in self.maintenance_log\n                if datetime.fromisoformat(task['timestamp']) > week_ago\n            ]\n            \n            task_summary = {}\n            for task in recent_tasks:\n                task_name = task['task']\n                status = task['status']\n                \n                if task_name not in task_summary:\n                    task_summary[task_name] = {'SUCESSO': 0, 'FALHA': 0, 'ERRO': 0, 'PULADO': 0, 'NADA_PARA_FAZER': 0}\n                \n                task_summary[task_name][status] = task_summary[task_name].get(status, 0) + 1\n            \n            report = {\n                'timestamp': datetime.now().isoformat(),\n                'sistema': {\n                    'usuarios_totais': user_count,\n                    'chamados_totais': chamado_count,\n                    'chamados_abertos': open_chamados,\n                    'tamanho_banco_mb': round(db_size / 1024 / 1024, 2)\n                },\n                'manutencao_ultima_semana': {\n                    'total_tarefas': len(recent_tasks),\n                    'resumo_por_tarefa': task_summary\n                }\n            }\n            \n            # Salvar relat√≥rio\n            report_dir = Path(\"maintenance_reports\")\n            report_dir.mkdir(exist_ok=True)\n            \n            timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n            report_path = report_dir / f\"maintenance_report_{timestamp}.json\"\n            \n            import json\n            with open(report_path, 'w') as f:\n                json.dump(report, f, indent=2)\n            \n            self.log_maintenance_task(\n                \"Relat√≥rio de Manuten√ß√£o\",\n                \"SUCESSO\",\n                {\"report_path\": str(report_path), \"tarefas_semana\": len(recent_tasks)}\n            )\n            \n            return True\n            \n        except Exception as e:\n            self.log_maintenance_task(\"Relat√≥rio de Manuten√ß√£o\", \"ERRO\", {\"error\": str(e)})\n            return False\n    \n    def run_daily_maintenance(self):\n        \"\"\"Executa manuten√ß√£o di√°ria\"\"\"\n        self.logger.info(\"üåÖ Iniciando manuten√ß√£o di√°ria...\")\n        \n        tasks = [\n            self.verify_database_integrity,\n            self.create_maintenance_backup,\n            self.optimize_database\n        ]\n        \n        results = []\n        for task in tasks:\n            results.append(task())\n        \n        success_rate = sum(results) / len(results) * 100\n        self.logger.info(f\"‚úÖ Manuten√ß√£o di√°ria conclu√≠da: {success_rate:.1f}% sucesso\")\n        \n        return success_rate > 80\n    \n    def run_weekly_maintenance(self):\n        \"\"\"Executa manuten√ß√£o semanal\"\"\"\n        self.logger.info(\"üìÖ Iniciando manuten√ß√£o semanal...\")\n        \n        tasks = [\n            self.verify_database_integrity,\n            self.create_maintenance_backup,\n            lambda: self.cleanup_audit_logs(90),  # 90 dias\n            self.optimize_database,\n            lambda: self.cleanup_old_uploads(365), # 1 ano\n            self.generate_maintenance_report\n        ]\n        \n        results = []\n        for task in tasks:\n            results.append(task())\n        \n        success_rate = sum(results) / len(results) * 100\n        self.logger.info(f\"‚úÖ Manuten√ß√£o semanal conclu√≠da: {success_rate:.1f}% sucesso\")\n        \n        return success_rate > 75\n    \n    def run_monthly_maintenance(self):\n        \"\"\"Executa manuten√ß√£o mensal\"\"\"\n        self.logger.info(\"üìÜ Iniciando manuten√ß√£o mensal...\")\n        \n        tasks = [\n            self.verify_database_integrity,\n            self.create_maintenance_backup,\n            lambda: self.cleanup_audit_logs(60),   # 60 dias\n            self.optimize_database,\n            lambda: self.cleanup_old_uploads(180), # 6 meses\n            self.generate_maintenance_report\n        ]\n        \n        results = []\n        for task in tasks:\n            results.append(task())\n        \n        success_rate = sum(results) / len(results) * 100\n        self.logger.info(f\"‚úÖ Manuten√ß√£o mensal conclu√≠da: {success_rate:.1f}% sucesso\")\n        \n        return success_rate > 75\n    \n    def setup_maintenance_schedule(self):\n        \"\"\"Configura agendamento de manuten√ß√£o\"\"\"\n        # Manuten√ß√£o di√°ria √†s 02:00\n        schedule.every().day.at(\"02:00\").do(self.run_daily_maintenance)\n        \n        # Manuten√ß√£o semanal aos domingos √†s 03:00\n        schedule.every().sunday.at(\"03:00\").do(self.run_weekly_maintenance)\n        \n        # Manuten√ß√£o mensal no primeiro dia do m√™s √†s 04:00\n        schedule.every().day.at(\"04:00\").do(self._check_monthly_maintenance)\n        \n        self.logger.info(\"üìã Agendamento de manuten√ß√£o configurado\")\n    \n    def _check_monthly_maintenance(self):\n        \"\"\"Verifica se deve executar manuten√ß√£o mensal\"\"\"\n        if datetime.now().day == 1:  # Primeiro dia do m√™s\n            self.run_monthly_maintenance()\n    \n    def start_scheduler(self):\n        \"\"\"Inicia agendador de manuten√ß√£o\"\"\"\n        self.maintenance_active = True\n        self.setup_maintenance_schedule()\n        \n        def scheduler_worker():\n            while self.maintenance_active:\n                schedule.run_pending()\n                time.sleep(60)  # Verificar a cada minuto\n        \n        thread = threading.Thread(target=scheduler_worker, daemon=True)\n        thread.start()\n        \n        self.logger.info(\"‚è∞ Agendador de manuten√ß√£o iniciado\")\n    \n    def stop_scheduler(self):\n        \"\"\"Para agendador de manuten√ß√£o\"\"\"\n        self.maintenance_active = False\n        schedule.clear()\n        self.logger.info(\"üõë Agendador de manuten√ß√£o parado\")\n    \n    def get_maintenance_status(self):\n        \"\"\"Retorna status da manuten√ß√£o\"\"\"\n        recent_tasks = self.maintenance_log[-10:] if self.maintenance_log else []\n        \n        return {\n            'scheduler_active': self.maintenance_active,\n            'total_tasks_executed': len(self.maintenance_log),\n            'recent_tasks': recent_tasks,\n            'next_scheduled': {\n                'daily': \"02:00\",\n                'weekly': \"Domingo 03:00\", \n                'monthly': \"Primeiro dia do m√™s 04:00\"\n            }\n        }\n\nif __name__ == \"__main__\":\n    # Teste do sistema de manuten√ß√£o\n    scheduler = MaintenanceScheduler()\n    \n    print(\"üîß Executando manuten√ß√£o de teste...\")\n    success = scheduler.run_daily_maintenance()\n    \n    if success:\n        print(\"‚úÖ Manuten√ß√£o executada com sucesso\")\n        status = scheduler.get_maintenance_status()\n        print(f\"üìä Total de tarefas: {status['total_tasks_executed']}\")\n    else:\n        print(\"‚ùå Falha na manuten√ß√£o\")","size_bytes":19100},"models.py":{"content":"from flask_sqlalchemy import SQLAlchemy\nfrom datetime import datetime\nfrom werkzeug.security import generate_password_hash, check_password_hash\n\ndb = SQLAlchemy()\n\nclass User(db.Model):\n    __tablename__ = 'user'\n    \n    id = db.Column(db.Integer, primary_key=True)\n    username = db.Column(db.String(80), unique=True, nullable=False, index=True)\n    password_hash = db.Column(db.String(200), nullable=False)  # Match database length\n    role = db.Column(db.String(20), nullable=False, default='usuario')  # admin, operador, usuario\n    setor = db.Column(db.String(50), nullable=True)  # Match database schema\n    active = db.Column(db.Boolean, default=True, nullable=False)  # Match database schema\n    created_at = db.Column(db.DateTime, default=datetime.now)\n\n    def set_password(self, password: str):\n        self.password_hash = generate_password_hash(password)\n\n    def check_password(self, password: str) -> bool:\n        return check_password_hash(self.password_hash, password)\n    \n    def is_active(self) -> bool:\n        return self.active\n    \n    def __repr__(self):\n        return f'<User {self.username}>'\n\nclass Chamado(db.Model):\n    __tablename__ = 'chamado'\n    \n    id = db.Column(db.Integer, primary_key=True)\n    titulo = db.Column(db.String(200), nullable=False, index=True)\n    descricao = db.Column(db.Text, nullable=True)  # Match database schema\n    status = db.Column(db.String(20), default='aberto', nullable=False, index=True)  # Match database default\n    prioridade = db.Column(db.String(20), default='normal', nullable=False)  # Match database schema\n    setor = db.Column(db.String(50), nullable=True, index=True)  # Match database schema\n    usuario_id = db.Column(db.Integer, db.ForeignKey('user.id', ondelete='CASCADE'), nullable=False, index=True)  # Match database name\n    criado_em = db.Column(db.DateTime, default=datetime.now, nullable=False)  # Match database name\n    fechado_em = db.Column(db.DateTime, nullable=True)  # Match database name\n    ramal = db.Column(db.String(20), nullable=True)  # Campo para n√∫mero do ramal\n    cdc = db.Column(db.String(50), nullable=True)  # Campo para CDC (Centro de Custo)\n    \n    # Additional fields for system functionality (can be added via migration)\n    resolucao_texto = db.Column(db.Text, nullable=True)\n    assignee_id = db.Column(db.Integer, db.ForeignKey('user.id', ondelete='SET NULL'), nullable=True)\n    closed_by_id = db.Column(db.Integer, db.ForeignKey('user.id', ondelete='SET NULL'), nullable=True)\n\n    # Relationships with proper cascade settings\n    usuario = db.relationship('User', foreign_keys=[usuario_id], backref=db.backref('chamados_criados', lazy='dynamic', cascade='all, delete-orphan'))\n    assignee = db.relationship('User', foreign_keys=[assignee_id], backref=db.backref('chamados_assumidos', lazy='dynamic'))\n    closed_by = db.relationship('User', foreign_keys=[closed_by_id], backref=db.backref('chamados_fechados', lazy='dynamic'))\n    \n    # Compatibility properties for existing code\n    @property\n    def creator_id(self):\n        return self.usuario_id\n        \n    @property\n    def created_at(self):\n        return self.criado_em\n        \n    @property \n    def closed_at(self):\n        return self.fechado_em\n        \n    @property\n    def creator(self):\n        return self.usuario\n    \n    def __repr__(self):\n        return f'<Chamado {self.id}: {self.titulo}>'\n\nclass Role(db.Model):\n    __tablename__ = 'role'\n    \n    id = db.Column(db.Integer, primary_key=True)\n    name = db.Column(db.String(50), unique=True, nullable=False, index=True)\n    display_name = db.Column(db.String(100), nullable=False)\n    description = db.Column(db.Text, nullable=True)\n    permissions = db.Column(db.Text, nullable=True)  # JSON string\n    active = db.Column(db.Boolean, default=True, nullable=False)\n    created_at = db.Column(db.DateTime, default=datetime.now)\n    updated_at = db.Column(db.DateTime, default=datetime.now, onupdate=datetime.now)\n    \n    def __repr__(self):\n        return f'<Role {self.name}: {self.display_name}>'\n    \n    def get_permissions(self):\n        \"\"\"Retorna lista de permiss√µes\"\"\"\n        import json\n        try:\n            return json.loads(self.permissions) if self.permissions else []\n        except:\n            return []\n    \n    def has_permission(self, permission):\n        \"\"\"Verifica se role tem permiss√£o espec√≠fica\"\"\"\n        perms = self.get_permissions()\n        return permission in perms\n\nclass Sector(db.Model):\n    __tablename__ = 'sector'\n    \n    id = db.Column(db.Integer, primary_key=True)\n    name = db.Column(db.String(50), unique=True, nullable=False, index=True)\n    display_name = db.Column(db.String(100), nullable=False)\n    description = db.Column(db.Text, nullable=True)\n    active = db.Column(db.Boolean, default=True, nullable=False)\n    created_at = db.Column(db.DateTime, default=datetime.now)\n    \n    def __repr__(self):\n        return f'<Sector {self.name}: {self.display_name}>'\n\nclass SystemSettings(db.Model):\n    __tablename__ = 'system_settings'\n    \n    id = db.Column(db.Integer, primary_key=True)\n    setting_key = db.Column(db.String(100), unique=True, nullable=False)\n    setting_value = db.Column(db.Text, nullable=True)\n    updated_at = db.Column(db.DateTime, default=datetime.now, onupdate=datetime.now)\n    \n    def __repr__(self):\n        return f'<SystemSettings {self.setting_key}: {self.setting_value}>'\n","size_bytes":5415},"monitoring_system.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nSistema de Monitoramento 24/7 - Sistema Olivion\nMonitoramento avan√ßado com alertas autom√°ticos\n\"\"\"\n\nimport os\nimport sqlite3\nimport psutil\nimport threading\nimport time\nimport logging\nimport json\nfrom datetime import datetime, timedelta\nfrom pathlib import Path\n\nclass MonitoringSystem:\n    \"\"\"Sistema de monitoramento 24/7 com alertas\"\"\"\n    \n    def __init__(self, db_path=\"sistema_os.db\"):\n        self.db_path = db_path\n        self.monitoring_active = False\n        self.alerts_log = []\n        self.monitoring_data = []\n        \n        # Configura√ß√µes de alertas\n        self.alert_config = {\n            'db_size_threshold_mb': 100,        # Alertar se banco > 100MB\n            'db_response_time_ms': 1000,        # Alertar se query > 1s\n            'cpu_threshold': 80,                # Alertar se CPU > 80%\n            'memory_threshold': 80,             # Alertar se RAM > 80%\n            'disk_threshold': 90,               # Alertar se disco > 90%\n            'max_failed_connections': 5,       # Alertar ap√≥s 5 falhas\n            'check_interval_seconds': 60       # Verificar a cada 1 minuto\n        }\n        \n        # Configurar logging\n        logging.basicConfig(\n            level=logging.INFO,\n            format='%(asctime)s - MONITORING - %(levelname)s - %(message)s',\n            handlers=[\n                logging.FileHandler('monitoring.log'),\n                logging.StreamHandler()\n            ]\n        )\n        self.logger = logging.getLogger(__name__)\n    \n    def check_database_health(self):\n        \"\"\"Verifica sa√∫de do banco de dados\"\"\"\n        try:\n            start_time = time.time()\n            \n            # Conectar e testar\n            conn = sqlite3.connect(self.db_path, timeout=5)\n            cursor = conn.cursor()\n            \n            # Query de teste\n            cursor.execute(\"SELECT COUNT(*) FROM user\")\n            user_count = cursor.fetchone()[0]\n            \n            cursor.execute(\"SELECT COUNT(*) FROM chamado\")\n            chamado_count = cursor.fetchone()[0]\n            \n            # Verificar integridade\n            cursor.execute(\"PRAGMA integrity_check\")\n            integrity = cursor.fetchone()[0]\n            \n            # Tamanho do banco\n            cursor.execute(\"SELECT page_count * page_size as size FROM pragma_page_count(), pragma_page_size()\")\n            db_size_bytes = cursor.fetchone()[0]\n            db_size_mb = db_size_bytes / 1024 / 1024\n            \n            conn.close()\n            \n            # Tempo de resposta\n            response_time_ms = (time.time() - start_time) * 1000\n            \n            # Dados de sa√∫de\n            health_data = {\n                'timestamp': datetime.now().isoformat(),\n                'status': 'healthy',\n                'response_time_ms': round(response_time_ms, 2),\n                'database_size_mb': round(db_size_mb, 2),\n                'user_count': user_count,\n                'chamado_count': chamado_count,\n                'integrity': integrity,\n                'warnings': []\n            }\n            \n            # Verificar alertas\n            if db_size_mb > self.alert_config['db_size_threshold_mb']:\n                health_data['warnings'].append(f\"Banco de dados grande: {db_size_mb:.1f}MB\")\n            \n            if response_time_ms > self.alert_config['db_response_time_ms']:\n                health_data['warnings'].append(f\"Resposta lenta: {response_time_ms:.1f}ms\")\n            \n            if integrity != \"ok\":\n                health_data['status'] = 'critical'\n                health_data['warnings'].append(f\"Integridade comprometida: {integrity}\")\n            \n            return health_data\n            \n        except Exception as e:\n            return {\n                'timestamp': datetime.now().isoformat(),\n                'status': 'error',\n                'error': str(e),\n                'warnings': ['Falha na conex√£o com banco de dados']\n            }\n    \n    def check_system_resources(self):\n        \"\"\"Verifica recursos do sistema\"\"\"\n        try:\n            # CPU\n            cpu_percent = psutil.cpu_percent(interval=1)\n            \n            # Mem√≥ria\n            memory = psutil.virtual_memory()\n            memory_percent = memory.percent\n            \n            # Disco\n            disk = psutil.disk_usage('/')\n            disk_percent = disk.percent\n            \n            # Processo atual\n            process = psutil.Process()\n            process_memory = process.memory_info().rss / 1024 / 1024  # MB\n            \n            resource_data = {\n                'timestamp': datetime.now().isoformat(),\n                'cpu_percent': round(cpu_percent, 1),\n                'memory_percent': round(memory_percent, 1),\n                'disk_percent': round(disk_percent, 1),\n                'process_memory_mb': round(process_memory, 1),\n                'warnings': []\n            }\n            \n            # Verificar alertas\n            if cpu_percent > self.alert_config['cpu_threshold']:\n                resource_data['warnings'].append(f\"CPU alta: {cpu_percent}%\")\n            \n            if memory_percent > self.alert_config['memory_threshold']:\n                resource_data['warnings'].append(f\"Mem√≥ria alta: {memory_percent}%\")\n            \n            if disk_percent > self.alert_config['disk_threshold']:\n                resource_data['warnings'].append(f\"Disco cheio: {disk_percent}%\")\n            \n            return resource_data\n            \n        except Exception as e:\n            return {\n                'timestamp': datetime.now().isoformat(),\n                'error': str(e),\n                'warnings': ['Falha na coleta de recursos do sistema']\n            }\n    \n    def check_application_health(self):\n        \"\"\"Verifica sa√∫de da aplica√ß√£o\"\"\"\n        try:\n            # Verificar arquivos cr√≠ticos\n            critical_files = [\n                'app.py', 'models.py', 'sistema_os.db',\n                'backup_manager.py', 'database_safety.py'\n            ]\n            \n            missing_files = []\n            for file_name in critical_files:\n                if not Path(file_name).exists():\n                    missing_files.append(file_name)\n            \n            # Verificar logs de erro recentes\n            error_count = 0\n            if Path('app.log').exists():\n                try:\n                    with open('app.log', 'r') as f:\n                        recent_logs = f.readlines()[-100:]  # √öltimas 100 linhas\n                        error_count = sum(1 for line in recent_logs if 'ERROR' in line)\n                except:\n                    pass\n            \n            app_data = {\n                'timestamp': datetime.now().isoformat(),\n                'status': 'healthy',\n                'missing_files': missing_files,\n                'recent_errors': error_count,\n                'warnings': []\n            }\n            \n            if missing_files:\n                app_data['status'] = 'warning'\n                app_data['warnings'].append(f\"Arquivos ausentes: {', '.join(missing_files)}\")\n            \n            if error_count > 10:\n                app_data['warnings'].append(f\"Muitos erros recentes: {error_count}\")\n            \n            return app_data\n            \n        except Exception as e:\n            return {\n                'timestamp': datetime.now().isoformat(),\n                'status': 'error',\n                'error': str(e),\n                'warnings': ['Falha na verifica√ß√£o da aplica√ß√£o']\n            }\n    \n    def send_alert(self, alert_data):\n        \"\"\"Envia alerta (log + poss√≠vel email)\"\"\"\n        try:\n            alert = {\n                'timestamp': datetime.now().isoformat(),\n                'type': alert_data.get('type', 'unknown'),\n                'severity': alert_data.get('severity', 'warning'),\n                'message': alert_data.get('message', ''),\n                'details': alert_data.get('details', {})\n            }\n            \n            # Adicionar ao log de alertas\n            self.alerts_log.append(alert)\n            \n            # Manter apenas √∫ltimos 1000 alertas\n            if len(self.alerts_log) > 1000:\n                self.alerts_log = self.alerts_log[-1000:]\n            \n            # Log do alerta\n            severity_level = {\n                'info': logging.INFO,\n                'warning': logging.WARNING,\n                'critical': logging.ERROR\n            }.get(alert['severity'], logging.WARNING)\n            \n            self.logger.log(severity_level, f\"üö® ALERTA {alert['type']}: {alert['message']}\")\n            \n            # Email/SMS poderia ser implementado aqui\n            # self.send_email_alert(alert)\n            \n            return True\n            \n        except Exception as e:\n            self.logger.error(f\"‚ùå Erro ao enviar alerta: {e}\")\n            return False\n    \n    def perform_monitoring_cycle(self):\n        \"\"\"Executa um ciclo completo de monitoramento\"\"\"\n        try:\n            cycle_data = {\n                'timestamp': datetime.now().isoformat(),\n                'database': self.check_database_health(),\n                'system': self.check_system_resources(),\n                'application': self.check_application_health()\n            }\n            \n            # Adicionar aos dados de monitoramento\n            self.monitoring_data.append(cycle_data)\n            \n            # Manter apenas √∫ltimas 24 horas de dados (assumindo check a cada minuto)\n            max_data_points = 24 * 60\n            if len(self.monitoring_data) > max_data_points:\n                self.monitoring_data = self.monitoring_data[-max_data_points:]\n            \n            # Verificar e enviar alertas\n            all_warnings = []\n            all_warnings.extend(cycle_data['database'].get('warnings', []))\n            all_warnings.extend(cycle_data['system'].get('warnings', []))\n            all_warnings.extend(cycle_data['application'].get('warnings', []))\n            \n            # Enviar alertas se necess√°rio\n            for warning in all_warnings:\n                self.send_alert({\n                    'type': 'system_warning',\n                    'severity': 'warning',\n                    'message': warning,\n                    'details': cycle_data\n                })\n            \n            # Verificar status cr√≠tico\n            critical_status = [\n                cycle_data['database'].get('status') == 'critical',\n                cycle_data['database'].get('status') == 'error',\n                cycle_data['application'].get('status') == 'error'\n            ]\n            \n            if any(critical_status):\n                self.send_alert({\n                    'type': 'system_critical',\n                    'severity': 'critical',\n                    'message': 'Sistema em estado cr√≠tico',\n                    'details': cycle_data\n                })\n            \n            return cycle_data\n            \n        except Exception as e:\n            self.logger.error(f\"‚ùå Erro no ciclo de monitoramento: {e}\")\n            return None\n    \n    def get_monitoring_summary(self, hours=24):\n        \"\"\"Retorna resumo do monitoramento das √∫ltimas N horas\"\"\"\n        try:\n            cutoff_time = datetime.now() - timedelta(hours=hours)\n            \n            # Filtrar dados recentes\n            recent_data = [\n                data for data in self.monitoring_data\n                if datetime.fromisoformat(data['timestamp']) > cutoff_time\n            ]\n            \n            if not recent_data:\n                return {'error': 'Nenhum dado de monitoramento dispon√≠vel'}\n            \n            # Calcular estat√≠sticas\n            db_response_times = [d['database'].get('response_time_ms', 0) for d in recent_data]\n            cpu_usage = [d['system'].get('cpu_percent', 0) for d in recent_data]\n            memory_usage = [d['system'].get('memory_percent', 0) for d in recent_data]\n            \n            # Contar alertas\n            recent_alerts = [\n                alert for alert in self.alerts_log\n                if datetime.fromisoformat(alert['timestamp']) > cutoff_time\n            ]\n            \n            summary = {\n                'period_hours': hours,\n                'data_points': len(recent_data),\n                'database_performance': {\n                    'avg_response_time_ms': round(sum(db_response_times) / len(db_response_times), 2),\n                    'max_response_time_ms': round(max(db_response_times), 2)\n                },\n                'system_performance': {\n                    'avg_cpu_percent': round(sum(cpu_usage) / len(cpu_usage), 1),\n                    'max_cpu_percent': round(max(cpu_usage), 1),\n                    'avg_memory_percent': round(sum(memory_usage) / len(memory_usage), 1),\n                    'max_memory_percent': round(max(memory_usage), 1)\n                },\n                'alerts': {\n                    'total_alerts': len(recent_alerts),\n                    'critical_alerts': len([a for a in recent_alerts if a['severity'] == 'critical']),\n                    'warning_alerts': len([a for a in recent_alerts if a['severity'] == 'warning'])\n                },\n                'last_check': recent_data[-1]['timestamp'] if recent_data else None\n            }\n            \n            return summary\n            \n        except Exception as e:\n            self.logger.error(f\"‚ùå Erro no resumo: {e}\")\n            return {'error': str(e)}\n    \n    def start_monitoring(self):\n        \"\"\"Inicia monitoramento cont√≠nuo\"\"\"\n        self.monitoring_active = True\n        \n        def monitoring_worker():\n            while self.monitoring_active:\n                self.perform_monitoring_cycle()\n                time.sleep(self.alert_config['check_interval_seconds'])\n        \n        thread = threading.Thread(target=monitoring_worker, daemon=True)\n        thread.start()\n        \n        self.logger.info(\"üîç Monitoramento 24/7 iniciado\")\n        self.send_alert({\n            'type': 'system_info',\n            'severity': 'info',\n            'message': 'Sistema de monitoramento iniciado',\n            'details': {'interval_seconds': self.alert_config['check_interval_seconds']}\n        })\n    \n    def stop_monitoring(self):\n        \"\"\"Para monitoramento\"\"\"\n        self.monitoring_active = False\n        self.logger.info(\"üõë Monitoramento parado\")\n\nif __name__ == \"__main__\":\n    # Teste do sistema de monitoramento\n    monitor = MonitoringSystem()\n    \n    print(\"üîç Executando verifica√ß√£o de teste...\")\n    cycle_data = monitor.perform_monitoring_cycle()\n    \n    if cycle_data:\n        print(\"üìä Status atual:\")\n        print(f\"  Database: {cycle_data['database']['status']}\")\n        print(f\"  System CPU: {cycle_data['system']['cpu_percent']}%\")\n        print(f\"  System Memory: {cycle_data['system']['memory_percent']}%\")\n        print(f\"  Response Time: {cycle_data['database']['response_time_ms']}ms\")\n    else:\n        print(\"‚ùå Falha na verifica√ß√£o\")","size_bytes":15005},"production_manager.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nGerenciador de Produ√ß√£o - Sistema Olivion\nSistema integrado para prepara√ß√£o e gerenciamento de produ√ß√£o\n\"\"\"\n\nimport os\nimport logging\nfrom datetime import datetime\nfrom pathlib import Path\n\n# Importar todos os sistemas\ntry:\n    from postgresql_migration import PostgreSQLMigrator\n    from cloud_backup_manager import CloudBackupManager\n    from monitoring_system import MonitoringSystem\n    from maintenance_scheduler import MaintenanceScheduler\n    from backup_manager import BackupManager\n    from database_safety import DatabaseSafety\nexcept ImportError as e:\n    print(f\"‚ö†Ô∏è Alguns sistemas n√£o dispon√≠veis: {e}\")\n\nclass ProductionManager:\n    \"\"\"Gerenciador integrado para ambiente de produ√ß√£o\"\"\"\n    \n    def __init__(self, db_path=\"sistema_os.db\"):\n        self.db_path = db_path\n        self.logger = logging.getLogger(__name__)\n        \n        # Inicializar todos os sistemas\n        self.migrator = PostgreSQLMigrator(db_path) if 'PostgreSQLMigrator' in locals() else None\n        self.cloud_backup = CloudBackupManager(db_path) if 'CloudBackupManager' in locals() else None\n        self.monitoring = MonitoringSystem(db_path) if 'MonitoringSystem' in locals() else None\n        self.scheduler = MaintenanceScheduler(db_path) if 'MaintenanceScheduler' in locals() else None\n        self.backup_manager = BackupManager(db_path) if 'BackupManager' in locals() else None\n        self.db_safety = DatabaseSafety(db_path) if 'DatabaseSafety' in locals() else None\n        \n        # Configurar logging\n        logging.basicConfig(\n            level=logging.INFO,\n            format='%(asctime)s - PRODUCTION - %(levelname)s - %(message)s'\n        )\n    \n    def check_production_readiness(self):\n        \"\"\"Verifica se sistema est√° pronto para produ√ß√£o\"\"\"\n        self.logger.info(\"üîç Verificando prontid√£o para produ√ß√£o...\")\n        \n        checks = {\n            'database_integrity': False,\n            'backup_system': False,\n            'monitoring_system': False,\n            'maintenance_scheduler': False,\n            'security_settings': False\n        }\n        \n        issues = []\n        \n        # 1. Verificar integridade do banco\n        try:\n            if self.db_safety:\n                is_healthy, _ = self.db_safety.check_database_integrity()\n                checks['database_integrity'] = is_healthy\n                if not is_healthy:\n                    issues.append(\"Problemas de integridade no banco de dados\")\n        except Exception as e:\n            issues.append(f\"Erro na verifica√ß√£o de integridade: {e}\")\n        \n        # 2. Verificar sistema de backup\n        try:\n            if self.backup_manager:\n                backup_path = self.backup_manager.create_backup(\"readiness_check\")\n                checks['backup_system'] = backup_path is not None\n                if not backup_path:\n                    issues.append(\"Sistema de backup n√£o funcional\")\n        except Exception as e:\n            issues.append(f\"Erro no sistema de backup: {e}\")\n        \n        # 3. Verificar monitoramento\n        try:\n            if self.monitoring:\n                cycle_data = self.monitoring.perform_monitoring_cycle()\n                checks['monitoring_system'] = cycle_data is not None\n                if not cycle_data:\n                    issues.append(\"Sistema de monitoramento n√£o funcional\")\n        except Exception as e:\n            issues.append(f\"Erro no sistema de monitoramento: {e}\")\n        \n        # 4. Verificar scheduler de manuten√ß√£o\n        try:\n            if self.scheduler:\n                status = self.scheduler.get_maintenance_status()\n                checks['maintenance_scheduler'] = status is not None\n                if not status:\n                    issues.append(\"Agendador de manuten√ß√£o n√£o funcional\")\n        except Exception as e:\n            issues.append(f\"Erro no agendador de manuten√ß√£o: {e}\")\n        \n        # 5. Verificar configura√ß√µes de seguran√ßa\n        try:\n            import sqlite3\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute(\"PRAGMA foreign_keys\")\n            fk_enabled = cursor.fetchone()[0]\n            \n            cursor.execute(\"PRAGMA journal_mode\")\n            journal_mode = cursor.fetchone()[0]\n            \n            cursor.execute(\"PRAGMA synchronous\")\n            sync_mode = cursor.fetchone()[0]\n            \n            conn.close()\n            \n            # Verificar configura√ß√µes seguras\n            secure_config = (fk_enabled == 1 and \n                           journal_mode == 'wal' and \n                           sync_mode >= 2)\n            \n            checks['security_settings'] = secure_config\n            if not secure_config:\n                issues.append(f\"Configura√ß√µes inseguras: FK={fk_enabled}, WAL={journal_mode}, SYNC={sync_mode}\")\n        \n        except Exception as e:\n            issues.append(f\"Erro na verifica√ß√£o de seguran√ßa: {e}\")\n        \n        # Calcular score de prontid√£o\n        readiness_score = sum(checks.values()) / len(checks) * 100\n        \n        result = {\n            'ready_for_production': readiness_score >= 80,\n            'readiness_score': round(readiness_score, 1),\n            'checks_passed': checks,\n            'issues': issues,\n            'timestamp': datetime.now().isoformat()\n        }\n        \n        if result['ready_for_production']:\n            self.logger.info(f\"‚úÖ Sistema PRONTO para produ√ß√£o (Score: {readiness_score}%)\")\n        else:\n            self.logger.warning(f\"‚ö†Ô∏è Sistema N√ÉO pronto para produ√ß√£o (Score: {readiness_score}%)\")\n            for issue in issues:\n                self.logger.warning(f\"  - {issue}\")\n        \n        return result\n    \n    def prepare_for_production(self):\n        \"\"\"Prepara sistema para ambiente de produ√ß√£o\"\"\"\n        self.logger.info(\"üöÄ Preparando sistema para produ√ß√£o...\")\n        \n        preparation_steps = []\n        \n        # 1. Criar backup pr√©-produ√ß√£o\n        try:\n            if self.backup_manager:\n                backup_path = self.backup_manager.create_backup(\"pre_production\")\n                if backup_path:\n                    preparation_steps.append((\"Backup pr√©-produ√ß√£o\", \"SUCESSO\", str(backup_path)))\n                else:\n                    preparation_steps.append((\"Backup pr√©-produ√ß√£o\", \"FALHA\", \"N√£o foi poss√≠vel criar backup\"))\n        except Exception as e:\n            preparation_steps.append((\"Backup pr√©-produ√ß√£o\", \"ERRO\", str(e)))\n        \n        # 2. Configurar sistemas de seguran√ßa\n        try:\n            if self.db_safety:\n                # Aplicar configura√ß√µes de seguran√ßa\n                import sqlite3\n                conn = sqlite3.connect(self.db_path)\n                cursor = conn.cursor()\n                \n                cursor.execute(\"PRAGMA foreign_keys = ON\")\n                cursor.execute(\"PRAGMA journal_mode = WAL\")\n                cursor.execute(\"PRAGMA synchronous = FULL\")\n                cursor.execute(\"PRAGMA temp_store = MEMORY\")\n                cursor.execute(\"PRAGMA cache_size = 10000\")\n                \n                conn.close()\n                preparation_steps.append((\"Configura√ß√µes de seguran√ßa\", \"SUCESSO\", \"Aplicadas\"))\n        except Exception as e:\n            preparation_steps.append((\"Configura√ß√µes de seguran√ßa\", \"ERRO\", str(e)))\n        \n        # 3. Iniciar monitoramento\n        try:\n            if self.monitoring and not self.monitoring.monitoring_active:\n                self.monitoring.start_monitoring()\n                preparation_steps.append((\"Monitoramento 24/7\", \"SUCESSO\", \"Iniciado\"))\n        except Exception as e:\n            preparation_steps.append((\"Monitoramento 24/7\", \"ERRO\", str(e)))\n        \n        # 4. Configurar manuten√ß√£o autom√°tica\n        try:\n            if self.scheduler and not self.scheduler.maintenance_active:\n                self.scheduler.start_scheduler()\n                preparation_steps.append((\"Manuten√ß√£o autom√°tica\", \"SUCESSO\", \"Agendada\"))\n        except Exception as e:\n            preparation_steps.append((\"Manuten√ß√£o autom√°tica\", \"ERRO\", str(e)))\n        \n        # 5. Configurar backups na nuvem\n        try:\n            if self.cloud_backup:\n                self.cloud_backup.start_automatic_backups(interval_hours=6)\n                preparation_steps.append((\"Backup na nuvem\", \"SUCESSO\", \"Ativo a cada 6h\"))\n        except Exception as e:\n            preparation_steps.append((\"Backup na nuvem\", \"ERRO\", str(e)))\n        \n        # Verificar resultados\n        successful_steps = sum(1 for step in preparation_steps if step[1] == \"SUCESSO\")\n        total_steps = len(preparation_steps)\n        success_rate = successful_steps / total_steps * 100\n        \n        result = {\n            'preparation_successful': success_rate >= 80,\n            'success_rate': round(success_rate, 1),\n            'steps_completed': preparation_steps,\n            'timestamp': datetime.now().isoformat()\n        }\n        \n        if result['preparation_successful']:\n            self.logger.info(f\"‚úÖ Prepara√ß√£o conclu√≠da com sucesso ({success_rate}%)\")\n        else:\n            self.logger.warning(f\"‚ö†Ô∏è Prepara√ß√£o incompleta ({success_rate}%)\")\n        \n        return result\n    \n    def migrate_to_postgresql(self):\n        \"\"\"Migra para PostgreSQL se dispon√≠vel\"\"\"\n        try:\n            if not self.migrator:\n                return {\n                    'migration_successful': False,\n                    'reason': 'Sistema de migra√ß√£o n√£o dispon√≠vel',\n                    'timestamp': datetime.now().isoformat()\n                }\n            \n            self.logger.info(\"üì¶ Iniciando migra√ß√£o para PostgreSQL...\")\n            \n            # Verificar disponibilidade PostgreSQL\n            available, missing = self.migrator.check_postgresql_availability()\n            \n            if not available:\n                return {\n                    'migration_successful': False,\n                    'reason': f'PostgreSQL n√£o configurado. Vari√°veis ausentes: {missing}',\n                    'timestamp': datetime.now().isoformat()\n                }\n            \n            # Executar migra√ß√£o\n            success = self.migrator.full_migration()\n            \n            result = {\n                'migration_successful': success,\n                'reason': 'Migra√ß√£o conclu√≠da' if success else 'Falha na migra√ß√£o',\n                'timestamp': datetime.now().isoformat()\n            }\n            \n            if success:\n                self.logger.info(\"‚úÖ Migra√ß√£o PostgreSQL conclu√≠da\")\n            else:\n                self.logger.error(\"‚ùå Falha na migra√ß√£o PostgreSQL\")\n            \n            return result\n            \n        except Exception as e:\n            self.logger.error(f\"‚ùå Erro na migra√ß√£o: {e}\")\n            return {\n                'migration_successful': False,\n                'reason': f'Erro: {e}',\n                'timestamp': datetime.now().isoformat()\n            }\n    \n    def get_production_status(self):\n        \"\"\"Retorna status completo do sistema de produ√ß√£o\"\"\"\n        try:\n            status = {\n                'timestamp': datetime.now().isoformat(),\n                'systems': {}\n            }\n            \n            # Status de cada sistema\n            if self.monitoring:\n                summary = self.monitoring.get_monitoring_summary(1)  # √öltima hora\n                status['systems']['monitoring'] = {\n                    'active': self.monitoring.monitoring_active,\n                    'last_check': summary.get('last_check'),\n                    'alerts': summary.get('alerts', {})\n                }\n            \n            if self.scheduler:\n                maint_status = self.scheduler.get_maintenance_status()\n                status['systems']['maintenance'] = {\n                    'active': maint_status.get('scheduler_active', False),\n                    'tasks_executed': maint_status.get('total_tasks_executed', 0),\n                    'next_scheduled': maint_status.get('next_scheduled', {})\n                }\n            \n            if self.cloud_backup:\n                backup_stats = self.cloud_backup.get_backup_statistics()\n                status['systems']['cloud_backup'] = {\n                    'active': True,\n                    'statistics': backup_stats\n                }\n            \n            # Verifica√ß√£o de prontid√£o\n            readiness = self.check_production_readiness()\n            status['readiness'] = readiness\n            \n            return status\n            \n        except Exception as e:\n            self.logger.error(f\"‚ùå Erro ao obter status: {e}\")\n            return {\n                'timestamp': datetime.now().isoformat(),\n                'error': str(e)\n            }\n\nif __name__ == \"__main__\":\n    # Teste do gerenciador de produ√ß√£o\n    manager = ProductionManager()\n    \n    print(\"üîç Verificando prontid√£o para produ√ß√£o...\")\n    readiness = manager.check_production_readiness()\n    \n    print(f\"üìä Score de prontid√£o: {readiness['readiness_score']}%\")\n    print(f\"‚úÖ Pronto para produ√ß√£o: {'SIM' if readiness['ready_for_production'] else 'N√ÉO'}\")\n    \n    if readiness['issues']:\n        print(\"‚ö†Ô∏è Problemas encontrados:\")\n        for issue in readiness['issues']:\n            print(f\"  - {issue}\")\n    \n    if readiness['ready_for_production']:\n        print(\"\\nüöÄ Preparando para produ√ß√£o...\")\n        preparation = manager.prepare_for_production()\n        print(f\"‚úÖ Prepara√ß√£o: {preparation['success_rate']}% conclu√≠da\")","size_bytes":13664},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"cryptography>=46.0.1\",\n    \"eventlet>=0.40.3\",\n    \"flask>=3.1.2\",\n    \"flask-socketio>=5.5.1\",\n    \"flask-sqlalchemy>=3.1.1\",\n    \"matplotlib>=3.10.6\",\n    \"openpyxl>=3.1.5\",\n    \"pandas>=2.3.2\",\n    \"psutil>=7.1.0\",\n    \"pyopenssl>=25.3.0\",\n    \"python-dotenv>=1.1.1\",\n    \"pytz>=2025.2\",\n    \"reportlab>=4.4.4\",\n    \"requests>=2.32.5\",\n    \"schedule>=1.2.2\",\n    \"sqlalchemy>=2.0.43\",\n    \"werkzeug>=3.1.3\",\n    \"xlsxwriter>=3.2.9\",\n]\n","size_bytes":585},"replication_manager.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nSistema de Replica√ß√£o - Sistema Olivion\nSistema simples de alta disponibilidade e replica√ß√£o de dados\n\"\"\"\n\nimport os\nimport sqlite3\nimport shutil\nimport threading\nimport time\nimport logging\nimport json\nfrom datetime import datetime, timedelta\nfrom pathlib import Path\n\nclass ReplicationManager:\n    \"\"\"Gerenciador de replica√ß√£o e alta disponibilidade\"\"\"\n    \n    def __init__(self, primary_db=\"sistema_os.db\", replica_dir=\"replicas\"):\n        self.primary_db = primary_db\n        self.replica_dir = Path(replica_dir)\n        self.replica_dir.mkdir(exist_ok=True)\n        \n        self.replication_active = False\n        self.replication_log = []\n        \n        # Configura√ß√µes de replica√ß√£o\n        self.config = {\n            'replication_interval_seconds': 300,  # 5 minutos\n            'max_replicas': 3,                    # M√°ximo 3 r√©plicas\n            'max_lag_seconds': 600,               # M√°ximo 10 min de atraso\n            'verification_enabled': True          # Verificar integridade\n        }\n        \n        # Configurar logging\n        logging.basicConfig(\n            level=logging.INFO,\n            format='%(asctime)s - REPLICATION - %(levelname)s - %(message)s'\n        )\n        self.logger = logging.getLogger(__name__)\n    \n    def log_replication_event(self, event_type, status, details=None):\n        \"\"\"Registra evento de replica√ß√£o\"\"\"\n        log_entry = {\n            'timestamp': datetime.now().isoformat(),\n            'event_type': event_type,\n            'status': status,\n            'details': details or {}\n        }\n        \n        self.replication_log.append(log_entry)\n        \n        # Manter apenas √∫ltimos 1000 eventos\n        if len(self.replication_log) > 1000:\n            self.replication_log = self.replication_log[-1000:]\n        \n        self.logger.info(f\"üîÑ {event_type}: {status}\")\n    \n    def get_database_checksum(self, db_path):\n        \"\"\"Calcula checksum do banco de dados\"\"\"\n        try:\n            conn = sqlite3.connect(db_path)\n            cursor = conn.cursor()\n            \n            # Contar registros e calcular hash simples\n            cursor.execute(\"SELECT COUNT(*) FROM user\")\n            user_count = cursor.fetchone()[0]\n            \n            cursor.execute(\"SELECT COUNT(*) FROM chamado\") \n            chamado_count = cursor.fetchone()[0]\n            \n            # √öltima modifica√ß√£o de chamados\n            cursor.execute(\"SELECT MAX(criado_em) FROM chamado\")\n            last_update = cursor.fetchone()[0] or \"\"\n            \n            conn.close()\n            \n            # Checksum simples baseado em contadores e timestamp\n            checksum = f\"{user_count}:{chamado_count}:{last_update}\"\n            return checksum\n            \n        except Exception as e:\n            self.logger.error(f\"‚ùå Erro ao calcular checksum: {e}\")\n            return None\n    \n    def create_replica(self, replica_name=None):\n        \"\"\"Cria r√©plica do banco principal\"\"\"\n        try:\n            if not replica_name:\n                timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n                replica_name = f\"replica_{timestamp}.db\"\n            \n            replica_path = self.replica_dir / replica_name\n            \n            # Verificar se banco principal existe\n            if not Path(self.primary_db).exists():\n                self.log_replication_event(\"Criar R√©plica\", \"FALHA\", {\"reason\": \"Banco principal n√£o encontrado\"})\n                return None\n            \n            # Criar c√≥pia do banco principal\n            shutil.copy2(self.primary_db, replica_path)\n            \n            # Verificar integridade da r√©plica\n            if self.config['verification_enabled']:\n                primary_checksum = self.get_database_checksum(self.primary_db)\n                replica_checksum = self.get_database_checksum(replica_path)\n                \n                if primary_checksum != replica_checksum:\n                    replica_path.unlink()  # Remover r√©plica inv√°lida\n                    self.log_replication_event(\"Criar R√©plica\", \"FALHA\", {\n                        \"reason\": \"Checksum inv√°lido\",\n                        \"primary\": primary_checksum,\n                        \"replica\": replica_checksum\n                    })\n                    return None\n            \n            # Adicionar metadados da r√©plica\n            metadata = {\n                'created_at': datetime.now().isoformat(),\n                'primary_db': self.primary_db,\n                'primary_checksum': self.get_database_checksum(self.primary_db),\n                'replica_size': replica_path.stat().st_size\n            }\n            \n            metadata_path = replica_path.with_suffix('.meta.json')\n            with open(metadata_path, 'w') as f:\n                json.dump(metadata, f, indent=2)\n            \n            self.log_replication_event(\"Criar R√©plica\", \"SUCESSO\", {\n                \"replica_name\": replica_name,\n                \"size_bytes\": replica_path.stat().st_size\n            })\n            \n            return replica_path\n            \n        except Exception as e:\n            self.log_replication_event(\"Criar R√©plica\", \"ERRO\", {\"error\": str(e)})\n            return None\n    \n    def update_replicas(self):\n        \"\"\"Atualiza todas as r√©plicas existentes\"\"\"\n        try:\n            replicas = list(self.replica_dir.glob(\"replica_*.db\"))\n            \n            if not replicas:\n                self.log_replication_event(\"Atualizar R√©plicas\", \"NADA_PARA_FAZER\", {\"reason\": \"Nenhuma r√©plica encontrada\"})\n                return True\n            \n            primary_checksum = self.get_database_checksum(self.primary_db)\n            if not primary_checksum:\n                self.log_replication_event(\"Atualizar R√©plicas\", \"FALHA\", {\"reason\": \"Erro no banco principal\"})\n                return False\n            \n            updated_count = 0\n            failed_count = 0\n            \n            for replica_path in replicas:\n                try:\n                    # Verificar se r√©plica precisa ser atualizada\n                    replica_checksum = self.get_database_checksum(replica_path)\n                    \n                    if replica_checksum == primary_checksum:\n                        continue  # R√©plica j√° est√° atualizada\n                    \n                    # Atualizar r√©plica\n                    shutil.copy2(self.primary_db, replica_path)\n                    \n                    # Verificar atualiza√ß√£o\n                    new_checksum = self.get_database_checksum(replica_path)\n                    if new_checksum == primary_checksum:\n                        # Atualizar metadados\n                        metadata_path = replica_path.with_suffix('.meta.json')\n                        if metadata_path.exists():\n                            with open(metadata_path, 'r') as f:\n                                metadata = json.load(f)\n                            \n                            metadata['last_updated'] = datetime.now().isoformat()\n                            metadata['primary_checksum'] = primary_checksum\n                            \n                            with open(metadata_path, 'w') as f:\n                                json.dump(metadata, f, indent=2)\n                        \n                        updated_count += 1\n                    else:\n                        failed_count += 1\n                        \n                except Exception as e:\n                    self.logger.error(f\"‚ùå Erro ao atualizar r√©plica {replica_path.name}: {e}\")\n                    failed_count += 1\n            \n            if failed_count == 0:\n                self.log_replication_event(\"Atualizar R√©plicas\", \"SUCESSO\", {\n                    \"atualizadas\": updated_count,\n                    \"total\": len(replicas)\n                })\n                return True\n            else:\n                self.log_replication_event(\"Atualizar R√©plicas\", \"PARCIAL\", {\n                    \"atualizadas\": updated_count,\n                    \"falharam\": failed_count,\n                    \"total\": len(replicas)\n                })\n                return False\n                \n        except Exception as e:\n            self.log_replication_event(\"Atualizar R√©plicas\", \"ERRO\", {\"error\": str(e)})\n            return False\n    \n    def cleanup_old_replicas(self, max_age_hours=24):\n        \"\"\"Remove r√©plicas antigas\"\"\"\n        try:\n            cutoff_time = time.time() - (max_age_hours * 3600)\n            replicas = list(self.replica_dir.glob(\"replica_*.db\"))\n            \n            # Manter pelo menos 1 r√©plica\n            if len(replicas) <= 1:\n                return True\n            \n            # Ordenar por data de modifica√ß√£o (mais recente primeiro)\n            replicas.sort(key=lambda x: x.stat().st_mtime, reverse=True)\n            \n            removed_count = 0\n            \n            # Manter as N r√©plicas mais recentes e remover antigas\n            for replica in replicas[self.config['max_replicas']:]:\n                try:\n                    replica.unlink()\n                    # Remover metadados tamb√©m\n                    metadata_path = replica.with_suffix('.meta.json')\n                    if metadata_path.exists():\n                        metadata_path.unlink()\n                    \n                    removed_count += 1\n                    \n                except Exception as e:\n                    self.logger.error(f\"‚ùå Erro ao remover r√©plica {replica.name}: {e}\")\n            \n            # Remover r√©plicas muito antigas\n            for replica in replicas[:self.config['max_replicas']]:\n                if replica.stat().st_mtime < cutoff_time:\n                    try:\n                        replica.unlink()\n                        metadata_path = replica.with_suffix('.meta.json')\n                        if metadata_path.exists():\n                            metadata_path.unlink()\n                        \n                        removed_count += 1\n                        \n                    except Exception as e:\n                        self.logger.error(f\"‚ùå Erro ao remover r√©plica antiga {replica.name}: {e}\")\n            \n            if removed_count > 0:\n                self.log_replication_event(\"Limpeza de R√©plicas\", \"SUCESSO\", {\n                    \"removidas\": removed_count,\n                    \"max_age_hours\": max_age_hours\n                })\n            else:\n                self.log_replication_event(\"Limpeza de R√©plicas\", \"NADA_PARA_FAZER\")\n            \n            return True\n            \n        except Exception as e:\n            self.log_replication_event(\"Limpeza de R√©plicas\", \"ERRO\", {\"error\": str(e)})\n            return False\n    \n    def verify_replica_integrity(self, replica_path):\n        \"\"\"Verifica integridade de uma r√©plica\"\"\"\n        try:\n            primary_checksum = self.get_database_checksum(self.primary_db)\n            replica_checksum = self.get_database_checksum(replica_path)\n            \n            is_valid = primary_checksum == replica_checksum\n            \n            return {\n                'valid': is_valid,\n                'primary_checksum': primary_checksum,\n                'replica_checksum': replica_checksum,\n                'replica_path': str(replica_path)\n            }\n            \n        except Exception as e:\n            return {\n                'valid': False,\n                'error': str(e),\n                'replica_path': str(replica_path)\n            }\n    \n    def get_replication_status(self):\n        \"\"\"Retorna status do sistema de replica√ß√£o\"\"\"\n        try:\n            replicas = list(self.replica_dir.glob(\"replica_*.db\"))\n            \n            status = {\n                'replication_active': self.replication_active,\n                'primary_db': self.primary_db,\n                'primary_exists': Path(self.primary_db).exists(),\n                'replica_count': len(replicas),\n                'replicas': []\n            }\n            \n            # Informa√ß√µes de cada r√©plica\n            for replica in replicas:\n                replica_info = {\n                    'name': replica.name,\n                    'size_mb': round(replica.stat().st_size / 1024 / 1024, 2),\n                    'modified': datetime.fromtimestamp(replica.stat().st_mtime).isoformat(),\n                    'valid': None\n                }\n                \n                # Verificar integridade se solicitado\n                if self.config['verification_enabled']:\n                    integrity = self.verify_replica_integrity(replica)\n                    replica_info['valid'] = integrity['valid']\n                \n                status['replicas'].append(replica_info)\n            \n            # Estat√≠sticas de replica√ß√£o\n            recent_events = [\n                event for event in self.replication_log\n                if datetime.fromisoformat(event['timestamp']) > datetime.now() - timedelta(hours=24)\n            ]\n            \n            status['recent_activity'] = {\n                'last_24h_events': len(recent_events),\n                'successful_replications': len([e for e in recent_events if e['status'] == 'SUCESSO']),\n                'failed_replications': len([e for e in recent_events if e['status'] in ['FALHA', 'ERRO']])\n            }\n            \n            return status\n            \n        except Exception as e:\n            return {\n                'error': str(e),\n                'timestamp': datetime.now().isoformat()\n            }\n    \n    def run_replication_cycle(self):\n        \"\"\"Executa um ciclo completo de replica√ß√£o\"\"\"\n        try:\n            self.logger.info(\"üîÑ Iniciando ciclo de replica√ß√£o...\")\n            \n            # 1. Verificar se h√° r√©plicas\n            replicas = list(self.replica_dir.glob(\"replica_*.db\"))\n            \n            if len(replicas) == 0:\n                # Criar primeira r√©plica\n                self.create_replica()\n            else:\n                # Atualizar r√©plicas existentes\n                self.update_replicas()\n            \n            # 2. Limpeza de r√©plicas antigas\n            self.cleanup_old_replicas()\n            \n            # 3. Criar nova r√©plica se necess√°rio\n            current_replicas = list(self.replica_dir.glob(\"replica_*.db\"))\n            if len(current_replicas) < self.config['max_replicas']:\n                self.create_replica()\n            \n            self.log_replication_event(\"Ciclo de Replica√ß√£o\", \"SUCESSO\", {\n                \"replicas_atuais\": len(current_replicas)\n            })\n            \n            return True\n            \n        except Exception as e:\n            self.log_replication_event(\"Ciclo de Replica√ß√£o\", \"ERRO\", {\"error\": str(e)})\n            return False\n    \n    def start_automatic_replication(self):\n        \"\"\"Inicia replica√ß√£o autom√°tica\"\"\"\n        self.replication_active = True\n        \n        def replication_worker():\n            while self.replication_active:\n                self.run_replication_cycle()\n                time.sleep(self.config['replication_interval_seconds'])\n        \n        thread = threading.Thread(target=replication_worker, daemon=True)\n        thread.start()\n        \n        self.log_replication_event(\"Sistema de Replica√ß√£o\", \"INICIADO\", {\n            \"interval_seconds\": self.config['replication_interval_seconds']\n        })\n    \n    def stop_automatic_replication(self):\n        \"\"\"Para replica√ß√£o autom√°tica\"\"\"\n        self.replication_active = False\n        self.log_replication_event(\"Sistema de Replica√ß√£o\", \"PARADO\")\n\nif __name__ == \"__main__\":\n    # Teste do sistema de replica√ß√£o\n    replication = ReplicationManager()\n    \n    print(\"üîÑ Executando teste de replica√ß√£o...\")\n    success = replication.run_replication_cycle()\n    \n    if success:\n        status = replication.get_replication_status()\n        print(f\"‚úÖ Replica√ß√£o executada com sucesso\")\n        print(f\"üìä R√©plicas ativas: {status['replica_count']}\")\n        print(f\"üíæ Banco principal: {status['primary_db']} ({'OK' if status['primary_exists'] else 'ERRO'})\")\n    else:\n        print(\"‚ùå Falha na replica√ß√£o\")","size_bytes":16163},"replit.md":{"content":"# Sistema HelpDesk 13 - Olivion\n\n## Vis√£o Geral\nSistema de gest√£o de chamados/tickets instalado com sucesso a partir do reposit√≥rio GitHub: https://github.com/diasjoao21dias-art/sistema-helpdesk13.git\n\n### Status Atual\n- ‚úÖ **Sistema funcionando** na porta 5000\n- ‚úÖ **Base de dados SQLite** inicializada e limpa\n- ‚úÖ **Todas as depend√™ncias Python** instaladas\n- ‚úÖ **Sistema de licenciamento** ativo\n- ‚úÖ **Workflow configurado** e rodando automaticamente\n- ‚úÖ **Scripts LIMPAR_BANCO.py e USAR.py executados** com sucesso\n\n## Informa√ß√µes de Acesso\n\n### Como Acessar\n- **URL**: https://[seu-repl-name].replit.app\n- **Porta local**: 5000\n- **Login padr√£o**: admin\n- **Senha padr√£o**: admin\n\n‚ö†Ô∏è **IMPORTANTE**: Altere a senha ap√≥s o primeiro login!\n\n## Funcionalidades Principais\n\n### ‚úÖ Gest√£o de Chamados/Tickets\n- Abertura de chamados por usu√°rios\n- Atribui√ß√£o por setores (T.I, Manuten√ß√£o, CCIH, Telefonia)\n- Controle de status e urg√™ncia\n- Upload de imagens (at√© 3 por chamado)\n- Hist√≥rico completo\n- Campo para ramal e CDC\n\n### ‚úÖ Sistema de Usu√°rios\n- 3 n√≠veis: Admin, Operador, Usu√°rio\n- Controle por setores\n- Autentica√ß√£o segura\n- Sistema de permiss√µes avan√ßado\n\n### ‚úÖ Relat√≥rios Avan√ßados\n- Gr√°ficos e estat√≠sticas\n- Exporta√ß√£o PDF e Excel\n- Filtros por per√≠odo, setor, status\n- An√°lise de performance\n\n### ‚úÖ Sistema de Licen√ßas Comercial\n- Licenciamento por hardware\n- Controle de 30 dias\n- 3 tipos de licen√ßa\n- Ativa√ß√£o remota\n\n## Configura√ß√£o do Projeto\n\n### Arquivos Principais\n- `app.py` - Aplica√ß√£o principal Flask\n- `USAR.py` - Script de inicializa√ß√£o\n- `models.py` - Modelos do banco de dados\n- `config.py` - Configura√ß√µes\n- `requirements.txt` - Depend√™ncias Python\n\n### M√≥dulos de Seguran√ßa\n- `backup_manager.py` - Gerenciamento de backups\n- `database_safety.py` - Seguran√ßa do banco\n- `activity_logger.py` - Log de atividades\n- `license_manager.py` - Sistema de licen√ßas\n\n### Estrutura de Pastas\n- `static/uploads/` ‚Üí Imagens dos chamados\n- `static/relatorios/` ‚Üí Relat√≥rios gerados\n- `templates/` ‚Üí Interfaces do usu√°rio\n- `instance/sistema_os.db` ‚Üí Banco de dados SQLite\n- `backups/` ‚Üí Backups autom√°ticos\n\n## Configura√ß√µes de Seguran√ßa\n\n### Primeiro Acesso\n1. Fa√ßa login com admin/admin\n2. V√° em Admin > Usu√°rios\n3. Altere a senha do admin\n4. Crie operadores e usu√°rios\n\n### Gerenciar Setores\n- T.I ‚Üí Problemas t√©cnicos\n- Manuten√ß√£o ‚Üí Manuten√ß√£o predial\n- CCIH / SESMT ‚Üí Seguran√ßa do trabalho\n- Telefonia ‚Üí Telecomunica√ß√µes\n\n## Modifica√ß√µes Recentes\n- **22/09/2025**: Nova instala√ß√£o do projeto sistema-helpdesk13\n  - Projeto clonado do GitHub: https://github.com/diasjoao21dias-art/sistema-helpdesk13.git\n  - Depend√™ncias Python instaladas via packager_tool (Flask, SQLAlchemy, SocketIO, etc.)\n  - Script LIMPAR_BANCO.py executado (banco limpo para nova m√°quina)\n  - Script USAR.py executado (sistema iniciado)\n  - Sistema configurado para Replit (porta 5000)\n  - Workflow \"Sistema HelpDesk\" criado e funcionando\n  - Banco de dados SQLite inicializado automaticamente\n\n## Logs e Monitoramento\n- Sistema de logs integrado e funcionando\n- Monitoramento em tempo real via SocketIO\n- Backup autom√°tico configurado\n- Auditoria de a√ß√µes de usu√°rios\n- Workflow: \"Sistema Helpdesk\" rodando na porta 5000\n\n## Pr√≥ximos Passos Recomendados\n1. ‚úÖ Alterar senha padr√£o do admin\n2. ‚úÖ Configurar usu√°rios e operadores\n3. ‚úÖ Testar funcionalidades principais\n4. ‚úÖ Configurar setores conforme necessidade\n5. ‚úÖ Revisar sistema de licenciamento\n\n## Comandos √öteis\n- **Iniciar**: O sistema inicia automaticamente via workflow\n- **Reiniciar**: Use o bot√£o de restart do workflow no Replit\n- **Logs**: Dispon√≠veis no painel de logs do Replit\n\n---\n*Sistema Olivion v2.0 - Instalado em 22/09/2025*\n\n## Prefer√™ncias do Usu√°rio\n- **Idioma**: Portugu√™s Brasileiro\n- **Ambiente**: Replit com SQLite\n- **Porta**: 5000 (padr√£o Replit)","size_bytes":3958},"validation_rules.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nRegras de Valida√ß√£o - Sistema Olivion\nValida√ß√µes robustas para prevenir dados inv√°lidos\n\"\"\"\n\nimport re\nfrom datetime import datetime\nfrom typing import Dict, List, Tuple, Optional\n\nclass ValidationRules:\n    \"\"\"Conjunto de regras de valida√ß√£o para dados cr√≠ticos\"\"\"\n    \n    @staticmethod\n    def validate_user_data(username: str, password: str, role: str, setor: str = None) -> Tuple[bool, List[str]]:\n        \"\"\"Valida dados de usu√°rio com regras de seguran√ßa\"\"\"\n        errors = []\n        \n        # Validar username\n        if not username or len(username.strip()) < 3:\n            errors.append(\"Username deve ter pelo menos 3 caracteres\")\n        elif len(username) > 50:\n            errors.append(\"Username n√£o pode ter mais de 50 caracteres\")\n        elif not re.match(r'^[a-zA-Z0-9_-]+$', username):\n            errors.append(\"Username s√≥ pode conter letras, n√∫meros, _ e -\")\n        \n        # Validar password\n        if password:  # S√≥ validar se senha foi fornecida\n            if len(password) < 6:\n                errors.append(\"Senha deve ter pelo menos 6 caracteres\")\n            elif len(password) > 128:\n                errors.append(\"Senha n√£o pode ter mais de 128 caracteres\")\n            elif not re.search(r'[A-Za-z]', password):\n                errors.append(\"Senha deve conter pelo menos uma letra\")\n            elif not re.search(r'[0-9]', password):\n                errors.append(\"Senha deve conter pelo menos um n√∫mero\")\n        \n        # Validar role\n        valid_roles = [\"admin\", \"operador\", \"usuario\"]\n        if role not in valid_roles:\n            errors.append(f\"Papel deve ser um de: {', '.join(valid_roles)}\")\n        \n        # Validar setor se necess√°rio\n        if role == \"operador\" and not setor:\n            errors.append(\"Operadores devem ter um setor definido\")\n        \n        return len(errors) == 0, errors\n    \n    @staticmethod\n    def validate_chamado_data(titulo: str, descricao: str, setor: str, \n                            prioridade: str = \"media\", usuario_id: int = None) -> Tuple[bool, List[str]]:\n        \"\"\"Valida dados de chamado com regras de neg√≥cio\"\"\"\n        errors = []\n        \n        # Validar t√≠tulo\n        if not titulo or len(titulo.strip()) < 5:\n            errors.append(\"T√≠tulo deve ter pelo menos 5 caracteres\")\n        elif len(titulo) > 200:\n            errors.append(\"T√≠tulo n√£o pode ter mais de 200 caracteres\")\n        \n        # Validar descri√ß√£o\n        if not descricao or len(descricao.strip()) < 10:\n            errors.append(\"Descri√ß√£o deve ter pelo menos 10 caracteres\")\n        elif len(descricao) > 2000:\n            errors.append(\"Descri√ß√£o n√£o pode ter mais de 2000 caracteres\")\n        \n        # Validar setor\n        valid_setores = [\"T.I\", \"Manuten√ß√£o\", \"CCIH / SESMT / Manuten√ß√£o de Ar condicionado\", \"Telefonia e outros servi√ßos\"]\n        if setor not in valid_setores:\n            errors.append(f\"Setor deve ser um de: {', '.join(valid_setores)}\")\n        \n        # Validar prioridade\n        valid_prioridades = [\"baixa\", \"media\", \"alta\", \"urgente\"]\n        if prioridade not in valid_prioridades:\n            errors.append(f\"Prioridade deve ser um de: {', '.join(valid_prioridades)}\")\n        \n        # Validar usu√°rio\n        if usuario_id is not None and usuario_id <= 0:\n            errors.append(\"ID de usu√°rio inv√°lido\")\n        \n        return len(errors) == 0, errors\n    \n    @staticmethod\n    def sanitize_input(data: str, max_length: int = 1000) -> str:\n        \"\"\"Sanitiza entrada removendo caracteres perigosos\"\"\"\n        if not data:\n            return \"\"\n        \n        # Remover caracteres de controle\n        sanitized = re.sub(r'[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]', '', str(data))\n        \n        # Truncar se necess√°rio\n        if len(sanitized) > max_length:\n            sanitized = sanitized[:max_length]\n        \n        # Remover espa√ßos extras\n        sanitized = re.sub(r'\\s+', ' ', sanitized.strip())\n        \n        return sanitized\n    \n    @staticmethod\n    def validate_file_upload(filename: str, file_size: int) -> Tuple[bool, List[str]]:\n        \"\"\"Valida upload de arquivo\"\"\"\n        errors = []\n        \n        if not filename:\n            errors.append(\"Nome do arquivo n√£o pode estar vazio\")\n            return False, errors\n        \n        # Validar extens√£o\n        allowed_extensions = {'png', 'jpg', 'jpeg', 'gif'}\n        if '.' not in filename:\n            errors.append(\"Arquivo deve ter uma extens√£o\")\n        else:\n            ext = filename.rsplit('.', 1)[1].lower()\n            if ext not in allowed_extensions:\n                errors.append(f\"Extens√µes permitidas: {', '.join(allowed_extensions)}\")\n        \n        # Validar tamanho (5MB m√°ximo)\n        max_size = 5 * 1024 * 1024\n        if file_size > max_size:\n            errors.append(f\"Arquivo muito grande. M√°ximo: {max_size/1024/1024:.1f}MB\")\n        \n        # Validar nome seguro\n        if not re.match(r'^[a-zA-Z0-9._-]+$', filename):\n            errors.append(\"Nome do arquivo cont√©m caracteres inv√°lidos\")\n        \n        return len(errors) == 0, errors\n    \n    @staticmethod\n    def validate_search_params(query: str, filters: Dict) -> Tuple[bool, List[str]]:\n        \"\"\"Valida par√¢metros de busca para prevenir ataques\"\"\"\n        errors = []\n        \n        # Validar query de busca\n        if query and len(query) > 100:\n            errors.append(\"Termo de busca muito longo\")\n        \n        # Verificar caracteres suspeitos\n        if query and re.search(r'[<>\"\\';]', query):\n            errors.append(\"Termo de busca cont√©m caracteres inv√°lidos\")\n        \n        # Validar filtros\n        if filters:\n            for key, value in filters.items():\n                if not isinstance(key, str) or len(key) > 50:\n                    errors.append(f\"Chave de filtro inv√°lida: {key}\")\n                \n                if value and isinstance(value, str) and len(value) > 100:\n                    errors.append(f\"Valor de filtro muito longo: {key}\")\n        \n        return len(errors) == 0, errors\n\n# Inst√¢ncia global para uso na aplica√ß√£o\nvalidator = ValidationRules()","size_bytes":6180},"static/style.css":{"content":"body { background: #f5f5f5; }","size_bytes":29},"static/sw.js":{"content":"// Service Worker for Sistema OS PWA\n// Minimal implementation for PWA registration\n\nconst CACHE_NAME = 'olivium-v1-modern';\n\n// Install event - basic PWA registration\nself.addEventListener('install', function(event) {\n  console.log('Service Worker: Installing...');\n  self.skipWaiting();\n});\n\n// Activate event\nself.addEventListener('activate', function(event) {\n  console.log('Service Worker: Activating...');\n  event.waitUntil(self.clients.claim());\n});\n\n// Fetch event - pass through all requests to network\n// No caching for now to maintain all existing functionality\nself.addEventListener('fetch', function(event) {\n  // Simply pass through all requests to the network\n  // This ensures all existing functionality works exactly as before\n  event.respondWith(fetch(event.request));\n});","size_bytes":790},"static/css/custom.css":{"content":"body { padding-bottom: 60px; }\nfooter { position: fixed; bottom: 0; left: 0; right: 0; background: #f8f9fa; border-top: 1px solid #e2e2e2; padding: 8px 0; }\n","size_bytes":157},"static/css/form-validation.css":{"content":"/**\n * CSS para Sistema de Valida√ß√£o de Formul√°rios - Sistema Olivion\n */\n\n/* Estilos para campos com valida√ß√£o */\n.form-control.is-valid {\n    border-color: #198754;\n    box-shadow: 0 0 0 0.2rem rgba(25, 135, 84, 0.25);\n}\n\n.form-control.is-invalid {\n    border-color: #dc3545;\n    box-shadow: 0 0 0 0.2rem rgba(220, 53, 69, 0.25);\n}\n\n/* Mensagens de erro personalizadas */\n.field-errors {\n    display: block;\n    width: 100%;\n    margin-top: 0.25rem;\n    font-size: 0.875em;\n    color: #dc3545;\n}\n\n.field-errors div {\n    margin-bottom: 0.25rem;\n}\n\n.field-errors div:last-child {\n    margin-bottom: 0;\n}\n\n/* Indicador de for√ßa da senha */\n.password-strength {\n    margin-top: 0.5rem;\n}\n\n.password-strength .progress {\n    height: 4px;\n    margin-bottom: 0.25rem;\n    background-color: #e9ecef;\n    border-radius: 2px;\n    overflow: hidden;\n}\n\n.password-strength small {\n    font-size: 0.75rem;\n    font-weight: 500;\n}\n\n/* Destacar campos obrigat√≥rios para COMPRAS */\n.required-for-compras input {\n    border-left: 4px solid #ffc107;\n}\n\n.compras-warning {\n    font-size: 0.875rem;\n    border-radius: 0.375rem;\n    padding: 0.5rem 0.75rem;\n}\n\n/* Anima√ß√µes para feedback visual */\n.form-control {\n    transition: border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;\n}\n\n/* Valida√ß√£o de upload de arquivo */\n.file-upload-error {\n    color: #dc3545;\n    font-size: 0.875rem;\n    margin-top: 0.25rem;\n}\n\n.file-upload-success {\n    color: #198754;\n    font-size: 0.875rem;\n    margin-top: 0.25rem;\n}\n\n/* Indicadores visuais durante valida√ß√£o */\n.validating {\n    position: relative;\n}\n\n.validating::after {\n    content: '';\n    position: absolute;\n    right: 10px;\n    top: 50%;\n    transform: translateY(-50%);\n    width: 16px;\n    height: 16px;\n    border: 2px solid #dee2e6;\n    border-top: 2px solid #007bff;\n    border-radius: 50%;\n    animation: spin 1s linear infinite;\n}\n\n@keyframes spin {\n    0% { transform: translateY(-50%) rotate(0deg); }\n    100% { transform: translateY(-50%) rotate(360deg); }\n}\n\n/* Melhorar apar√™ncia dos campos obrigat√≥rios */\n.form-label.required::after {\n    content: ' *';\n    color: #dc3545;\n    font-weight: bold;\n}\n\n/* Estilos para diferentes tipos de valida√ß√£o */\n.validation-success {\n    border-left: 4px solid #198754;\n    background-color: rgba(25, 135, 84, 0.05);\n}\n\n.validation-warning {\n    border-left: 4px solid #ffc107;\n    background-color: rgba(255, 193, 7, 0.05);\n}\n\n.validation-error {\n    border-left: 4px solid #dc3545;\n    background-color: rgba(220, 53, 69, 0.05);\n}\n\n/* Responsividade para mobile */\n@media (max-width: 768px) {\n    .field-errors {\n        font-size: 0.8rem;\n    }\n    \n    .password-strength small {\n        font-size: 0.7rem;\n    }\n    \n    .compras-warning {\n        font-size: 0.8rem;\n        padding: 0.4rem 0.6rem;\n    }\n}\n\n/* Estilos para formul√°rios em modo escuro (se implementado) */\n[data-theme=\"dark\"] .form-control.is-valid {\n    border-color: #28a745;\n}\n\n[data-theme=\"dark\"] .form-control.is-invalid {\n    border-color: #dc3545;\n}\n\n[data-theme=\"dark\"] .field-errors {\n    color: #ff6b6b;\n}\n\n[data-theme=\"dark\"] .password-strength .progress {\n    background-color: #495057;\n}","size_bytes":3183},"static/css/mobile-optimizations.css":{"content":"/**\n * Otimiza√ß√µes Mobile - Sistema Olivion\n * CSS otimizado para dispositivos m√≥veis\n */\n\n/* === MEDIA QUERIES === */\n\n/* Mobile First - Base styles for mobile */\n@media (max-width: 767.98px) {\n  \n  /* === LAYOUT GERAL === */\n  .container-fluid {\n    padding-left: 0.75rem;\n    padding-right: 0.75rem;\n  }\n  \n  .row {\n    margin-left: -0.375rem;\n    margin-right: -0.375rem;\n  }\n  \n  .row > * {\n    padding-left: 0.375rem;\n    padding-right: 0.375rem;\n  }\n  \n  /* === NAVEGA√á√ÉO MOBILE === */\n  .navbar {\n    padding: 0.5rem 0.75rem;\n  }\n  \n  .navbar-brand {\n    font-size: 1.1rem;\n    padding: 0.25rem 0;\n  }\n  \n  .navbar-toggler {\n    padding: 0.25rem 0.5rem;\n    font-size: 0.9rem;\n  }\n  \n  .offcanvas {\n    width: 280px !important;\n    max-width: 85vw;\n  }\n  \n  .offcanvas-header {\n    padding: 1rem;\n  }\n  \n  .offcanvas-body {\n    padding: 0.5rem 1rem;\n  }\n  \n  /* === SIDEBAR MOBILE === */\n  .sidebar {\n    margin-bottom: 1rem;\n  }\n  \n  .sidebar-menu .nav-link {\n    padding: 0.75rem 1rem;\n    font-size: 0.95rem;\n  }\n  \n  .sidebar-menu .nav-link i {\n    width: 20px;\n    margin-right: 0.75rem;\n  }\n  \n  /* === CARDS E CONTAINERS === */\n  .card {\n    margin-bottom: 1rem;\n    border-radius: 12px;\n  }\n  \n  .card-header {\n    padding: 0.75rem 1rem;\n    font-size: 1rem;\n  }\n  \n  .card-body {\n    padding: 1rem;\n  }\n  \n  /* === FORMUL√ÅRIOS MOBILE === */\n  .form-control {\n    padding: 0.75rem;\n    font-size: 16px; /* Previne zoom no iOS */\n    border-radius: 8px;\n  }\n  \n  .form-select {\n    padding: 0.75rem;\n    font-size: 16px;\n    border-radius: 8px;\n  }\n  \n  textarea.form-control {\n    min-height: 120px;\n    resize: vertical;\n  }\n  \n  .form-label {\n    font-size: 0.9rem;\n    margin-bottom: 0.5rem;\n    font-weight: 500;\n  }\n  \n  .form-text {\n    font-size: 0.8rem;\n    margin-top: 0.25rem;\n  }\n  \n  /* === BOT√ïES MOBILE === */\n  .btn {\n    padding: 0.75rem 1rem;\n    font-size: 0.9rem;\n    border-radius: 8px;\n    min-height: 44px; /* Touch target iOS */\n  }\n  \n  .btn-sm {\n    padding: 0.5rem 0.75rem;\n    font-size: 0.85rem;\n    min-height: 36px;\n  }\n  \n  .btn-lg {\n    padding: 1rem 1.5rem;\n    font-size: 1rem;\n    min-height: 50px;\n  }\n  \n  /* Bot√µes em linha no mobile */\n  .btn-group-mobile {\n    display: flex;\n    flex-direction: column;\n    gap: 0.5rem;\n    width: 100%;\n  }\n  \n  .btn-group-mobile .btn {\n    width: 100%;\n    margin: 0;\n  }\n  \n  /* === TABELAS MOBILE === */\n  .table-responsive {\n    border-radius: 8px;\n    overflow-x: auto;\n    -webkit-overflow-scrolling: touch;\n  }\n  \n  .table {\n    min-width: 600px; /* For√ßa scroll horizontal */\n    font-size: 0.85rem;\n  }\n  \n  .table th {\n    padding: 0.5rem;\n    font-size: 0.8rem;\n    white-space: nowrap;\n  }\n  \n  .table td {\n    padding: 0.5rem;\n    vertical-align: middle;\n  }\n  \n  /* Tabela compacta para mobile */\n  .table-mobile-compact {\n    min-width: auto !important;\n  }\n  \n  .table-mobile-compact th,\n  .table-mobile-compact td {\n    padding: 0.4rem 0.3rem;\n    font-size: 0.8rem;\n  }\n  \n  /* === MODAIS MOBILE === */\n  .modal-dialog {\n    margin: 0.5rem;\n    max-width: calc(100vw - 1rem);\n  }\n  \n  .modal-content {\n    border-radius: 12px;\n  }\n  \n  .modal-header {\n    padding: 1rem;\n    border-bottom: 1px solid var(--border-color);\n  }\n  \n  .modal-body {\n    padding: 1rem;\n    max-height: 60vh;\n    overflow-y: auto;\n  }\n  \n  .modal-footer {\n    padding: 1rem;\n    border-top: 1px solid var(--border-color);\n  }\n  \n  /* === ALERTAS E NOTIFICA√á√ïES === */\n  .alert {\n    padding: 0.75rem 1rem;\n    margin-bottom: 1rem;\n    border-radius: 8px;\n    font-size: 0.9rem;\n  }\n  \n  .toast {\n    max-width: calc(100vw - 2rem);\n    margin: 1rem;\n  }\n  \n  /* === ESTAT√çSTICAS MOBILE === */\n  .stats-card {\n    padding: 1rem;\n    margin-bottom: 1rem;\n  }\n  \n  .stats-number {\n    font-size: 1.8rem;\n  }\n  \n  .stats-label {\n    font-size: 0.85rem;\n  }\n  \n  /* === UPLOAD DE ARQUIVOS === */\n  .file-upload-zone {\n    padding: 2rem 1rem;\n    border: 2px dashed var(--border-color);\n    border-radius: 8px;\n    text-align: center;\n    cursor: pointer;\n    transition: all 0.3s ease;\n  }\n  \n  .file-upload-zone:hover,\n  .file-upload-zone.dragover {\n    border-color: var(--primary-color);\n    background-color: rgba(37, 99, 235, 0.05);\n  }\n  \n  /* === BARRA DE PROGRESSO === */\n  .progress {\n    height: 8px;\n    border-radius: 4px;\n  }\n  \n  /* === BADGES E LABELS === */\n  .badge {\n    font-size: 0.75rem;\n    padding: 0.35em 0.65em;\n  }\n  \n  /* === NAVEGA√á√ÉO BREADCRUMB === */\n  .breadcrumb {\n    margin-bottom: 1rem;\n    padding: 0.5rem 0;\n    font-size: 0.85rem;\n  }\n  \n  .breadcrumb-item {\n    line-height: 1.2;\n  }\n  \n  /* === PAGINA√á√ÉO === */\n  .pagination {\n    margin-bottom: 0;\n    justify-content: center;\n  }\n  \n  .page-link {\n    padding: 0.5rem 0.75rem;\n    font-size: 0.9rem;\n  }\n  \n  /* === CARDS DE CHAMADOS === */\n  .ticket-card {\n    padding: 1rem;\n    margin-bottom: 1rem;\n    border-radius: 8px;\n    border-left: 4px solid var(--primary-color);\n    background: var(--card-bg);\n    box-shadow: var(--card-shadow);\n  }\n  \n  .ticket-header {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    margin-bottom: 0.5rem;\n  }\n  \n  .ticket-title {\n    font-size: 1rem;\n    font-weight: 600;\n    margin: 0;\n  }\n  \n  .ticket-status {\n    font-size: 0.75rem;\n  }\n  \n  .ticket-meta {\n    font-size: 0.8rem;\n    color: var(--secondary-color);\n    margin: 0.25rem 0;\n  }\n  \n  .ticket-description {\n    font-size: 0.9rem;\n    color: var(--text-color);\n    margin-top: 0.5rem;\n    line-height: 1.4;\n  }\n  \n  /* === MENU LATERAL COMPACTO === */\n  .sidebar-compact {\n    width: 60px;\n  }\n  \n  .sidebar-compact .nav-link {\n    text-align: center;\n    padding: 0.75rem 0.5rem;\n  }\n  \n  .sidebar-compact .nav-link span {\n    display: none;\n  }\n  \n  .sidebar-compact .nav-link i {\n    margin-right: 0;\n  }\n  \n  /* === THUMB NAVIGATION === */\n  .thumb-nav {\n    position: fixed;\n    bottom: 20px;\n    right: 20px;\n    z-index: 1050;\n  }\n  \n  .thumb-nav .btn {\n    width: 50px;\n    height: 50px;\n    border-radius: 50%;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n    margin-bottom: 0.5rem;\n  }\n  \n  /* === OTIMIZA√á√ïES DE TOQUE === */\n  .touch-target {\n    min-height: 44px;\n    min-width: 44px;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n  }\n  \n  /* === LOADING STATES === */\n  .loading-spinner {\n    display: inline-block;\n    width: 20px;\n    height: 20px;\n    border: 2px solid rgba(255, 255, 255, 0.3);\n    border-radius: 50%;\n    border-top-color: #ffffff;\n    animation: spin 1s ease-in-out infinite;\n  }\n  \n  @keyframes spin {\n    to { transform: rotate(360deg); }\n  }\n  \n  /* === MELHORIAS DE ACESSIBILIDADE === */\n  .sr-only {\n    position: absolute !important;\n    width: 1px !important;\n    height: 1px !important;\n    padding: 0 !important;\n    margin: -1px !important;\n    overflow: hidden !important;\n    clip: rect(0, 0, 0, 0) !important;\n    white-space: nowrap !important;\n    border: 0 !important;\n  }\n  \n  /* === DARK MODE MOBILE === */\n  [data-theme=\"dark\"] .file-upload-zone:hover,\n  [data-theme=\"dark\"] .file-upload-zone.dragover {\n    background-color: rgba(37, 99, 235, 0.1);\n  }\n  \n  [data-theme=\"dark\"] .ticket-card {\n    background: var(--card-bg);\n    border-left-color: var(--primary-color);\n  }\n}\n\n/* === TABLET (768px - 991.98px) === */\n@media (min-width: 768px) and (max-width: 991.98px) {\n  .container-fluid {\n    padding-left: 1rem;\n    padding-right: 1rem;\n  }\n  \n  .card-body {\n    padding: 1.5rem;\n  }\n  \n  .sidebar {\n    width: 250px;\n  }\n  \n  .table {\n    font-size: 0.9rem;\n  }\n  \n  .btn {\n    padding: 0.5rem 1rem;\n  }\n}\n\n/* === LANDSCAPE MOBILE === */\n@media (max-width: 767.98px) and (orientation: landscape) {\n  .navbar {\n    padding: 0.25rem 0.75rem;\n  }\n  \n  .modal-dialog {\n    max-height: 90vh;\n  }\n  \n  .modal-body {\n    max-height: 50vh;\n  }\n  \n  .offcanvas {\n    width: 250px !important;\n  }\n}\n\n/* === MUITO PEQUENO (< 576px) === */\n@media (max-width: 575.98px) {\n  .container, .container-sm, .container-md, .container-lg, .container-xl, .container-xxl {\n    padding-left: 0.5rem;\n    padding-right: 0.5rem;\n  }\n  \n  .card-body {\n    padding: 0.75rem;\n  }\n  \n  .btn {\n    font-size: 0.85rem;\n    padding: 0.6rem 0.8rem;\n  }\n  \n  .form-control, .form-select {\n    font-size: 16px; /* Previne zoom iOS */\n  }\n  \n  .table {\n    font-size: 0.8rem;\n  }\n  \n  .stats-number {\n    font-size: 1.5rem;\n  }\n}\n\n/* === UTILITIES MOBILE === */\n.d-mobile-block { display: none !important; }\n.d-mobile-none { display: block !important; }\n\n@media (max-width: 767.98px) {\n  .d-mobile-block { display: block !important; }\n  .d-mobile-none { display: none !important; }\n  \n  .w-mobile-100 { width: 100% !important; }\n  .text-mobile-center { text-align: center !important; }\n  .mb-mobile-3 { margin-bottom: 1rem !important; }\n  .p-mobile-2 { padding: 0.5rem !important; }\n}\n\n/* === PWA SPECIFIC === */\n@media all and (display-mode: standalone) {\n  .navbar {\n    padding-top: env(safe-area-inset-top, 0);\n  }\n  \n  .container-fluid {\n    padding-bottom: env(safe-area-inset-bottom, 0);\n  }\n}\n\n/* === OTIMIZA√á√ïES ANDROID/iOS === */\n@supports (-webkit-touch-callout: none) {\n  /* iOS espec√≠fico */\n  .form-control:focus,\n  .form-select:focus {\n    transform: translateZ(0); /* Fix para rendering iOS */\n  }\n}\n\n@supports ((-webkit-backdrop-filter: blur(10px)) or (backdrop-filter: blur(10px))) {\n  .modal-content {\n    backdrop-filter: blur(10px);\n    background-color: rgba(255, 255, 255, 0.95);\n  }\n  \n  [data-theme=\"dark\"] .modal-content {\n    background-color: rgba(30, 41, 59, 0.95);\n  }\n}","size_bytes":9663},"static/css/style.css":{"content":"body{background-color:#f8f9fa}.table td,.table th{vertical-align:middle}","size_bytes":72},"static/js/form-validation.js":{"content":"/**\n * Sistema de Valida√ß√£o de Formul√°rios - Sistema Olivion\n * Valida√ß√µes em tempo real com feedback visual\n */\n\nclass FormValidator {\n    constructor() {\n        this.rules = {\n            username: {\n                minLength: 3,\n                maxLength: 50,\n                pattern: /^[a-zA-Z0-9_-]+$/,\n                required: true\n            },\n            password: {\n                minLength: 6,\n                maxLength: 128,\n                pattern: /^(?=.*[A-Za-z])(?=.*\\d)/,\n                required: true\n            },\n            email: {\n                pattern: /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/,\n                required: true\n            },\n            titulo: {\n                minLength: 5,\n                maxLength: 200,\n                required: true\n            },\n            descricao: {\n                minLength: 10,\n                maxLength: 2000,\n                required: true\n            },\n            ramal: {\n                pattern: /^\\d{3,6}$/,\n                required: false\n            },\n            cdc: {\n                maxLength: 50,\n                required: false\n            }\n        };\n\n        this.init();\n    }\n\n    init() {\n        // Aguardar o DOM carregar\n        if (document.readyState === 'loading') {\n            document.addEventListener('DOMContentLoaded', () => this.bindEvents());\n        } else {\n            this.bindEvents();\n        }\n    }\n\n    bindEvents() {\n        // Valida√ß√£o em tempo real para inputs\n        document.querySelectorAll('input, textarea, select').forEach(field => {\n            field.addEventListener('blur', (e) => this.validateField(e.target));\n            field.addEventListener('input', (e) => this.clearErrors(e.target));\n        });\n\n        // Valida√ß√£o especial para upload de arquivos\n        document.querySelectorAll('input[type=\"file\"]').forEach(input => {\n            input.addEventListener('change', (e) => this.validateFile(e.target));\n        });\n\n        // Valida√ß√£o em formul√°rios submit\n        document.querySelectorAll('form').forEach(form => {\n            form.addEventListener('submit', (e) => {\n                if (!this.validateForm(form)) {\n                    e.preventDefault();\n                }\n            });\n        });\n\n        // For√ßa da senha em tempo real\n        const passwordField = document.querySelector('input[name=\"password\"]');\n        if (passwordField) {\n            passwordField.addEventListener('input', (e) => this.showPasswordStrength(e.target));\n        }\n    }\n\n    validateField(field) {\n        const name = field.name;\n        const value = field.value.trim();\n        const rule = this.rules[name];\n\n        if (!rule) return true;\n\n        const errors = [];\n\n        // Validar campo obrigat√≥rio\n        if (rule.required && !value) {\n            errors.push(`${this.getFieldLabel(field)} √© obrigat√≥rio`);\n        }\n\n        if (value) {\n            // Validar comprimento m√≠nimo\n            if (rule.minLength && value.length < rule.minLength) {\n                errors.push(`${this.getFieldLabel(field)} deve ter pelo menos ${rule.minLength} caracteres`);\n            }\n\n            // Validar comprimento m√°ximo\n            if (rule.maxLength && value.length > rule.maxLength) {\n                errors.push(`${this.getFieldLabel(field)} n√£o pode ter mais de ${rule.maxLength} caracteres`);\n            }\n\n            // Validar padr√£o\n            if (rule.pattern && !rule.pattern.test(value)) {\n                errors.push(this.getPatternErrorMessage(name));\n            }\n        }\n\n        // Valida√ß√µes espec√≠ficas\n        if (name === 'usuario_setor') {\n            this.checkComprasSetor(value, field.form);\n        }\n\n        this.showFieldErrors(field, errors);\n        return errors.length === 0;\n    }\n\n    validateFile(fileInput) {\n        const file = fileInput.files[0];\n        if (!file) return true;\n\n        const errors = [];\n        const maxSize = 5 * 1024 * 1024; // 5MB\n        const allowedTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/gif'];\n\n        // Validar tamanho\n        if (file.size > maxSize) {\n            errors.push(`Arquivo muito grande. M√°ximo permitido: 5MB`);\n        }\n\n        // Validar tipo\n        if (!allowedTypes.includes(file.type)) {\n            errors.push(`Tipo de arquivo n√£o permitido. Use: JPG, JPEG, PNG ou GIF`);\n        }\n\n        // Validar nome do arquivo (seguran√ßa)\n        if (!/^[a-zA-Z0-9._-]+$/.test(file.name)) {\n            errors.push(`Nome do arquivo cont√©m caracteres inv√°lidos`);\n        }\n\n        this.showFieldErrors(fileInput, errors);\n        return errors.length === 0;\n    }\n\n    validateForm(form) {\n        let isValid = true;\n        const fields = form.querySelectorAll('input, textarea, select');\n\n        fields.forEach(field => {\n            if (!this.validateField(field)) {\n                isValid = false;\n            }\n        });\n\n        // Valida√ß√£o especial: CDC obrigat√≥rio para COMPRAS\n        const setorField = form.querySelector('input[name=\"usuario_setor\"]');\n        const cdcField = form.querySelector('input[name=\"cdc\"]');\n        \n        if (setorField && cdcField) {\n            const setorValue = setorField.value.toUpperCase();\n            if ((setorValue.includes('COMPRAS') || setorValue.includes('COMPRA')) && !cdcField.value.trim()) {\n                this.showFieldErrors(cdcField, ['CDC √© obrigat√≥rio para o setor COMPRAS']);\n                isValid = false;\n            }\n        }\n\n        return isValid;\n    }\n\n    checkComprasSetor(setorValue, form) {\n        const cdcField = form.querySelector('input[name=\"cdc\"]');\n        if (cdcField) {\n            const isCompras = setorValue.toUpperCase().includes('COMPRAS') || \n                            setorValue.toUpperCase().includes('COMPRA');\n            \n            if (isCompras) {\n                cdcField.setAttribute('required', 'required');\n                cdcField.parentElement.classList.add('required-for-compras');\n                \n                // Adicionar aviso visual\n                let warning = cdcField.parentElement.querySelector('.compras-warning');\n                if (!warning) {\n                    warning = document.createElement('div');\n                    warning.className = 'alert alert-warning mt-2 compras-warning';\n                    warning.innerHTML = '<i class=\"bi bi-exclamation-triangle\"></i> CDC √© obrigat√≥rio para o setor COMPRAS';\n                    cdcField.parentElement.appendChild(warning);\n                }\n            } else {\n                cdcField.removeAttribute('required');\n                cdcField.parentElement.classList.remove('required-for-compras');\n                \n                // Remover aviso\n                const warning = cdcField.parentElement.querySelector('.compras-warning');\n                if (warning) warning.remove();\n            }\n        }\n    }\n\n    showPasswordStrength(passwordField) {\n        const password = passwordField.value;\n        let strengthContainer = document.getElementById('password-strength');\n        \n        if (!strengthContainer) {\n            strengthContainer = document.createElement('div');\n            strengthContainer.id = 'password-strength';\n            strengthContainer.className = 'mt-2';\n            passwordField.parentElement.appendChild(strengthContainer);\n        }\n\n        if (!password) {\n            strengthContainer.innerHTML = '';\n            return;\n        }\n\n        const strength = this.calculatePasswordStrength(password);\n        const strengthClass = strength.class;\n        const strengthText = strength.text;\n\n        strengthContainer.innerHTML = `\n            <div class=\"password-strength\">\n                <div class=\"progress\" style=\"height: 5px;\">\n                    <div class=\"progress-bar bg-${strengthClass}\" \n                         style=\"width: ${strength.percentage}%\"></div>\n                </div>\n                <small class=\"text-${strengthClass}\">${strengthText}</small>\n            </div>\n        `;\n    }\n\n    calculatePasswordStrength(password) {\n        let score = 0;\n        \n        // Comprimento\n        if (password.length >= 8) score += 2;\n        else if (password.length >= 6) score += 1;\n        \n        // Min√∫sculas\n        if (/[a-z]/.test(password)) score += 1;\n        \n        // Mai√∫sculas\n        if (/[A-Z]/.test(password)) score += 1;\n        \n        // N√∫meros\n        if (/[0-9]/.test(password)) score += 1;\n        \n        // S√≠mbolos\n        if (/[^A-Za-z0-9]/.test(password)) score += 1;\n\n        if (score < 3) return { class: 'danger', text: 'Fraca', percentage: 25 };\n        if (score < 5) return { class: 'warning', text: 'M√©dia', percentage: 50 };\n        if (score < 6) return { class: 'info', text: 'Boa', percentage: 75 };\n        return { class: 'success', text: 'Forte', percentage: 100 };\n    }\n\n    showFieldErrors(field, errors) {\n        this.clearErrors(field);\n\n        if (errors.length === 0) {\n            field.classList.remove('is-invalid');\n            field.classList.add('is-valid');\n            return;\n        }\n\n        field.classList.add('is-invalid');\n        field.classList.remove('is-valid');\n\n        // Criar container de erros\n        const errorContainer = document.createElement('div');\n        errorContainer.className = 'invalid-feedback field-errors';\n        errorContainer.innerHTML = errors.map(error => `<div>${error}</div>`).join('');\n\n        field.parentElement.appendChild(errorContainer);\n    }\n\n    clearErrors(field) {\n        const existingErrors = field.parentElement.querySelectorAll('.field-errors');\n        existingErrors.forEach(error => error.remove());\n        \n        field.classList.remove('is-invalid', 'is-valid');\n    }\n\n    getFieldLabel(field) {\n        const label = field.parentElement.querySelector('label');\n        if (label) {\n            return label.textContent.replace('*', '').trim();\n        }\n        \n        const placeholder = field.getAttribute('placeholder');\n        if (placeholder) {\n            return placeholder.replace('Digite', '').replace('...', '').trim();\n        }\n        \n        return field.name.charAt(0).toUpperCase() + field.name.slice(1);\n    }\n\n    getPatternErrorMessage(fieldName) {\n        const messages = {\n            username: 'Username s√≥ pode conter letras, n√∫meros, _ e -',\n            password: 'Senha deve conter pelo menos uma letra e um n√∫mero',\n            email: 'Email deve ter um formato v√°lido (exemplo@dominio.com)',\n            ramal: 'Ramal deve conter apenas n√∫meros (3-6 d√≠gitos)'\n        };\n        return messages[fieldName] || 'Formato inv√°lido';\n    }\n\n    // M√©todo p√∫blico para sanitizar entrada\n    static sanitizeInput(input) {\n        return input.replace(/[<>\\\"'&]/g, function(match) {\n            const map = {\n                '<': '&lt;',\n                '>': '&gt;',\n                '\"': '&quot;',\n                \"'\": '&#x27;',\n                '&': '&amp;'\n            };\n            return map[match];\n        });\n    }\n\n    // M√©todo p√∫blico para valida√ß√£o manual\n    static validate(fieldName, value) {\n        const validator = new FormValidator();\n        const mockField = { name: fieldName, value: value };\n        return validator.validateField(mockField);\n    }\n}\n\n// Inicializar validador quando o script carregar\nconst formValidator = new FormValidator();\n\n// Exportar para uso global\nwindow.FormValidator = FormValidator;","size_bytes":11466},"api_endpoints.py":{"content":"# api_endpoints.py - Endpoints REST para integra√ß√£o externa/mobile\n\nfrom flask import Flask, jsonify, request\nfrom flask_sqlalchemy import SQLAlchemy\nfrom functools import wraps\nfrom datetime import datetime\nimport json\nfrom typing import Dict, List, Any, Optional\nfrom api_security import enhanced_api_auth, api_rate_limit\n\ndef create_api_routes(app: Flask, db: SQLAlchemy) -> None:\n    \"\"\"Cria endpoints REST para o sistema\"\"\"\n    \n    def api_key_required(f):\n        \"\"\"Decorator para validar API key ou sess√£o ativa\"\"\"\n        @wraps(f)\n        def decorated_function(*args, **kwargs):\n            from flask import session, request, jsonify\n            \n            # Verificar API key no header\n            api_key = request.headers.get('X-API-Key')\n            if api_key == 'helpdesk_demo_api_key_2025':  # API key para demonstra√ß√£o\n                return f(*args, **kwargs)\n            \n            # Verificar se usu√°rio tem sess√£o ativa e √© admin/operador\n            if 'user_id' in session:\n                try:\n                    # Import dentro do contexto para evitar problemas\n                    from models import User\n                    user = User.query.get(session['user_id'])\n                    if user and (user.is_admin or user.is_operator_like):\n                        return f(*args, **kwargs)\n                except:\n                    pass\n            \n            # N√£o autorizado\n            return jsonify({\n                'success': False,\n                'error': 'API key ou autoriza√ß√£o necess√°ria',\n                'timestamp': datetime.now().isoformat()\n            }), 401\n            \n        return decorated_function\n    \n    def json_response(data: Any, status_code: int = 200) -> tuple:\n        \"\"\"Padroniza resposta JSON\"\"\"\n        return jsonify({\n            'success': status_code < 400,\n            'data': data,\n            'timestamp': datetime.now().isoformat()\n        }), status_code\n    \n    @app.route('/api/v1/health', methods=['GET'])\n    def api_health() -> tuple:\n        \"\"\"Endpoint de sa√∫de da API\"\"\"\n        return json_response({\n            'status': 'healthy',\n            'version': '1.0.0',\n            'database': 'connected'\n        })\n    \n    @app.route('/api/v1/stats', methods=['GET'])\n    @api_key_required\n    def api_stats() -> tuple:\n        \"\"\"Estat√≠sticas b√°sicas do sistema\"\"\"\n        try:\n            # Usar SQLAlchemy de forma consistente\n            with app.app_context():\n                # Import models no contexto da app\n                from models import User, Chamado\n                from sqlalchemy import func\n                \n                # Contar usu√°rios ativos\n                total_users = db.session.query(User).filter(User.active == True).count()\n                \n                # Contar total de chamados\n                total_chamados = db.session.query(Chamado).count()\n                \n                # Chamados por status\n                status_query = db.session.query(\n                    Chamado.status, \n                    func.count(Chamado.id)\n                ).group_by(Chamado.status).all()\n                status_counts = {status: count for status, count in status_query}\n                \n                # Chamados por setor\n                setor_query = db.session.query(\n                    Chamado.setor, \n                    func.count(Chamado.id)\n                ).group_by(Chamado.setor).all()\n                setor_counts = {setor: count for setor, count in setor_query}\n            \n            return json_response({\n                'total_users': total_users,\n                'total_chamados': total_chamados,\n                'chamados_por_status': status_counts,\n                'chamados_por_setor': setor_counts\n            })\n            \n        except Exception as e:\n            return json_response({'error': str(e)}, 500)\n    \n    @app.route('/api/v1/chamados', methods=['GET'])\n    @api_rate_limit\n    @enhanced_api_auth('read')\n    def api_list_chamados() -> tuple:\n        \"\"\"Lista todos os chamados\"\"\"\n        try:\n            from models import Chamado, User\n            \n            # Par√¢metros de filtro\n            status = request.args.get('status')\n            setor = request.args.get('setor')\n            limit = min(int(request.args.get('limit', 50)), 100)  # Max 100\n            offset = int(request.args.get('offset', 0))\n            \n            # Query base\n            query = Chamado.query\n            \n            # Aplicar filtros\n            if status:\n                query = query.filter(Chamado.status == status)\n            if setor:\n                query = query.filter(Chamado.setor == setor)\n            \n            # Pagina√ß√£o\n            chamados = query.offset(offset).limit(limit).all()\n            \n            # Serializar resultados\n            result = []\n            for chamado in chamados:\n                result.append({\n                    'id': chamado.id,\n                    'titulo': chamado.titulo,\n                    'descricao': chamado.descricao,\n                    'status': chamado.status,\n                    'setor': chamado.setor,\n                    'urgencia': chamado.urgencia,\n                    'prioridade': chamado.prioridade,\n                    'criado_em': chamado.criado_em.isoformat() if chamado.criado_em else None,\n                    'fechado_em': chamado.fechado_em.isoformat() if chamado.fechado_em else None,\n                    'ramal': chamado.ramal,\n                    'cdc': chamado.cdc\n                })\n            \n            return json_response({\n                'chamados': result,\n                'count': len(result),\n                'offset': offset,\n                'limit': limit\n            })\n            \n        except Exception as e:\n            return json_response({'error': str(e)}, 500)\n    \n    @app.route('/api/v1/chamados/<int:chamado_id>', methods=['GET'])\n    @api_key_required\n    def api_get_chamado(chamado_id: int) -> tuple:\n        \"\"\"Busca chamado espec√≠fico\"\"\"\n        try:\n            from models import Chamado, User\n            \n            chamado = Chamado.query.get(chamado_id)\n            if not chamado:\n                return json_response({'error': 'Chamado n√£o encontrado'}, 404)\n            \n            # Buscar informa√ß√µes do usu√°rio\n            usuario = User.query.get(chamado.usuario_id) if chamado.usuario_id else None\n            fechado_por = User.query.get(chamado.fechado_por_id) if chamado.fechado_por_id else None\n            \n            result = {\n                'id': chamado.id,\n                'titulo': chamado.titulo,\n                'descricao': chamado.descricao,\n                'status': chamado.status,\n                'setor': chamado.setor,\n                'urgencia': chamado.urgencia,\n                'prioridade': chamado.prioridade,\n                'criado_em': chamado.criado_em.isoformat() if chamado.criado_em else None,\n                'fechado_em': chamado.fechado_em.isoformat() if chamado.fechado_em else None,\n                'resolucao': chamado.resolucao,\n                'ramal': chamado.ramal,\n                'cdc': chamado.cdc,\n                'usuario': usuario.username if usuario else None,\n                'fechado_por': fechado_por.username if fechado_por else None,\n                'imagens': [chamado.imagem1, chamado.imagem2, chamado.imagem3]\n            }\n            \n            return json_response(result)\n            \n        except Exception as e:\n            return json_response({'error': str(e)}, 500)\n    \n    @app.route('/api/v1/chamados', methods=['POST'])\n    @api_rate_limit\n    @enhanced_api_auth('write')\n    def api_create_chamado() -> tuple:\n        \"\"\"Cria novo chamado via API\"\"\"\n        try:\n            from models import Chamado\n            \n            data = request.get_json()\n            if not data:\n                return json_response({'error': 'Dados JSON obrigat√≥rios'}, 400)\n            \n            # Validar campos obrigat√≥rios\n            required_fields = ['titulo', 'descricao', 'setor']\n            for field in required_fields:\n                if not data.get(field):\n                    return json_response({'error': f'Campo {field} √© obrigat√≥rio'}, 400)\n            \n            # Criar novo chamado\n            chamado = Chamado()\n            chamado.titulo = data['titulo']\n            chamado.descricao = data['descricao'] \n            chamado.setor = data['setor']\n            chamado.urgencia = data.get('urgencia', 'Normal')\n            chamado.prioridade = data.get('prioridade', 'Normal')\n            chamado.status = data.get('status', 'Aberto')\n            chamado.ramal = data.get('ramal', '')\n            chamado.cdc = data.get('cdc', '')\n            chamado.usuario_id = data.get('usuario_id', 1)\n            chamado.criado_em = datetime.now()\n            \n            db.session.add(chamado)\n            db.session.commit()\n            \n            return json_response({\n                'message': 'Chamado criado com sucesso',\n                'chamado_id': chamado.id\n            }, 201)\n            \n        except Exception as e:\n            db.session.rollback()\n            return json_response({'error': str(e)}, 500)\n    \n    @app.route('/api/v1/chamados/<int:chamado_id>/status', methods=['PUT'])\n    @api_rate_limit\n    @enhanced_api_auth('write')\n    def api_update_chamado_status(chamado_id: int) -> tuple:\n        \"\"\"Atualiza status de um chamado\"\"\"\n        try:\n            from models import Chamado\n            \n            data = request.get_json()\n            if not data or 'status' not in data:\n                return json_response({'error': 'Status √© obrigat√≥rio'}, 400)\n            \n            chamado = Chamado.query.get(chamado_id)\n            if not chamado:\n                return json_response({'error': 'Chamado n√£o encontrado'}, 404)\n            \n            # Atualizar status\n            old_status = chamado.status\n            chamado.status = data['status']\n            \n            # Se fechando, definir data\n            if data['status'] in ['Fechado', 'Resolvido']:\n                chamado.fechado_em = datetime.now()\n                if data.get('resolucao'):\n                    chamado.resolucao = data['resolucao']\n            \n            db.session.commit()\n            \n            return json_response({\n                'message': f'Status alterado de {old_status} para {data[\"status\"]}',\n                'chamado_id': chamado_id\n            })\n            \n        except Exception as e:\n            db.session.rollback()\n            return json_response({'error': str(e)}, 500)\n    \n    @app.route('/api/v1/usuarios', methods=['GET'])\n    @api_key_required\n    def api_list_usuarios() -> tuple:\n        \"\"\"Lista usu√°rios do sistema\"\"\"\n        try:\n            from models import User\n            \n            limit = min(int(request.args.get('limit', 20)), 50)  # Max 50\n            offset = int(request.args.get('offset', 0))\n            \n            usuarios = User.query.filter(User.active == True).offset(offset).limit(limit).all()\n            \n            result = []\n            for user in usuarios:\n                result.append({\n                    'id': user.id,\n                    'username': user.username,\n                    'role': user.role,\n                    'setor': user.setor,\n                    'created_at': user.created_at.isoformat() if user.created_at else None\n                })\n            \n            return json_response({\n                'usuarios': result,\n                'count': len(result),\n                'offset': offset,\n                'limit': limit\n            })\n            \n        except Exception as e:\n            return json_response({'error': str(e)}, 500)\n    \n    @app.route('/api/v1/setores', methods=['GET'])\n    def api_list_setores() -> tuple:\n        \"\"\"Lista setores dispon√≠veis\"\"\"\n        from app import SETOR_CHOICES\n        return json_response({\n            'setores': SETOR_CHOICES\n        })\n    \n    print(\"‚úÖ Endpoints REST configurados:\")\n    print(\"   GET  /api/v1/health\")\n    print(\"   GET  /api/v1/stats\") \n    print(\"   GET  /api/v1/chamados\")\n    print(\"   POST /api/v1/chamados\")\n    print(\"   GET  /api/v1/chamados/<id>\")\n    print(\"   PUT  /api/v1/chamados/<id>/status\")\n    print(\"   GET  /api/v1/usuarios\")\n    print(\"   GET  /api/v1/setores\")","size_bytes":12395},"api_security.py":{"content":"# api_security.py - Sistema de seguran√ßa para API REST\n\nfrom functools import wraps\nfrom collections import defaultdict\nfrom datetime import datetime, timedelta\nimport time\nfrom flask import request, jsonify, session\n\n# Rate limiting simples\nclass RateLimiter:\n    \"\"\"Rate limiter simples baseado em IP\"\"\"\n    \n    def __init__(self, max_requests: int = 100, window_minutes: int = 15):\n        self.max_requests = max_requests\n        self.window_seconds = window_minutes * 60\n        self.requests = defaultdict(list)  # IP -> list of timestamps\n    \n    def is_allowed(self, identifier: str) -> bool:\n        \"\"\"Verifica se o identificador pode fazer uma requisi√ß√£o\"\"\"\n        now = time.time()\n        \n        # Limpar requisi√ß√µes antigas\n        self.requests[identifier] = [\n            timestamp for timestamp in self.requests[identifier]\n            if now - timestamp < self.window_seconds\n        ]\n        \n        # Verificar limite\n        if len(self.requests[identifier]) >= self.max_requests:\n            return False\n        \n        # Adicionar requisi√ß√£o atual\n        self.requests[identifier].append(now)\n        return True\n    \n    def get_remaining_requests(self, identifier: str) -> int:\n        \"\"\"Retorna quantas requisi√ß√µes restam para o identificador\"\"\"\n        now = time.time()\n        self.requests[identifier] = [\n            timestamp for timestamp in self.requests[identifier]\n            if now - timestamp < self.window_seconds\n        ]\n        return max(0, self.max_requests - len(self.requests[identifier]))\n\n# Inst√¢ncia global do rate limiter\nrate_limiter = RateLimiter(max_requests=60, window_minutes=15)  # 60 req/15min\n\ndef api_rate_limit(f):\n    \"\"\"Decorator para rate limiting da API\"\"\"\n    @wraps(f)\n    def decorated_function(*args, **kwargs):\n        # Identificar cliente (IP + User-Agent)\n        client_ip = request.environ.get('REMOTE_ADDR', 'unknown')\n        user_agent = request.headers.get('User-Agent', '')\n        client_id = f\"{client_ip}_{hash(user_agent) % 10000}\"\n        \n        if not rate_limiter.is_allowed(client_id):\n            return jsonify({\n                'success': False,\n                'error': 'Rate limit exceeded. Try again later.',\n                'timestamp': datetime.now().isoformat()\n            }), 429\n        \n        # Adicionar headers de rate limit\n        response = f(*args, **kwargs)\n        if isinstance(response, tuple):\n            response_data, status_code = response\n            remaining = rate_limiter.get_remaining_requests(client_id)\n            response_data.headers['X-RateLimit-Remaining'] = str(remaining)\n            response_data.headers['X-RateLimit-Limit'] = str(rate_limiter.max_requests)\n            return response_data, status_code\n        else:\n            remaining = rate_limiter.get_remaining_requests(client_id)\n            response.headers['X-RateLimit-Remaining'] = str(remaining)\n            response.headers['X-RateLimit-Limit'] = str(rate_limiter.max_requests)\n            return response\n    \n    return decorated_function\n\ndef validate_api_key(api_key: str) -> bool:\n    \"\"\"Valida se uma API key √© v√°lida\"\"\"\n    # API keys v√°lidas (em produ√ß√£o, estes devem estar em vari√°veis de ambiente)\n    valid_keys = [\n        'helpdesk_demo_api_key_2025',\n        'helpdesk_admin_api_2025',\n        'helpdesk_readonly_api_2025'\n    ]\n    return api_key in valid_keys\n\ndef get_api_key_permissions(api_key: str) -> dict:\n    \"\"\"Retorna as permiss√µes de uma API key\"\"\"\n    permissions = {\n        'helpdesk_demo_api_key_2025': {\n            'read': True,\n            'write': True,\n            'admin': False,\n            'description': 'Demo API Key'\n        },\n        'helpdesk_admin_api_2025': {\n            'read': True,\n            'write': True,\n            'admin': True,\n            'description': 'Admin API Key'\n        },\n        'helpdesk_readonly_api_2025': {\n            'read': True,\n            'write': False,\n            'admin': False,\n            'description': 'Read-only API Key'\n        }\n    }\n    return permissions.get(api_key, {'read': False, 'write': False, 'admin': False})\n\ndef enhanced_api_auth(required_permission: str = 'read'):\n    \"\"\"Decorator avan√ßado para autentica√ß√£o API\"\"\"\n    def decorator(f):\n        @wraps(f)\n        def decorated_function(*args, **kwargs):\n            # Verificar API key no header\n            api_key = request.headers.get('X-API-Key')\n            \n            if api_key and validate_api_key(api_key):\n                permissions = get_api_key_permissions(api_key)\n                \n                # Verificar permiss√£o requerida\n                if permissions.get(required_permission, False):\n                    # Log da requisi√ß√£o autenticada via API key\n                    try:\n                        from enhanced_logging import log_api_request\n                        log_api_request(request.path, request.method, 200, 0, {\n                            'auth_method': 'api_key',\n                            'api_key_desc': permissions['description']\n                        })\n                    except:\n                        pass\n                    \n                    return f(*args, **kwargs)\n                else:\n                    return jsonify({\n                        'success': False,\n                        'error': f'API key does not have {required_permission} permission',\n                        'timestamp': datetime.now().isoformat()\n                    }), 403\n            \n            # Fallback: verificar sess√£o ativa para usu√°rios logados\n            if 'user_id' in session:\n                try:\n                    from models import User\n                    user = User.query.get(session['user_id'])\n                    \n                    if user:\n                        # Verificar permiss√µes baseadas no role\n                        user_permissions = {\n                            'admin': {'read': True, 'write': True, 'admin': True},\n                            'operador': {'read': True, 'write': True, 'admin': False},\n                            'user': {'read': False, 'write': False, 'admin': False}\n                        }\n                        \n                        role_perms = user_permissions.get(user.role, {'read': False, 'write': False, 'admin': False})\n                        \n                        if role_perms.get(required_permission, False):\n                            # Log da requisi√ß√£o autenticada via sess√£o\n                            try:\n                                from enhanced_logging import log_api_request\n                                log_api_request(request.path, request.method, 200, 0, {\n                                    'auth_method': 'session',\n                                    'user_role': user.role,\n                                    'username': user.username\n                                })\n                            except:\n                                pass\n                            \n                            return f(*args, **kwargs)\n                        else:\n                            return jsonify({\n                                'success': False,\n                                'error': f'User role {user.role} does not have {required_permission} permission',\n                                'timestamp': datetime.now().isoformat()\n                            }), 403\n                except Exception as e:\n                    return jsonify({\n                        'success': False,\n                        'error': 'Authentication verification failed',\n                        'timestamp': datetime.now().isoformat()\n                    }), 500\n            \n            # Sem autentica√ß√£o v√°lida\n            return jsonify({\n                'success': False,\n                'error': 'API key or valid session required',\n                'hint': 'Include X-API-Key header or login via web interface',\n                'timestamp': datetime.now().isoformat()\n            }), 401\n        \n        return decorated_function\n    return decorator\n\nprint(\"üîê Sistema de seguran√ßa API carregado\")\nprint(\"üö¶ Rate limiting: 60 req/15min por IP\")\nprint(\"üîë API keys configuradas para demo/admin/readonly\")","size_bytes":8261},"app_backup.py":{"content":"from flask import Flask, render_template, request, redirect, url_for, session, send_file, abort, flash\nfrom flask_sqlalchemy import SQLAlchemy\nfrom flask_socketio import SocketIO, emit\nfrom sqlalchemy import text\nfrom sqlalchemy.orm import joinedload, selectinload\nfrom werkzeug.security import generate_password_hash, check_password_hash\nfrom werkzeug.utils import secure_filename\nfrom functools import wraps\nfrom datetime import datetime, timedelta\nimport pytz\nimport io, os, shutil\nimport psutil\nimport json\nimport sqlite3\n\n# Configure Bras√≠lia timezone (GMT-3)\nBRAZIL_TZ = pytz.timezone('America/Sao_Paulo')\n\ndef now_brazil():\n    \"\"\"Return current datetime in Brazil timezone (GMT-3)\"\"\"\n    return datetime.now(BRAZIL_TZ).replace(tzinfo=None)\nimport pandas as pd\nimport matplotlib\nmatplotlib.use(\"Agg\")\nimport matplotlib.pyplot as plt\nfrom reportlab.pdfgen import canvas\nfrom reportlab.lib.pagesizes import A4\nimport uuid\n\n# SISTEMAS DE LICENCIAMENTO REATIVADOS\ntry:\n    from backup_manager import BackupManager\n    from database_safety import DatabaseSafety  \n    from activity_logger import activity_logger, log_login, log_logout, log_admin_action, log_system_event\n    from license_manager import license_manager, is_licensed, get_license_status, check_feature_access\n    from license_generator import license_generator, create_standard_license, create_premium_license\n    backup_manager = BackupManager(\"sistema_os.db\")\n    db_safety = DatabaseSafety(\"sistema_os.db\")\n    print(\"‚úÖ Configura√ß√µes de seguran√ßa aplicadas\")\n    print(\"‚úÖ Sistemas de seguran√ßa carregados\")\n    print(\"üîê Sistema de licenciamento ativo\")\nexcept ImportError as e:\n    print(f\"‚ö†Ô∏è Sistemas de seguran√ßa n√£o carregados: {e}\")\n    backup_manager = None\n    db_safety = None\n    activity_logger = None\n    license_manager = None\n    \n    # Fun√ß√µes de fallback se n√£o conseguir carregar\n    def is_licensed():\n        return True\n\n    def get_license_status():\n        return {'licensed': True}\n\n    def check_feature_access(feature):\n        return True\n    \n    def log_login(user_id, username, ip_address=None, user_agent=None, session_id=None):\n        pass\n    \n    def log_logout(user_id, username, ip_address=None, session_id=None):\n        pass\n    \n    def log_admin_action(user_id, username, action_description, details=None):\n        pass\n    \n    def log_system_event(event_type, description, details=None):\n        pass\n\nAPP_NAME = \"Sistemas Olivium\"\n\nSETOR_CHOICES = [\"T.I\", \"Manuten√ß√£o\", \"CCIH / SESMT / Manuten√ß√£o de Ar condicionado\", \"Telefonia e outros servi√ßos\"]\n\n# Internal value mapping for sector consolidation\nSETOR_INTERNAL_VALUES = {\n    \"T.I\": \"ti\",\n    \"Manuten√ß√£o\": \"manutencao\", \n    \"CCIH / SESMT / Manuten√ß√£o de Ar condicionado\": \"ccih_sesmt_arcondicionado\",\n    \"Telefonia e outros servi√ßos\": \"telefonia_outros\"\n}\n\n# File upload configuration\nUPLOAD_FOLDER = 'static/uploads'\nALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg', 'gif'}\nMAX_FILE_SIZE = 5 * 1024 * 1024  # 5MB\n\ndef allowed_file(filename):\n    return '.' in filename and \\\n           filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\n\ndef save_uploaded_file(file):\n    \"\"\"Save uploaded file with secure name and return filename\"\"\"\n    if file and file.filename and allowed_file(file.filename):\n        # Create unique filename to prevent conflicts\n        filename_parts = file.filename.rsplit('.', 1)\n        if len(filename_parts) > 1:\n            ext = filename_parts[1].lower()\n        else:\n            ext = 'unknown'\n        filename = f\"{uuid.uuid4()}.{ext}\"\n        file.save(os.path.join(UPLOAD_FOLDER, filename))\n        return filename\n    return None\n\n# Carregar vari√°veis do arquivo .env se existir\ntry:\n    from dotenv import load_dotenv\n    load_dotenv()\nexcept ImportError:\n    pass  # dotenv n√£o instalado, continuar sem ele\n\napp = Flask(__name__)\nimport secrets\napp.secret_key = os.getenv(\"FLASK_SECRET_KEY\", secrets.token_hex(32))\n# Configura√ß√£o de banco de dados SQLite\n\n# FOR√áAR USO DE SQLITE - SEMPRE FUNCIONANDO\napp.config[\"SQLALCHEMY_DATABASE_URI\"] = \"sqlite:///sistema_os.db\"\napp.config[\"SQLALCHEMY_ENGINE_OPTIONS\"] = {\n    'pool_pre_ping': True,\n    'pool_recycle': 300,\n}\nprint(\"üóÑÔ∏è Usando SQLite para desenvolvimento...\")\n\napp.config[\"SQLALCHEMY_TRACK_MODIFICATIONS\"] = False\n\n# Performance optimization: Configure cache headers for static files\napp.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 31536000  # 1 year cache for static assets\napp.config[\"REPORT_DIR\"] = os.path.join(\"static\", \"relatorios\")\nos.makedirs(app.config[\"REPORT_DIR\"], exist_ok=True)\n\n# Ensure uploads directory exists\nos.makedirs(UPLOAD_FOLDER, exist_ok=True)\n\n# Sistema de usu√°rios online\nonline_users = set()\nuser_sessions = {}\n\n# Add datetime functions to Jinja2\n@app.template_global()\ndef now():\n    return now_brazil()\n\n# Add JSON filter to Jinja2\n@app.template_filter('fromjson')\ndef fromjson_filter(value):\n    import json\n    try:\n        return json.loads(value) if value else []\n    except:\n        return []\n\ndb = SQLAlchemy(app)\nsocketio = SocketIO(app, cors_allowed_origins=\"*\", logger=True)\n\n# Performance optimization: Add cache headers for static files\n@app.after_request\ndef add_cache_headers(response):\n    # Add cache headers for static assets to improve loading performance\n    if request.endpoint == 'static':\n        # Cache static files for 1 year\n        response.cache_control.max_age = 31536000\n        response.cache_control.public = True\n    elif request.path.endswith(('.css', '.js', '.png', '.jpg', '.jpeg', '.gif', '.ico', '.woff', '.woff2', '.ttf')):\n        # Cache other assets for 1 month\n        response.cache_control.max_age = 2592000\n        response.cache_control.public = True\n    else:\n        # No cache for dynamic pages (but allow reasonable cache for performance)\n        response.cache_control.max_age = 0\n        response.cache_control.no_cache = True\n        response.cache_control.must_revalidate = True\n    return response\n\ndef bootstrap():\n    # cria tabelas e admin/admin se n√£o existir\n    db.create_all()\n    \n    # Adicionar coluna ramal se n√£o existir\n    try:\n        db.session.execute(text('ALTER TABLE chamado ADD COLUMN ramal VARCHAR(20)'))\n        db.session.commit()\n        print(\"‚úÖ Coluna 'ramal' adicionada na tabela 'chamado'\")\n    except Exception as e:\n        if \"duplicate column name\" in str(e) or \"already exists\" in str(e):\n            print(\"‚úÖ Coluna 'ramal' j√° existe na tabela 'chamado'\")\n        else:\n            print(f\"‚ö†Ô∏è Erro ao adicionar coluna 'ramal': {e}\")\n        db.session.rollback()\n    \n    if not User.query.filter_by(username=\"admin\").first():\n        u = User(username=\"admin\", role=\"admin\", setor=None)\n        u.set_password(\"admin\")\n        db.session.add(u)\n        db.session.commit()\n\n\n# -------------------- MODELOS --------------------\n\n# New models for advanced admin functionality\nclass Sector(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    name = db.Column(db.String(100), unique=True, nullable=False)\n    display_name = db.Column(db.String(100), nullable=False)\n    description = db.Column(db.Text, nullable=True)\n    active = db.Column(db.Boolean, default=True)\n    created_at = db.Column(db.DateTime, default=now_brazil)\n\n# Many-to-many relationship table for users and sectors\nuser_sectors = db.Table('user_sectors',\n    db.Column('user_id', db.Integer, db.ForeignKey('user.id'), primary_key=True),\n    db.Column('sector_id', db.Integer, db.ForeignKey('sector.id'), primary_key=True)\n)\n    \n# Sistema de roles simplificado usando string\n\nclass SystemSettings(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    setting_key = db.Column(db.String(100), unique=True, nullable=False)\n    setting_value = db.Column(db.Text, nullable=True)\n    setting_type = db.Column(db.String(20), default='string')  # string, int, bool, json\n    description = db.Column(db.Text, nullable=True)\n    updated_at = db.Column(db.DateTime, default=now_brazil)\n\nclass User(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    username = db.Column(db.String(80), unique=True, nullable=False)\n    password_hash = db.Column(db.String(200), nullable=False)\n    role = db.Column(db.String(20), nullable=False)  # admin, operador, usuario\n    setor = db.Column(db.String(50), nullable=True)  # legacy single sector - DEPRECATED\n    # Sistema de roles simplificado usando campo string\n    # New many-to-many relationship with sectors\n    sectors = db.relationship('Sector', secondary=user_sectors, backref='users', lazy=True)\n\n    def set_password(self, password):\n        self.password_hash = generate_password_hash(password)\n\n    def check_password(self, password):\n        return check_password_hash(self.password_hash, password)\n        \n    def has_permission(self, permission):\n        \"\"\"Check if user has specific permission\"\"\"\n        if self.role == 'admin':  # Admin always has all permissions\n            return True\n            \n        # Check custom roles from Role table FIRST (they take precedence)\n        custom_role = Role.query.filter_by(name=self.role, active=True).first()\n        if custom_role:\n            return custom_role.has_permission(permission)\n            \n        # Check basic built-in roles\n        if self.role == 'operador':\n            # Operators can view and update tickets\n            return permission in ['view_tickets', 'update_tickets', 'create_tickets', 'view_sector', 'edit_sector', 'close_tickets', 'view_reports', 'edit_tickets', 'delete_tickets']\n        elif self.role == 'usuario':\n            # Users can only view and create their own tickets\n            return permission in ['view_own_tickets', 'create_tickets', 'view_own']\n        \n        # Fallback to legacy role-based permissions for unknown roles\n        legacy_permissions = {\n            'admin': ['view_all', 'edit_all', 'delete_all', 'manage_users', 'manage_sectors', 'manage_roles', 'view_reports', 'manage_settings', 'close_tickets', 'create_tickets', 'admin_access', 'edit_tickets', 'delete_tickets'],\n            'operador': ['view_sector', 'edit_sector', 'close_tickets', 'create_tickets', 'view_reports', 'edit_tickets', 'delete_tickets'],\n            'usuario': ['create_tickets', 'view_own']\n        }\n        \n        role_perms = legacy_permissions.get(self.role, [])\n        return permission in role_perms\n        \n    def is_admin(self):\n        \"\"\"Check if user is admin (built-in admin or custom role with admin permissions)\"\"\"\n        if self.role == 'admin':\n            return True\n        return self.has_permission('admin_access')\n        \n    def is_operator_like(self):\n        \"\"\"Check if user has operator-like permissions (built-in operador or custom role with operator permissions)\"\"\"\n        if self.role == 'operador':\n            return True\n        return self.has_permission('view_sector') or self.has_permission('edit_sector')\n        \n    def can_access_sector(self, sector_name):\n        \"\"\"Check if user can access tickets from a specific sector\"\"\"\n        if self.is_admin():\n            return True\n        if self.is_operator_like():\n            return self.has_sector_access(sector_name)\n        return False\n        \n    def get_sectors(self):\n        \"\"\"Get all sectors user has access to\"\"\"\n        if self.role == 'admin':  # Admin sees all sectors\n            return Sector.query.filter_by(active=True).all()\n        elif self.sectors:\n            return [s for s in self.sectors if s.active]\n        elif self.setor:  # Legacy single sector\n            sector = Sector.query.filter_by(name=self.setor, active=True).first()\n            return [sector] if sector else []\n        return []\n    \n    def get_sector_names(self):\n        \"\"\"Get list of sector names user has access to\"\"\"\n        return [s.name for s in self.get_sectors()]\n    \n    def has_sector_access(self, sector_name):\n        \"\"\"Check if user has access to a specific sector\"\"\"\n        if self.role == 'admin':\n            return True\n        return sector_name in self.get_sector_names()\n    \n    def assign_sectors(self, sector_ids):\n        \"\"\"Assign multiple sectors to user\"\"\"\n        # Clear existing sectors\n        self.sectors.clear()\n        # Add new sectors\n        if sector_ids:\n            sectors = Sector.query.filter(Sector.id.in_(sector_ids)).all()\n            self.sectors.extend(sectors)\n        # Update legacy setor field for backward compatibility\n        if self.sectors:\n            self.setor = self.sectors[0].name\n        else:\n            self.setor = None\n\nclass Chamado(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    titulo = db.Column(db.String(200), nullable=False)\n    descricao = db.Column(db.Text, nullable=False)\n    status = db.Column(db.String(20), default=\"Aberto\")  # Aberto, Em Andamento, Fechado\n    criado_em = db.Column(db.DateTime, default=now_brazil)  # hor√°rio de Bras√≠lia (GMT-3)\n    fechado_em = db.Column(db.DateTime, nullable=True)\n    resolucao = db.Column(db.Text, nullable=True)\n    setor = db.Column(db.String(50), nullable=True)\n    usuario_setor = db.Column(db.String(50), nullable=True)  # setor do usu√°rio que abriu o chamado\n    urgencia = db.Column(db.String(20), nullable=True)  # Urgente, N√£o Urgente (apenas quando fechado)\n    ramal = db.Column(db.String(20), nullable=True)  # n√∫mero do ramal do usu√°rio\n    cdc = db.Column(db.String(50), nullable=True)  # Campo para CDC (Centro de Custo)\n    \n    # Image attachments\n    imagem1 = db.Column(db.String(255), nullable=True)  # Path to first image\n    imagem2 = db.Column(db.String(255), nullable=True)  # Path to second image\n    imagem3 = db.Column(db.String(255), nullable=True)  # Path to third image\n\n    usuario_id = db.Column(db.Integer, db.ForeignKey(\"user.id\"))        # quem abriu\n    usuario = db.relationship(\"User\", foreign_keys=[usuario_id])\n\n    fechado_por_id = db.Column(db.Integer, db.ForeignKey(\"user.id\"))    # quem fechou\n    fechado_por = db.relationship(\"User\", foreign_keys=[fechado_por_id])\n    \n    def get_images(self):\n        \"\"\"Return list of image paths that exist\"\"\"\n        images = []\n        for img_field in [self.imagem1, self.imagem2, self.imagem3]:\n            if img_field:\n                images.append(img_field)\n        return images\n\nclass Role(db.Model):\n    \"\"\"Role model for advanced permissions system\"\"\"\n    __tablename__ = 'role'\n    \n    id = db.Column(db.Integer, primary_key=True)\n    name = db.Column(db.String(50), unique=True, nullable=False, index=True)\n    display_name = db.Column(db.String(100), nullable=False)\n    description = db.Column(db.Text, nullable=True)\n    permissions = db.Column(db.Text, nullable=True)  # JSON string\n    active = db.Column(db.Boolean, default=True, nullable=False)\n    created_at = db.Column(db.DateTime, default=now_brazil)\n    updated_at = db.Column(db.DateTime, default=now_brazil, onupdate=now_brazil)\n    \n    def __repr__(self):\n        return f'<Role {self.name}: {self.display_name}>'\n    \n    def get_permissions(self):\n        \"\"\"Return list of permissions\"\"\"\n        import json\n        try:\n            return json.loads(self.permissions) if self.permissions else []\n        except:\n            return []\n    \n    def has_permission(self, permission):\n        \"\"\"Check if role has specific permission\"\"\"\n        perms = self.get_permissions()\n        return permission in perms\n\n# -------------------- HELPERS DE AUTENTICA√á√ÉO --------------------\ndef login_required(f):\n    @wraps(f)\n    def wrapper(*args, **kwargs):\n        # Verificar licen√ßa primeiro (REATIVADO COMO ANTES)\n        if license_manager:\n            license_status = get_license_status()\n            if not license_status['licensed']:\n                if license_status.get('status') == 'expired':\n                    return render_template(\"license/expired.html\", \n                                         app_name=APP_NAME, \n                                         license_status=license_status)\n                else:\n                    return redirect(url_for(\"license_activation\"))\n        \n        if \"user_id\" not in session:\n            return redirect(url_for(\"login\"))\n        return f(*args, **kwargs)\n    return wrapper\n\ndef roles_required(*roles):\n    def deco(f):\n        @wraps(f)\n        def wrapper(*args, **kwargs):\n            if \"user_id\" not in session:\n                return redirect(url_for(\"login\"))\n            u = db.session.get(User, session[\"user_id\"])\n            if not u or u.role not in roles:\n                return abort(403)\n            return f(*args, **kwargs)\n        return wrapper\n    return deco\n\ndef permission_required(*permissions):\n    \"\"\"Decorator to check specific permissions instead of roles\"\"\"\n    def deco(f):\n        @wraps(f)\n        def wrapper(*args, **kwargs):\n            if \"user_id\" not in session:\n                return redirect(url_for(\"login\"))\n            u = db.session.get(User, session[\"user_id\"])\n            if not u:\n                return abort(403)\n            \n            # Check if user has ANY of the required permissions\n            has_permission = False\n            for permission in permissions:\n                if u.has_permission(permission):\n                    has_permission = True\n                    break\n                    \n            if not has_permission:\n                return abort(403)\n            return f(*args, **kwargs)\n        return wrapper\n    return deco\n\ndef current_user():\n    if \"user_id\" in session:\n        try:\n            user = db.session.get(User, session[\"user_id\"])\n            if user:\n                # Refresh user sectors in session for immediate effect\n                session['user_sectors'] = user.get_sector_names()\n                session['user_role'] = user.role\n                return user\n        except Exception as e:\n            print(f\"Error getting current user: {e}\")\n            # Try with basic columns only\n            try:\n                with db.engine.connect() as conn:\n                    # Fallback query compat√≠vel com SQLite\n                    result = conn.execute(text('SELECT id, username, password_hash, role FROM user WHERE id = :user_id'), {\"user_id\": session[\"user_id\"]})\n                    row = result.fetchone()\n                    if row:\n                        user = User()\n                        user.id = row[0]\n                        user.username = row[1] \n                        user.password_hash = row[2]\n                        user.role = row[3]\n                        return user\n            except Exception as e2:\n                print(f\"Error with fallback query: {e2}\")\n    return None\n\n# -------------------- CRIA DB E USU√ÅRIOS PADR√ÉO --------------------\n\ndef ensure_columns():\n    # garante colunas 'setor' em user e chamado (SQLite) e novas colunas para admin menu\n    try:\n        import sqlite3\n        db_path = os.path.join(app.root_path, \"sistema_os.db\")\n        if not os.path.exists(db_path):\n            db_path = \"sistema_os.db\"\n        conn = sqlite3.connect(db_path)\n        cur = conn.cursor()\n        def has_col(table, col):\n            cur.execute(f'PRAGMA table_info({table})')\n            return any(r[1] == col for r in cur.fetchall())\n        \n        # Legacy columns\n        if not has_col(\"user\", \"setor\"):\n            cur.execute(\"ALTER TABLE user ADD COLUMN setor VARCHAR(50)\")\n        if not has_col(\"chamado\", \"setor\"):\n            cur.execute(\"ALTER TABLE chamado ADD COLUMN setor VARCHAR(50)\")\n        if not has_col(\"chamado\", \"usuario_setor\"):\n            cur.execute(\"ALTER TABLE chamado ADD COLUMN usuario_setor VARCHAR(50)\")\n        if not has_col(\"chamado\", \"urgencia\"):\n            cur.execute(\"ALTER TABLE chamado ADD COLUMN urgencia VARCHAR(20)\")\n            \n        # New columns for admin menu functionality\n        if not has_col(\"user\", \"role_id\"):\n            cur.execute(\"ALTER TABLE user ADD COLUMN role_id INTEGER\")\n        if not has_col(\"user\", \"active\"):\n            cur.execute(\"ALTER TABLE user ADD COLUMN active BOOLEAN DEFAULT 1\")\n        if not has_col(\"user\", \"created_at\"):\n            cur.execute(\"ALTER TABLE user ADD COLUMN created_at DATETIME\")\n            \n        conn.commit()\n        conn.close()\n    except Exception as e:\n        print(\"Aviso: n√£o consegui garantir colunas de setor:\", e)\n\ndef initialize_system():\n    \"\"\"Initialize database tables, default data, and migrate existing data\"\"\"\n    with app.app_context():\n        # First create basic tables\n        db.create_all()\n        # Then ensure columns exist with migration\n        ensure_columns()\n        \n        # Create default users with simple approach first\n        def ensure_user(username, role, pwd):\n            try:\n                # Check if user exists using raw SQL to avoid ORM issues\n                with db.engine.begin() as conn:\n                    result = conn.execute(text(\"SELECT COUNT(*) FROM user WHERE username = :username\"), {\"username\": username})\n                    count = result.scalar()\n                    \n                    if count == 0:\n                        # Create user with basic columns\n                        conn.execute(text(\"INSERT INTO user (username, password_hash, role) VALUES (:username, :password_hash, :role)\"), \n                                   {\"username\": username, \"password_hash\": generate_password_hash(pwd), \"role\": role})\n                        print(f\"Created user {username}\")\n                    else:\n                        print(f\"User {username} already exists\")\n                        \n            except Exception as e:\n                print(f\"Error creating user {username}: {e}\")\n        \n        ensure_user(\"admin\", \"admin\", \"admin\")\n        ensure_user(\"operador\", \"operador\", \"operador\")\n        ensure_user(\"usuario\", \"usuario\", \"usuario\")\n        \n        print(\"Basic users created successfully\")\n        \n        # Initialize custom roles\n        try:\n            # Create semigerente role if it doesn't exist\n            semigerente = Role.query.filter_by(name='semigerente').first()\n            if not semigerente:\n                semigerente = Role(\n                    name='semigerente',\n                    display_name='Semi Gerente',\n                    description='Acesso completo a todas as funcionalidades',\n                    active=True,\n                    permissions='view_all,edit_all,delete_all,manage_users,manage_sectors,view_reports,manage_settings,close_tickets,create_tickets,admin_access,edit_tickets,delete_tickets,view_tickets,update_tickets,view_sector,edit_sector'\n                )\n                db.session.add(semigerente)\n                print(\"üîê Papel 'semigerente' criado com todas as permiss√µes\")\n            \n            # Create semioperador role if it doesn't exist  \n            semioperador = Role.query.filter_by(name='semioperador').first()\n            if not semioperador:\n                semioperador = Role(\n                    name='semioperador',\n                    display_name='Semi Operador',\n                    description='Acesso somente a relat√≥rios para visualiza√ß√£o',\n                    active=True,\n                    permissions='view_reports,view_tickets,view_sector'\n                )\n                db.session.add(semioperador)\n                print(\"üîê Papel 'semioperador' criado com permiss√µes de relat√≥rios\")\n                \n            db.session.commit()\n            print(\"Custom roles initialized successfully\")\n            \n        except Exception as e:\n            print(f\"‚ùå Erro ao criar pap√©is customizados: {e}\")\n            db.session.rollback()\n\n# Initialize system on import (disabled - using manual DB init)\n# initialize_system()\n\n@app.route(\"/admin/init-system\")\n@login_required\ndef admin_init_system():\n    \"\"\"Manual initialization of custom roles (admin only)\"\"\"\n    u = current_user()\n    if not u.is_admin():\n        abort(403)\n    \n    try:\n        initialize_system()\n        flash(\"Sistema inicializado com sucesso! Pap√©is customizados criados.\", \"success\")\n    except Exception as e:\n        flash(f\"Erro na inicializa√ß√£o: {e}\", \"danger\")\n    \n    return redirect(url_for(\"index\"))\n\n# -------------------- ROTAS DE AUTENTICA√á√ÉO --------------------\n@app.route(\"/login\", methods=[\"GET\", \"POST\"])\ndef login():\n    if request.method == \"POST\":\n        username = request.form.get(\"username\",\"\").strip()\n        password = request.form.get(\"password\",\"\")\n        user = User.query.filter_by(username=username).first()\n        if user and user.check_password(password):\n            # Check if user is active (disabled - column doesn't exist in current schema)\n            # This check was causing SQL errors and reducing performance\n            # Future: Add 'active' column if user activation/deactivation is needed\n            pass\n            \n            session[\"user_id\"] = user.id\n            \n            # Rastrear usu√°rio online\n            online_users.add(user.id)\n            user_sessions[user.id] = {\n                'login_time': datetime.now(),\n                'last_activity': datetime.now(),\n                'username': user.username\n            }\n            \n            # Log da atividade\n            if activity_logger:\n                log_login(user.id, user.username)\n            \n            return redirect(url_for(\"index\"))\n        flash(\"Usu√°rio ou senha incorretos.\", \"danger\")\n    return render_template(\"login.html\", app_name=APP_NAME)\n\n@app.route(\"/logout\")\n@login_required\ndef logout():\n    # Rastrear sa√≠da do usu√°rio\n    user_id = session.get(\"user_id\")\n    if user_id:\n        # Remover usu√°rio da lista de online\n        online_users.discard(user_id)\n        if user_id in user_sessions:\n            username = user_sessions[user_id].get('username', 'Usu√°rio')\n            del user_sessions[user_id]\n            # Log da atividade\n            if activity_logger:\n                log_logout(user_id, username)\n    \n    session.clear()\n    return redirect(url_for(\"login\"))\n\n# -------------------- ROTAS PRINCIPAIS --------------------\n@app.route(\"/\")\n@login_required\ndef index():\n    u = current_user()\n    \n    # Se n√£o conseguiu obter usu√°rio atual, redirecionar para login\n    if not u or not hasattr(u, 'role'):\n        session.clear()\n        return redirect(url_for(\"login\"))\n    \n    # Get sort parameter from URL (default: asc for ascending order)\n    sort_order = request.args.get('sort', 'asc')\n    \n    # Determine sort order (asc = crescente/oldest first, desc = decrescente/newest first)\n    if sort_order == 'desc':\n        order_by_clause = Chamado.criado_em.desc()\n        next_sort = 'asc'\n        sort_label = 'Recentes Primeiro'\n        sort_icon = 'bi bi-arrow-down'\n    else:\n        order_by_clause = Chamado.criado_em.asc()\n        next_sort = 'desc'\n        sort_label = 'Antigos Primeiro'\n        sort_icon = 'bi bi-arrow-up'\n    \n    # Optimize database queries with eager loading to prevent N+1 problems\n    base_query = Chamado.query.options(\n        joinedload(Chamado.usuario),\n        joinedload(Chamado.fechado_por)\n    )\n    \n    if u.is_admin():\n        # Admin sees all tickets\n        chamados = base_query.order_by(order_by_clause).all()\n    elif u.has_permission('view_all'):\n        # Users with view_all permission (like semigerente) see all tickets\n        chamados = base_query.order_by(order_by_clause).all()\n    elif u.is_operator_like():\n        # Operators and operator-like roles see tickets from their assigned sectors only\n        user_sector_names = u.get_sector_names()\n        if user_sector_names:\n            chamados = base_query.filter(Chamado.setor.in_(user_sector_names)).order_by(order_by_clause).all()\n        else:\n            chamados = []  # No sectors assigned, no tickets visible\n    else:\n        # Regular users see only their own tickets\n        chamados = base_query.filter_by(usuario_id=u.id).order_by(order_by_clause).all()\n    \n    return render_template(\"index.html\", \n                         app_name=APP_NAME, \n                         user=u, \n                         chamados=chamados,\n                         sort_order=sort_order,\n                         next_sort=next_sort,\n                         sort_label=sort_label,\n                         sort_icon=sort_icon)\n\n# -------------------- USU√ÅRIOS (ADMIN) --------------------\n@app.route(\"/usuarios\")\n@login_required\n@roles_required(\"admin\")\ndef usuarios_list():\n    users = User.query.order_by(User.username).all()\n    return render_template(\"usuarios_list.html\", app_name=APP_NAME, user=current_user(), users=users)\n\n@app.route(\"/usuarios/novo\", methods=[\"GET\",\"POST\"])\n@login_required\n@roles_required(\"admin\")\ndef usuarios_novo():\n    if request.method == \"POST\":\n        username = request.form[\"username\"].strip()\n        password = request.form[\"password\"]\n        role = request.form[\"role\"]\n        if not username or not password:\n            flash(\"Preencha usu√°rio e senha.\", \"warning\")\n            return redirect(url_for(\"usuarios_novo\"))\n        if User.query.filter_by(username=username).first():\n            flash(\"Usu√°rio j√° existe.\", \"danger\")\n            return redirect(url_for(\"usuarios_novo\"))\n        \n        u = User(username=username, role=role)\n        u.set_password(password)\n        db.session.add(u)\n        \n        # Handle sector assignment\n        sector_ids = request.form.getlist('sector_ids')\n        legacy_setor = request.form.get('setor')\n        \n        if sector_ids:\n            sector_ids = [int(id) for id in sector_ids if id.isdigit()]\n            u.assign_sectors(sector_ids)\n        elif legacy_setor:\n            sector = Sector.query.filter_by(name=legacy_setor).first()\n            if sector:\n                u.assign_sectors([sector.id])\n            else:\n                u.setor = legacy_setor\n        \n        # Validate operator sector assignment\n        if role == 'operador' and not u.get_sectors():\n            flash(\"Operadores devem ter pelo menos um setor atribu√≠do.\", \"warning\")\n            # Buscar setores para o template\n            try:\n                sectors = Sector.query.filter_by(active=True).order_by(Sector.display_name).all()\n            except:\n                sectors = []\n            return render_template(\"usuarios_form.html\", app_name=APP_NAME, user=current_user(), u=None, sectors=sectors)\n        \n        db.session.commit()\n        flash(\"Usu√°rio criado.\", \"success\")\n        return redirect(url_for(\"usuarios_list\"))\n    \n    # Buscar setores para o template\n    try:\n        sectors = Sector.query.filter_by(active=True).order_by(Sector.display_name).all()\n    except:\n        sectors = []\n    return render_template(\"usuarios_form.html\", app_name=APP_NAME, user=current_user(), u=None, sectors=sectors)\n\n@app.route(\"/usuarios/editar/<int:user_id>\", methods=[\"GET\",\"POST\"])\n@login_required\n@roles_required(\"admin\")\ndef usuarios_editar(user_id):\n    u = db.session.get(User, user_id) or abort(404)\n    if request.method == \"POST\":\n        u.username = request.form[\"username\"].strip()\n        new_pwd = request.form.get(\"password\",\"\").strip()\n        u.role = request.form[\"role\"]\n        \n        # Handle both legacy single sector and new multi-sector assignment\n        sector_ids = request.form.getlist('sector_ids')\n        legacy_setor = request.form.get('setor')\n        \n        if sector_ids:\n            # New multi-sector system\n            sector_ids = [int(id) for id in sector_ids if id.isdigit()]\n            u.assign_sectors(sector_ids)\n        elif legacy_setor:\n            # Legacy single sector system - find sector by name and assign\n            sector = Sector.query.filter_by(name=legacy_setor).first()\n            if sector:\n                u.assign_sectors([sector.id])\n            else:\n                u.setor = legacy_setor  # Fallback for backward compatibility\n        else:\n            # Clear sectors\n            u.assign_sectors([])\n        \n        # Validate operator sector assignment\n        if u.is_operator_like() and not u.is_admin() and not u.get_sectors():\n            flash(\"Operadores devem ter pelo menos um setor atribu√≠do.\", \"warning\")\n            # Buscar setores para o template\n            try:\n                sectors = Sector.query.filter_by(active=True).order_by(Sector.display_name).all()\n            except:\n                sectors = []\n            return render_template(\"usuarios_form.html\", app_name=APP_NAME, user=current_user(), u=u, sectors=sectors)\n        \n        if new_pwd:\n            u.set_password(new_pwd)\n        \n        # Force session refresh for currently logged in user\n        if u.id == session.get('user_id'):\n            session['user_sectors'] = u.get_sector_names()\n            session['user_role'] = u.role\n        \n        db.session.commit()\n        flash(\"Usu√°rio atualizado.\", \"success\")\n        return redirect(url_for(\"usuarios_list\"))\n    \n    # Buscar setores para o template\n    try:\n        sectors = Sector.query.filter_by(active=True).order_by(Sector.display_name).all()\n    except:\n        sectors = []\n    return render_template(\"usuarios_form.html\", app_name=APP_NAME, user=current_user(), u=u, sectors=sectors)\n\n@app.route(\"/usuarios/excluir/<int:user_id>\")\n@login_required\n@roles_required(\"admin\")\ndef usuarios_excluir(user_id):\n    if user_id == session.get(\"user_id\"):\n        flash(\"Voc√™ n√£o pode excluir a si mesmo.\", \"warning\")\n        return redirect(url_for(\"usuarios_list\"))\n    u = db.session.get(User, user_id) or abort(404)\n    db.session.delete(u)\n    db.session.commit()\n    flash(\"Usu√°rio exclu√≠do.\", \"success\")\n    return redirect(url_for(\"usuarios_list\"))\n\n# -------------------- CHAMADOS --------------------\n@app.route(\"/chamados/novo\", methods=[\"GET\",\"POST\"])\n@login_required\ndef chamados_novo():\n    u = current_user()\n    if request.method == \"POST\":\n        titulo = request.form[\"titulo\"].strip()\n        descricao = request.form[\"descricao\"].strip()\n        if not titulo or not descricao:\n            flash(\"Informe t√≠tulo e descri√ß√£o.\", \"warning\")\n            return redirect(url_for(\"chamados_novo\"))\n        usuario_setor = request.form.get('usuario_setor')\n        if not usuario_setor:\n            flash(\"Informe seu setor.\", \"warning\")\n            return redirect(url_for(\"chamados_novo\"))\n        ramal = request.form.get('ramal', '').strip()\n        cdc = request.form.get('cdc', '').strip()\n        \n        # Valida√ß√£o CDC para setor COMPRAS\n        setor_selecionado = request.form.get('setor', '').strip()\n        if setor_selecionado and ('COMPRAS' in setor_selecionado.upper() or 'COMPRA' in setor_selecionado.upper()):\n            if not cdc:\n                flash(\"Para o setor COMPRAS √© obrigat√≥rio informar o CDC. Caso n√£o tenha na sua OS, a mesma ser√° invalidada.\", \"error\")\n                return redirect(url_for(\"chamados_novo\"))\n        \n        c = Chamado(titulo=titulo, descricao=descricao, usuario_id=u.id, status=\"Aberto\", setor=request.form.get('setor'), usuario_setor=usuario_setor, ramal=ramal, cdc=cdc)\n        \n        # Handle image uploads\n        for i in range(1, 4):  # imagem1, imagem2, imagem3\n            file = request.files.get(f'imagem{i}')\n            if file:\n                filename = save_uploaded_file(file)\n                if filename:\n                    setattr(c, f'imagem{i}', filename)\n        \n        db.session.add(c)\n        db.session.commit()\n        # Emit WebSocket event for new ticket\n        emit_ticket_update(ticket_to_dict(c), 'created')\n        flash(\"Chamado criado.\", \"success\")\n        return redirect(url_for(\"index\"))\n    \n    # Get dynamic sectors for the form\n    try:\n        sectors = Sector.query.filter_by(active=True).order_by(Sector.display_name).all()\n    except:\n        # Fallback to default sectors if table doesn't exist yet\n        sectors = [\n            {'name': 'ti', 'display_name': 'T.I'},\n            {'name': 'manutencao', 'display_name': 'Manuten√ß√£o'},\n            {'name': 'ccih', 'display_name': 'CCIH / SESMT / Manuten√ß√£o de Ar condicionado'},\n            {'name': 'telefonia', 'display_name': 'Telefonia e outros servi√ßos'}\n        ]\n    \n    return render_template(\"chamado_form.html\", app_name=APP_NAME, user=u, chamado=None, sectors=sectors)\n\n@app.route(\"/chamados/editar/<int:cid>\", methods=[\"GET\",\"POST\"])\n@login_required\ndef chamados_editar(cid):\n    u = current_user()\n    c = db.session.get(Chamado, cid) or abort(404)\n    # permiss√µes atualizadas: apenas admin pode editar\n    if not u.is_admin():\n        abort(403)\n    if request.method == \"POST\":\n        old_status = c.status\n        c.titulo = request.form[\"titulo\"].strip()\n        c.descricao = request.form[\"descricao\"].strip()\n        c.status = request.form.get(\"status\", c.status)\n        # Update sector if provided\n        setor = request.form.get(\"setor\")\n        if setor:\n            c.setor = setor\n        \n        # Update CDC field\n        cdc = request.form.get('cdc', '').strip()\n        c.cdc = cdc\n        \n        # Valida√ß√£o CDC para setor COMPRAS na edi√ß√£o\n        if c.setor and ('COMPRAS' in c.setor.upper() or 'COMPRA' in c.setor.upper()):\n            if not cdc:\n                flash(\"Para o setor COMPRAS √© obrigat√≥rio informar o CDC. Caso n√£o tenha na sua OS, a mesma ser√° invalidada.\", \"error\")\n                # Get dynamic sectors for the form in case of error\n                try:\n                    sectors = Sector.query.filter_by(active=True).order_by(Sector.display_name).all()\n                except:\n                    sectors = [\n                        {'name': 'ti', 'display_name': 'T.I'},\n                        {'name': 'manutencao', 'display_name': 'Manuten√ß√£o'},\n                        {'name': 'ccih', 'display_name': 'CCIH / SESMT / Manuten√ß√£o de Ar condicionado'},\n                        {'name': 'telefonia', 'display_name': 'Telefonia e outros servi√ßos'}\n                    ]\n                return render_template(\"chamado_form.html\", app_name=APP_NAME, user=u, chamado=c, sectors=sectors)\n        \n        # Handle image uploads and removals\n        for i in range(1, 4):  # imagem1, imagem2, imagem3\n            # Check if user wants to remove existing image\n            if request.form.get(f'remover_imagem{i}'):\n                old_image = getattr(c, f'imagem{i}')\n                if old_image:\n                    # Delete file from filesystem\n                    try:\n                        os.remove(os.path.join(UPLOAD_FOLDER, old_image))\n                    except:\n                        pass  # File might not exist\n                setattr(c, f'imagem{i}', None)\n            \n            # Handle new image upload\n            file = request.files.get(f'imagem{i}')\n            if file:\n                filename = save_uploaded_file(file)\n                if filename:\n                    # Remove old image if replacing\n                    old_image = getattr(c, f'imagem{i}')\n                    if old_image:\n                        try:\n                            os.remove(os.path.join(UPLOAD_FOLDER, old_image))\n                        except:\n                            pass\n                    setattr(c, f'imagem{i}', filename)\n        \n        db.session.commit()\n        # Emit WebSocket event for ticket update\n        event_type = 'status_changed' if old_status != c.status else 'updated'\n        emit_ticket_update(ticket_to_dict(c), event_type)\n        flash(\"Chamado atualizado.\", \"success\")\n        return redirect(url_for(\"index\"))\n    \n    # Get dynamic sectors for the form\n    try:\n        sectors = Sector.query.filter_by(active=True).order_by(Sector.display_name).all()\n    except:\n        # Fallback to default sectors if table doesn't exist yet\n        sectors = [\n            {'name': 'ti', 'display_name': 'T.I'},\n            {'name': 'manutencao', 'display_name': 'Manuten√ß√£o'},\n            {'name': 'ccih', 'display_name': 'CCIH / SESMT / Manuten√ß√£o de Ar condicionado'},\n            {'name': 'telefonia', 'display_name': 'Telefonia e outros servi√ßos'}\n        ]\n    \n    return render_template(\"chamado_form.html\", app_name=APP_NAME, user=u, chamado=c, sectors=sectors)\n\n@app.route(\"/chamados/fechar/<int:cid>\", methods=[\"GET\",\"POST\"])\n@login_required\ndef chamados_fechar(cid):\n    u = current_user()\n    c = db.session.get(Chamado, cid) or abort(404)\n    # admin/operador podem fechar, operador apenas do seu setor\n    if not (u.is_admin() or u.is_operator_like()):\n        abort(403)\n    if u.is_operator_like() and not u.is_admin() and c.setor and not u.can_access_sector(c.setor):\n        abort(403)\n    if request.method == \"POST\":\n        urgencia = request.form.get(\"urgencia\")\n        if not urgencia or urgencia not in [\"Urgente\", \"N√£o Urgente\"]:\n            flash(\"√â obrigat√≥rio selecionar a classifica√ß√£o de urg√™ncia.\", \"error\")\n            return render_template(\"chamado_fechar.html\", app_name=APP_NAME, user=u, chamado=c)\n        \n        c.status = \"Fechado\"\n        c.fechado_em = now_brazil()\n        c.resolucao = request.form[\"resolucao\"].strip()\n        c.urgencia = urgencia\n        c.fechado_por_id = u.id\n        db.session.commit()\n        # Emit WebSocket event for ticket closure\n        emit_ticket_update(ticket_to_dict(c), 'closed')\n        flash(\"Chamado fechado.\", \"success\")\n        return redirect(url_for(\"index\"))\n    return render_template(\"chamado_fechar.html\", app_name=APP_NAME, user=u, chamado=c)\n\n@app.route(\"/chamados/excluir/<int:cid>\")\n@login_required\ndef chamados_excluir(cid):\n    u = current_user()\n    c = db.session.get(Chamado, cid) or abort(404)\n    # apenas admin pode excluir\n    if not u.is_admin():\n        abort(403)\n    db.session.delete(c)\n    db.session.commit()\n    flash(\"Chamado exclu√≠do.\", \"success\")\n    return redirect(url_for(\"index\"))\n\n# -------------------- VIEW TICKET --------------------\n@app.route(\"/chamados/view/<int:cid>\")\n@login_required\ndef chamados_view(cid):\n    u = current_user()\n    c = db.session.get(Chamado, cid) or abort(404)\n    \n    # Permiss√µes: admin v√™ tudo, operador v√™ do seu setor, usu√°rio v√™ apenas os seus\n    if not u.is_admin() and not u.has_permission('view_all'):\n        if u.is_operator_like() and c.setor and not u.can_access_sector(c.setor):\n            abort(403)\n        elif not u.is_operator_like() and c.usuario_id != u.id:\n            abort(403)\n    \n    return render_template(\"chamado_view.html\", app_name=APP_NAME, user=u, chamado=c)\n\n# -------------------- ADMIN UTIL --------------------\n@app.route(\"/admin/backup\")\n@login_required\n@roles_required(\"admin\")\ndef admin_backup():\n    # envia o arquivo sqlite para download\n    db_path = os.path.join(app.root_path, \"sistema_os.db\")\n    if not os.path.exists(db_path):\n        # tamb√©m pode estar relativo\n        db_path = \"sistema_os.db\"\n    if not os.path.exists(db_path):\n        flash(\"Banco de dados n√£o encontrado.\", \"danger\")\n        return redirect(url_for(\"index\"))\n    return send_file(db_path, as_attachment=True, download_name=\"sistema_os_backup.sqlite\")\n\n# -------------------- DATABASE MANAGEMENT --------------------\n@app.route(\"/admin/database/export\")\n@login_required\n@roles_required(\"admin\")\ndef admin_database_export():\n    \"\"\"Exportar banco de dados principal\"\"\"\n    try:\n        # Criar backup antes da exporta√ß√£o\n        from datetime import datetime\n        timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n        \n        db_path = \"sistema_os.db\"\n        if not os.path.exists(db_path):\n            flash(\"Banco de dados n√£o encontrado.\", \"danger\")\n            return redirect(url_for(\"admin_settings\"))\n        \n        # Nome do arquivo com timestamp\n        download_name = f\"sistema_os_export_{timestamp}.db\"\n        \n        return send_file(db_path, as_attachment=True, download_name=download_name, mimetype='application/x-sqlite3')\n    except Exception as e:\n        flash(f\"Erro ao exportar banco de dados: {str(e)}\", \"danger\")\n        return redirect(url_for(\"admin_settings\"))\n\n@app.route(\"/admin/database/import\", methods=[\"POST\"])\n@login_required\n@roles_required(\"admin\")\ndef admin_database_import():\n    \"\"\"Importar banco de dados\"\"\"\n    try:\n        # Verificar se arquivo foi enviado\n        if 'database_file' not in request.files:\n            flash(\"Nenhum arquivo selecionado.\", \"danger\")\n            return redirect(url_for(\"admin_settings\"))\n        \n        file = request.files['database_file']\n        if file.filename == '':\n            flash(\"Nenhum arquivo selecionado.\", \"danger\")\n            return redirect(url_for(\"admin_settings\"))\n        \n        # Verificar confirma√ß√£o\n        if not request.form.get('confirm_import'):\n            flash(\"√â necess√°rio confirmar a importa√ß√£o.\", \"danger\")\n            return redirect(url_for(\"admin_settings\"))\n        \n        # Verificar extens√£o do arquivo\n        allowed_extensions = {'.db', '.sqlite', '.sqlite3'}\n        file_ext = os.path.splitext(file.filename)[1].lower()\n        if file_ext not in allowed_extensions:\n            flash(\"Tipo de arquivo n√£o permitido. Use apenas .db, .sqlite ou .sqlite3\", \"danger\")\n            return redirect(url_for(\"admin_settings\"))\n        \n        # Criar backup do banco atual antes da importa√ß√£o\n        from datetime import datetime\n        timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n        backup_path = f\"backup_before_import_{timestamp}.db\"\n        \n        import shutil\n        if os.path.exists(\"sistema_os.db\"):\n            shutil.copy2(\"sistema_os.db\", backup_path)\n            print(f\"Backup criado: {backup_path}\")\n        \n        # Salvar arquivo tempor√°rio\n        temp_path = f\"temp_import_{timestamp}.db\"\n        file.save(temp_path)\n        \n        # Validar se √© um banco SQLite v√°lido\n        import sqlite3\n        try:\n            test_conn = sqlite3.connect(temp_path)\n            test_conn.execute(\"SELECT name FROM sqlite_master WHERE type='table'\")\n            test_conn.close()\n        except sqlite3.Error as e:\n            os.remove(temp_path)\n            flash(f\"Arquivo n√£o √© um banco SQLite v√°lido: {str(e)}\", \"danger\")\n            return redirect(url_for(\"admin_settings\"))\n        \n        # Fechar conex√µes do SQLAlchemy\n        db.session.close()\n        db.engine.dispose()\n        \n        # Substituir banco atual\n        if os.path.exists(\"sistema_os.db\"):\n            os.remove(\"sistema_os.db\")\n        \n        shutil.move(temp_path, \"sistema_os.db\")\n        \n        # Recriar conex√£o\n        from sqlalchemy import create_engine\n        app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///sistema_os.db'\n        db.engine = create_engine(app.config['SQLALCHEMY_DATABASE_URI'])\n        \n        flash(f\"Banco de dados importado com sucesso! Backup salvo como: {backup_path}\", \"success\")\n        \n        # Redirecionar para login pois pode ter mudado usu√°rios\n        session.clear()\n        return redirect(url_for(\"login\"))\n        \n    except Exception as e:\n        # Tentar restaurar backup se algo deu errado\n        try:\n            if 'backup_path' in locals() and os.path.exists(backup_path):\n                if os.path.exists(\"sistema_os.db\"):\n                    os.remove(\"sistema_os.db\")\n                shutil.move(backup_path, \"sistema_os.db\")\n                flash(f\"Erro na importa√ß√£o, banco restaurado: {str(e)}\", \"danger\")\n            else:\n                flash(f\"Erro cr√≠tico na importa√ß√£o: {str(e)}\", \"danger\")\n        except:\n            flash(f\"Erro cr√≠tico na importa√ß√£o e falha na restaura√ß√£o: {str(e)}\", \"danger\")\n        \n        return redirect(url_for(\"admin_settings\"))\n\n# -------------------- MONITORING SYSTEM --------------------\n@app.route(\"/admin/monitoring\")\n@login_required\n@roles_required(\"admin\")\ndef admin_monitoring():\n    \"\"\"P√°gina principal de monitoramento do sistema\"\"\"\n    try:\n        # Status geral do sistema\n        system_status = get_system_status()\n        \n        # Performance do sistema\n        performance = get_system_performance()\n        \n        # Estat√≠sticas do banco\n        db_stats = get_database_stats()\n        \n        # Usu√°rios online\n        online_count = len(online_users)\n        \n        # Atividades recentes\n        recent_activities = []\n        if activity_logger:\n            recent_activities = activity_logger.get_recent_activities(20)\n        \n        return render_template(\"admin/monitoring.html\",\n                             app_name=APP_NAME,\n                             user=current_user(),\n                             system_status=system_status,\n                             performance=performance,\n                             db_stats=db_stats,\n                             online_users=online_count,\n                             recent_activities=recent_activities)\n    except Exception as e:\n        flash(f\"Erro ao carregar monitoramento: {str(e)}\", \"danger\")\n        return redirect(url_for(\"admin_dashboard\"))\n\n@app.route(\"/admin/monitoring/data\")\n@login_required\n@roles_required(\"admin\")\ndef admin_monitoring_data():\n    \"\"\"API para dados de monitoramento em tempo real\"\"\"\n    try:\n        # Atividades recentes\n        recent_activities = []\n        if activity_logger:\n            recent_activities = activity_logger.get_recent_activities(10)\n        \n        data = {\n            'online_users': len(online_users),\n            'recent_activities': recent_activities,\n            'timestamp': datetime.now().strftime('%H:%M:%S')\n        }\n        \n        return json.dumps(data)\n    except Exception as e:\n        return json.dumps({'error': str(e)})\n\ndef get_system_status():\n    \"\"\"Obter status geral do sistema\"\"\"\n    status = {\n        'overall_status': 'Operacional',\n        'overall_status_color': 'success',\n        'overall_icon': 'check-circle',\n        'db_status': 'Conectado',\n        'db_status_color': 'success',\n        'backup_status': 'Ativo',\n        'backup_status_color': 'success',\n        'last_backup': 'Hoje'\n    }\n    \n    try:\n        # Verificar conex√£o do banco\n        result = db.session.execute(text(\"SELECT 1\")).fetchone()\n        if not result:\n            status['db_status'] = 'Erro'\n            status['db_status_color'] = 'danger'\n            status['overall_status'] = 'Aten√ß√£o'\n            status['overall_status_color'] = 'warning'\n    except:\n        status['db_status'] = 'Erro'\n        status['db_status_color'] = 'danger'\n        status['overall_status'] = 'Cr√≠tico'\n        status['overall_status_color'] = 'danger'\n        status['overall_icon'] = 'exclamation-triangle'\n    \n    # Verificar √∫ltimo backup\n    try:\n        import glob\n        backup_files = glob.glob(\"backups/*.db\")\n        if backup_files:\n            latest_backup = max(backup_files, key=os.path.getctime)\n            backup_time = datetime.fromtimestamp(os.path.getctime(latest_backup))\n            hours_ago = (datetime.now() - backup_time).total_seconds() / 3600\n            \n            if hours_ago < 24:\n                status['last_backup'] = f\"{int(hours_ago)}h atr√°s\"\n            else:\n                status['last_backup'] = backup_time.strftime('%d/%m')\n                if hours_ago > 48:  # Mais de 2 dias\n                    status['backup_status'] = 'Atrasado'\n                    status['backup_status_color'] = 'warning'\n        else:\n            status['backup_status'] = 'Sem backup'\n            status['backup_status_color'] = 'danger'\n    except:\n        status['backup_status'] = 'Erro'\n        status['backup_status_color'] = 'danger'\n    \n    return status\n\ndef get_system_performance():\n    \"\"\"Obter m√©tricas de performance do sistema\"\"\"\n    performance = {\n        'cpu_percent': 0,\n        'cpu_color': 'success',\n        'memory_percent': 0,\n        'memory_color': 'success',\n        'disk_percent': 0,\n        'disk_color': 'success'\n    }\n    \n    try:\n        # CPU\n        cpu = psutil.cpu_percent(interval=1)\n        performance['cpu_percent'] = round(cpu, 1)\n        if cpu > 80:\n            performance['cpu_color'] = 'danger'\n        elif cpu > 60:\n            performance['cpu_color'] = 'warning'\n        \n        # Mem√≥ria\n        memory = psutil.virtual_memory()\n        performance['memory_percent'] = round(memory.percent, 1)\n        if memory.percent > 80:\n            performance['memory_color'] = 'danger'\n        elif memory.percent > 60:\n            performance['memory_color'] = 'warning'\n        \n        # Disco\n        disk = psutil.disk_usage('/')\n        performance['disk_percent'] = round(disk.percent, 1)\n        if disk.percent > 90:\n            performance['disk_color'] = 'danger'\n        elif disk.percent > 80:\n            performance['disk_color'] = 'warning'\n            \n    except Exception as e:\n        print(f\"Erro ao obter performance: {e}\")\n    \n    return performance\n\ndef get_database_stats():\n    \"\"\"Obter estat√≠sticas do banco de dados\"\"\"\n    stats = {\n        'total_records': 0,\n        'db_size': '0 MB',\n        'active_tickets': 0,\n        'total_users': 0\n    }\n    \n    try:\n        # Total de registros\n        tables = ['user', 'chamado', 'system_activity']\n        total = 0\n        for table in tables:\n            try:\n                result = db.session.execute(text(f\"SELECT COUNT(*) FROM {table}\")).fetchone()\n                if result:\n                    total += result[0]\n            except:\n                pass\n        stats['total_records'] = total\n        \n        # Tamanho do banco\n        if os.path.exists(\"sistema_os.db\"):\n            size_bytes = os.path.getsize(\"sistema_os.db\")\n            size_mb = round(size_bytes / (1024 * 1024), 2)\n            stats['db_size'] = f\"{size_mb} MB\"\n        \n        # Chamados ativos\n        result = db.session.execute(text(\"SELECT COUNT(*) FROM chamado WHERE status != 'fechado'\")).fetchone()\n        if result:\n            stats['active_tickets'] = result[0]\n        \n        # Total de usu√°rios\n        result = db.session.execute(text(\"SELECT COUNT(*) FROM user\")).fetchone()\n        if result:\n            stats['total_users'] = result[0]\n            \n    except Exception as e:\n        print(f\"Erro ao obter estat√≠sticas do banco: {e}\")\n    \n    return stats\n\n@app.route(\"/admin/logs\")\n@login_required\n@roles_required(\"admin\")\ndef admin_logs():\n    \"\"\"P√°gina de logs de atividades\"\"\"\n    try:\n        # Pagina√ß√£o\n        page = request.args.get('page', 1, type=int)\n        per_page = 50\n        \n        # Filtros\n        action_filter = request.args.get('action', '')\n        user_filter = request.args.get('user', '')\n        date_filter = request.args.get('date', '')\n        \n        # Obter logs com filtros\n        logs = []\n        total_logs = 0\n        \n        if activity_logger:\n            # Implementar filtros na consulta\n            conn = sqlite3.connect(\"sistema_os.db\")\n            cursor = conn.cursor()\n            \n            query = \"SELECT * FROM system_activity WHERE 1=1\"\n            params = []\n            \n            if action_filter:\n                query += \" AND action_type LIKE ?\"\n                params.append(f'%{action_filter}%')\n            \n            if user_filter:\n                query += \" AND username LIKE ?\"\n                params.append(f'%{user_filter}%')\n            \n            if date_filter:\n                query += \" AND DATE(timestamp) = ?\"\n                params.append(date_filter)\n            \n            # Contar total\n            count_query = query.replace(\"SELECT *\", \"SELECT COUNT(*)\")\n            cursor.execute(count_query, params)\n            total_logs = cursor.fetchone()[0]\n            \n            # Buscar logs paginados\n            query += \" ORDER BY timestamp DESC LIMIT ? OFFSET ?\"\n            params.extend([per_page, (page - 1) * per_page])\n            \n            cursor.execute(query, params)\n            raw_logs = cursor.fetchall()\n            \n            # Formatar logs\n            for log in raw_logs:\n                logs.append({\n                    'id': log[0],\n                    'timestamp': activity_logger.format_timestamp(log[1]),\n                    'user': log[3] or 'Sistema',\n                    'action': log[4],\n                    'description': log[5],\n                    'details': log[6],\n                    'ip': log[7],\n                    'color': activity_logger.get_action_color(log[4])\n                })\n            \n            conn.close()\n        \n        # Estat√≠sticas r√°pidas\n        stats = activity_logger.get_activity_stats() if activity_logger else {}\n        \n        return render_template(\"admin/logs.html\",\n                             app_name=APP_NAME,\n                             user=current_user(),\n                             logs=logs,\n                             total_logs=total_logs,\n                             page=page,\n                             per_page=per_page,\n                             action_filter=action_filter,\n                             user_filter=user_filter,\n                             date_filter=date_filter,\n                             stats=stats)\n    \n    except Exception as e:\n        flash(f\"Erro ao carregar logs: {str(e)}\", \"danger\")\n        return redirect(url_for(\"admin_dashboard\"))\n\n@app.route(\"/admin/maintenance\", methods=[\"GET\", \"POST\"])\n@login_required\n@roles_required(\"admin\")\ndef admin_maintenance():\n    \"\"\"P√°gina de manuten√ß√£o do sistema\"\"\"\n    if request.method == \"POST\":\n        action = request.form.get(\"action\")\n        \n        try:\n            if action == \"optimize_db\":\n                # Otimizar banco de dados\n                db.session.execute(text(\"VACUUM;\"))\n                db.session.execute(text(\"REINDEX;\"))\n                db.session.commit()\n                \n                if activity_logger:\n                    log_admin_action(current_user().id, current_user().username, \n                                   \"Otimiza√ß√£o do banco de dados\")\n                \n                flash(\"Banco de dados otimizado com sucesso!\", \"success\")\n                \n            elif action == \"cleanup_logs\":\n                # Limpar logs antigos\n                if activity_logger:\n                    days = int(request.form.get(\"days\", 30))\n                    deleted = activity_logger.cleanup_old_activities(days)\n                    \n                    log_admin_action(current_user().id, current_user().username, \n                                   f\"Limpeza de logs - {deleted} registros removidos\")\n                    \n                    flash(f\"Removidos {deleted} logs antigos (mais de {days} dias)!\", \"success\")\n                \n            elif action == \"cleanup_reports\":\n                # Limpar relat√≥rios antigos\n                import glob\n                report_files = glob.glob(os.path.join(app.config[\"REPORT_DIR\"], \"*.png\"))\n                report_files.extend(glob.glob(os.path.join(app.config[\"REPORT_DIR\"], \"*.pdf\")))\n                \n                removed_count = 0\n                for file in report_files:\n                    try:\n                        os.remove(file)\n                        removed_count += 1\n                    except:\n                        pass\n                \n                if activity_logger:\n                    log_admin_action(current_user().id, current_user().username, \n                                   f\"Limpeza de relat√≥rios - {removed_count} arquivos removidos\")\n                \n                flash(f\"Removidos {removed_count} arquivos de relat√≥rios!\", \"success\")\n                \n            elif action == \"backup_db\":\n                # Criar backup manual\n                if backup_manager:\n                    backup_path = backup_manager.create_backup()\n                    \n                    if activity_logger:\n                        log_admin_action(current_user().id, current_user().username, \n                                       f\"Backup manual criado: {backup_path}\")\n                    \n                    flash(f\"Backup criado: {backup_path}\", \"success\")\n                else:\n                    flash(\"Sistema de backup n√£o dispon√≠vel!\", \"warning\")\n                    \n        except Exception as e:\n            flash(f\"Erro na opera√ß√£o: {str(e)}\", \"danger\")\n        \n        return redirect(url_for(\"admin_maintenance\"))\n    \n    # Obter informa√ß√µes do sistema\n    try:\n        # Informa√ß√µes do banco\n        db_size = os.path.getsize(\"sistema_os.db\") / (1024 * 1024) if os.path.exists(\"sistema_os.db\") else 0\n        \n        # Informa√ß√µes de logs\n        log_count = 0\n        if activity_logger:\n            conn = sqlite3.connect(\"sistema_os.db\")\n            cursor = conn.cursor()\n            try:\n                cursor.execute(\"SELECT COUNT(*) FROM system_activity\")\n                log_count = cursor.fetchone()[0]\n            except:\n                pass\n            conn.close()\n        \n        # Informa√ß√µes de backups\n        backup_info = []\n        if os.path.exists(\"backups\"):\n            import glob\n            backup_files = glob.glob(\"backups/*.db\")\n            for backup in sorted(backup_files, key=os.path.getctime, reverse=True)[:5]:\n                backup_info.append({\n                    'name': os.path.basename(backup),\n                    'size': f\"{os.path.getsize(backup) / (1024 * 1024):.2f} MB\",\n                    'date': datetime.fromtimestamp(os.path.getctime(backup)).strftime('%d/%m/%Y %H:%M')\n                })\n        \n        # Informa√ß√µes de relat√≥rios\n        report_count = 0\n        report_size = 0\n        if os.path.exists(app.config[\"REPORT_DIR\"]):\n            import glob\n            report_files = glob.glob(os.path.join(app.config[\"REPORT_DIR\"], \"*\"))\n            report_count = len(report_files)\n            for file in report_files:\n                try:\n                    report_size += os.path.getsize(file)\n                except:\n                    pass\n            report_size = report_size / (1024 * 1024)  # MB\n        \n        system_info = {\n            'db_size': f\"{db_size:.2f} MB\",\n            'log_count': log_count,\n            'backup_count': len(backup_info),\n            'report_count': report_count,\n            'report_size': f\"{report_size:.2f} MB\",\n            'backup_info': backup_info\n        }\n        \n    except Exception as e:\n        system_info = {'error': str(e)}\n    \n    # Obter informa√ß√µes da licen√ßa\n    license_status = None\n    if license_manager:\n        license_status = get_license_status()\n    \n    return render_template(\"admin/maintenance.html\",\n                         app_name=APP_NAME,\n                         user=current_user(),\n                         system_info=system_info,\n                         license_status=license_status)\n\n@app.route(\"/admin/audit\")\n@login_required\n@roles_required(\"admin\")\ndef admin_audit():\n    \"\"\"P√°gina de auditoria e seguran√ßa\"\"\"\n    try:\n        # Estat√≠sticas de seguran√ßa\n        security_stats = {}\n        \n        if activity_logger:\n            conn = sqlite3.connect(\"sistema_os.db\")\n            cursor = conn.cursor()\n            \n            # Logins nas √∫ltimas 24h\n            yesterday = datetime.now() - timedelta(days=1)\n            cursor.execute(\"\"\"\n                SELECT COUNT(*) FROM system_activity \n                WHERE action_type = 'LOGIN' AND timestamp > ?\n            \"\"\", (yesterday.strftime('%Y-%m-%d %H:%M:%S'),))\n            security_stats['logins_24h'] = cursor.fetchone()[0]\n            \n            # Tentativas de login falharam (seria necess√°rio implementar)\n            security_stats['failed_logins'] = 0\n            \n            # A√ß√µes administrativas\n            cursor.execute(\"\"\"\n                SELECT COUNT(*) FROM system_activity \n                WHERE action_type = 'ADMIN' AND timestamp > ?\n            \"\"\", (yesterday.strftime('%Y-%m-%d %H:%M:%S'),))\n            security_stats['admin_actions'] = cursor.fetchone()[0]\n            \n            # Usu√°rios √∫nicos ativos\n            cursor.execute(\"\"\"\n                SELECT COUNT(DISTINCT user_id) FROM system_activity \n                WHERE timestamp > ?\n            \"\"\", (yesterday.strftime('%Y-%m-%d %H:%M:%S'),))\n            security_stats['active_users'] = cursor.fetchone()[0]\n            \n            # A√ß√µes por tipo nas √∫ltimas 24h\n            cursor.execute(\"\"\"\n                SELECT action_type, COUNT(*) FROM system_activity \n                WHERE timestamp > ?\n                GROUP BY action_type\n                ORDER BY COUNT(*) DESC\n            \"\"\", (yesterday.strftime('%Y-%m-%d %H:%M:%S'),))\n            \n            security_stats['actions_by_type'] = dict(cursor.fetchall())\n            \n            # IPs √∫nicos nas √∫ltimas 24h\n            cursor.execute(\"\"\"\n                SELECT COUNT(DISTINCT ip_address) FROM system_activity \n                WHERE timestamp > ? AND ip_address IS NOT NULL\n            \"\"\", (yesterday.strftime('%Y-%m-%d %H:%M:%S'),))\n            security_stats['unique_ips'] = cursor.fetchone()[0]\n            \n            conn.close()\n        \n        # Informa√ß√µes de usu√°rios\n        user_stats = {}\n        try:\n            result = db.session.execute(text(\"SELECT COUNT(*) FROM user\")).fetchone()\n            user_stats['total_users'] = result[0] if result else 0\n            \n            result = db.session.execute(text(\"SELECT COUNT(*) FROM user WHERE role = 'admin'\")).fetchone()\n            user_stats['admin_users'] = result[0] if result else 0\n            \n            # Usu√°rios ativos (simplified - treating all users as active for performance)\n            # The 'active' column doesn't exist in current schema, so all users are considered active\n            user_stats['active_users'] = user_stats['total_users']\n                \n        except Exception as e:\n            user_stats = {'error': str(e)}\n        \n        return render_template(\"admin/audit.html\",\n                             app_name=APP_NAME,\n                             user=current_user(),\n                             security_stats=security_stats,\n                             user_stats=user_stats)\n    \n    except Exception as e:\n        flash(f\"Erro ao carregar auditoria: {str(e)}\", \"danger\")\n        return redirect(url_for(\"admin_dashboard\"))\n\n# -------------------- LICENSE MANAGEMENT --------------------\n@app.route(\"/license\")\n@app.route(\"/license/activation\")\ndef license_activation():\n    \"\"\"P√°gina de ativa√ß√£o de licen√ßa - REATIVADA\"\"\"\n    if not license_manager:\n        flash(\"Sistema de licenciamento n√£o dispon√≠vel\", \"error\")\n        return redirect(url_for(\"login\"))\n    \n    license_status = get_license_status()\n    machine_id = license_manager.machine_id if license_manager else \"N/A\"\n    \n    return render_template(\"license/activation.html\",\n                         app_name=APP_NAME,\n                         license_status=license_status,\n                         machine_id=machine_id)\n\n@app.route(\"/license/activate\", methods=[\"POST\"])\ndef license_activate():\n    \"\"\"Processar ativa√ß√£o de licen√ßa\"\"\"\n    if not license_manager:\n        flash(\"Sistema de licenciamento n√£o dispon√≠vel\", \"error\")\n        return redirect(url_for(\"license_activation\"))\n    \n    license_key = request.form.get(\"license_key\", \"\").strip().upper()\n    customer_name = request.form.get(\"customer_name\", \"\").strip()\n    customer_email = request.form.get(\"customer_email\", \"\").strip()\n    \n    if not all([license_key, customer_name, customer_email]):\n        flash(\"Todos os campos s√£o obrigat√≥rios\", \"error\")\n        return redirect(url_for(\"license_activation\"))\n    \n    # Tentar ativar licen√ßa\n    success, message = license_manager.activate_license(license_key, customer_name, customer_email)\n    \n    if success:\n        if activity_logger:\n            log_admin_action(0, \"Sistema\", f\"Licen√ßa ativada para {customer_name}\")\n        flash(message, \"success\")\n        return redirect(url_for(\"license_activation\"))\n    else:\n        flash(message, \"error\")\n        return redirect(url_for(\"license_activation\"))\n\n@app.route(\"/license/renew\", methods=[\"POST\"])\ndef license_renew():\n    \"\"\"Renovar licen√ßa existente\"\"\"\n    if not license_manager:\n        flash(\"Sistema de licenciamento n√£o dispon√≠vel\", \"error\")\n        return redirect(url_for(\"license_activation\"))\n    \n    license_key = request.form.get(\"license_key\", \"\").strip()\n    \n    if not license_key:\n        flash(\"Chave de licen√ßa √© obrigat√≥ria\", \"error\")\n        return redirect(url_for(\"license_activation\"))\n    \n    # Tentar renovar licen√ßa\n    success, message = license_manager.renew_license(license_key)\n    \n    if success:\n        if activity_logger:\n            log_admin_action(0, \"Sistema\", \"Licen√ßa renovada\")\n        flash(message, \"success\")\n    else:\n        flash(message, \"error\")\n    \n    return redirect(url_for(\"license_activation\"))\n\n@app.route(\"/license/status\")\ndef license_status():\n    \"\"\"API para verificar status da licen√ßa\"\"\"\n    if not license_manager:\n        return json.dumps({\"licensed\": False, \"error\": \"Sistema n√£o dispon√≠vel\"})\n    \n    status = get_license_status()\n    return json.dumps(status)\n\n@app.route(\"/admin/license\")\n@login_required\n@roles_required(\"admin\")\ndef admin_license():\n    \"\"\"Painel administrativo de licen√ßas\"\"\"\n    if not license_manager:\n        flash(\"Sistema de licenciamento n√£o dispon√≠vel\", \"error\")\n        return redirect(url_for(\"admin_dashboard\"))\n    \n    license_info = license_manager.get_license_info()\n    \n    # Verificar recursos dispon√≠veis\n    features_status = {}\n    if license_info['licensed'] and 'features' in license_info:\n        features = license_info['features']\n        features_status = {\n            'max_users': features.get('max_users', 10),\n            'max_tickets': features.get('max_tickets', 100),\n            'premium_reports': features.get('premium_reports', False),\n            'api_access': features.get('api_access', False),\n            'white_label': features.get('white_label', False)\n        }\n    \n    # Obter licen√ßas dispon√≠veis e vendidas\n    available_licenses = license_generator.get_available_licenses()\n    sold_licenses = license_generator.get_sold_licenses()\n    \n    return render_template(\"admin/license_management.html\",\n                         app_name=APP_NAME,\n                         user=current_user(),\n                         license_info=license_info,\n                         features_status=features_status,\n                         available_licenses=available_licenses,\n                         sold_licenses=sold_licenses)\n\n@app.route(\"/admin/license/generate\", methods=[\"POST\"])\n@login_required\n@roles_required(\"admin\")\ndef admin_license_generate():\n    \"\"\"Gerar nova chave de licen√ßa\"\"\"\n    if not license_generator:\n        flash(\"Sistema de gera√ß√£o n√£o dispon√≠vel\", \"error\")\n        return redirect(url_for(\"admin_license\"))\n    \n    license_type = request.form.get(\"license_type\", \"standard\")\n    customer_name = request.form.get(\"customer_name\", \"\").strip()\n    customer_email = request.form.get(\"customer_email\", \"\").strip()\n    notes = request.form.get(\"notes\", \"\").strip()\n    \n    # Definir pre√ßo baseado no tipo\n    prices = {\n        'basic': 100.0,\n        'standard': 200.0,\n        'premium': 500.0,\n        'enterprise': 1000.0\n    }\n    \n    price = prices.get(license_type, 200.0)\n    \n    result = license_generator.create_license(\n        license_type=license_type,\n        customer_name=customer_name if customer_name else None,\n        customer_email=customer_email if customer_email else None,\n        price=price,\n        notes=notes if notes else None\n    )\n    \n    if result['success']:\n        if activity_logger:\n            log_admin_action(\n                session.get(\"user_id\", 0),\n                session.get(\"username\", \"Sistema\"),\n                f\"Chave gerada: {result['license_key']} - Tipo: {license_type}\"\n            )\n        flash(f\"Chave de licen√ßa gerada: {result['license_key']}\", \"success\")\n    else:\n        flash(result['message'], \"error\")\n    \n    return redirect(url_for(\"admin_license\"))\n\n@app.route(\"/admin/license/bulk\", methods=[\"POST\"])\n@login_required\n@roles_required(\"admin\")\ndef admin_license_bulk():\n    \"\"\"Gerar licen√ßas em lote\"\"\"\n    if not license_generator:\n        flash(\"Sistema de gera√ß√£o n√£o dispon√≠vel\", \"error\")\n        return redirect(url_for(\"admin_license\"))\n    \n    try:\n        count = int(request.form.get(\"count\", 10))\n        license_type = request.form.get(\"license_type\", \"standard\")\n        \n        if count > 100:\n            flash(\"M√°ximo 100 licen√ßas por vez\", \"error\")\n            return redirect(url_for(\"admin_license\"))\n        \n        created_keys = license_generator.bulk_create_licenses(count, license_type)\n        \n        if activity_logger:\n            log_admin_action(\n                session.get(\"user_id\", 0),\n                session.get(\"username\", \"Sistema\"),\n                f\"Geradas {len(created_keys)} chaves em lote - Tipo: {license_type}\"\n            )\n        \n        flash(f\"{len(created_keys)} chaves de licen√ßa geradas com sucesso!\", \"success\")\n        \n    except ValueError:\n        flash(\"Quantidade inv√°lida\", \"error\")\n    except Exception as e:\n        flash(f\"Erro ao gerar licen√ßas: {str(e)}\", \"error\")\n    \n    return redirect(url_for(\"admin_license\"))\n\n@app.route(\"/admin/sistema\", methods=[\"GET\", \"POST\"])\n@login_required\n@roles_required(\"admin\")\ndef admin_sistema():\n    if request.method == \"POST\":\n        # Handle configuration updates\n        action = request.form.get(\"action\")\n        \n        if action == \"optimize_db\":\n            # Optimize database\n            try:\n                db.session.execute(text(\"VACUUM;\"))\n                db.session.commit()\n                flash(\"Banco de dados otimizado com sucesso!\", \"success\")\n            except Exception as e:\n                flash(f\"Erro ao otimizar banco: {str(e)}\", \"danger\")\n        \n        elif action == \"clear_logs\":\n            # Clear old reports from static folder\n            try:\n                import glob\n                report_files = glob.glob(os.path.join(app.config[\"REPORT_DIR\"], \"*.png\"))\n                report_files.extend(glob.glob(os.path.join(app.config[\"REPORT_DIR\"], \"*.pdf\")))\n                removed_count = 0\n                for file in report_files:\n                    try:\n                        os.remove(file)\n                        removed_count += 1\n                    except:\n                        pass\n                flash(f\"Removidos {removed_count} arquivos de relat√≥rios antigos!\", \"success\")\n            except Exception as e:\n                flash(f\"Erro ao limpar arquivos: {str(e)}\", \"danger\")\n        \n        return redirect(url_for(\"admin_sistema\"))\n    \n    # Get system statistics\n    stats = {}\n    try:\n        # Database stats\n        result = db.session.execute(text(\"SELECT COUNT(*) FROM chamado\")).fetchone()\n        stats['total_chamados'] = result[0] if result else 0\n        \n        result = db.session.execute(text(\"SELECT COUNT(*) FROM user\")).fetchone()\n        stats['total_usuarios'] = result[0] if result else 0\n        \n        result = db.session.execute(text(\"SELECT COUNT(*) FROM chamado WHERE status = 'aberto'\")).fetchone()\n        stats['chamados_abertos'] = result[0] if result else 0\n        \n        # Database file size\n        db_size = os.path.getsize(\"sistema_os.db\") / (1024 * 1024)  # MB\n        stats['db_size'] = f\"{db_size:.2f} MB\"\n        \n        # Report files count\n        import glob\n        report_files = len(glob.glob(os.path.join(app.config[\"REPORT_DIR\"], \"*\")))\n        stats['report_files'] = report_files\n        \n    except Exception as e:\n        stats['error'] = str(e)\n    \n    return render_template(\"admin_sistema.html\", stats=stats, app_name=APP_NAME, user=current_user())\n\n# -------------------- RELAT√ìRIOS --------------------\n@app.route(\"/relatorios\", methods=[\"GET\",\"POST\"])\n@login_required\n@permission_required(\"view_reports\")\ndef relatorios():\n    u = current_user()\n    # filtros\n    data_ini = request.values.get(\"data_ini\",\"\")\n    data_fim = request.values.get(\"data_fim\",\"\")\n    status = request.values.get(\"status\",\"\")\n    setor = request.values.get(\"setor\",\"\")\n    responsavel = request.values.get(\"responsavel\",\"\")\n    aberto_por = request.values.get(\"aberto_por\",\"\")\n    urgencia = request.values.get(\"urgencia\",\"\")\n\n    # Optimize query with eager loading to prevent N+1 problems\n    q = Chamado.query.options(\n        joinedload(Chamado.usuario),\n        joinedload(Chamado.fechado_por)\n    )\n    if setor:\n        # Suporte a dados legados: filtrar tanto por name interno quanto display_name\n        # para garantir compatibilidade com dados antigos\n        try:\n            sector_obj = Sector.query.filter(\n                (Sector.name == setor) | (Sector.display_name == setor)\n            ).first()\n            \n            if sector_obj:\n                # Filtrar por ambos os valores poss√≠veis para m√°xima compatibilidade\n                q = q.filter(\n                    (Chamado.setor == sector_obj.name) | \n                    (Chamado.setor == sector_obj.display_name)\n                )\n            else:\n                # Fallback: filtrar pelo valor exato selecionado\n                q = q.filter(Chamado.setor == setor)\n        except:\n            # Em caso de erro, usar filtro simples\n            q = q.filter(Chamado.setor == setor)\n    if u.is_operator_like() and not u.is_admin():\n        user_sectors = u.get_sectors()\n        if user_sectors:\n            # Incluir compatibilidade com dados legados: tanto name quanto display_name\n            allowed_sector_values = []\n            for sector in user_sectors:\n                allowed_sector_values.append(sector.name)\n                allowed_sector_values.append(sector.display_name)\n            # Remover duplicados\n            allowed_sector_values = list(set(allowed_sector_values))\n            q = q.filter(Chamado.setor.in_(allowed_sector_values))\n        else:\n            # Operator with no sectors sees no tickets\n            q = q.filter(False)\n    if data_ini:\n        try:\n            di = datetime.strptime(data_ini, \"%Y-%m-%d\")\n            q = q.filter(Chamado.criado_em >= di)\n        except:\n            pass\n    if data_fim:\n        try:\n            df = datetime.strptime(data_fim, \"%Y-%m-%d\")\n            df = df.replace(hour=23, minute=59, second=59)\n            q = q.filter(Chamado.criado_em <= df)\n        except:\n            pass\n    if status:\n        q = q.filter(Chamado.status == status)\n    if responsavel and responsavel.isdigit():\n        q = q.filter(Chamado.fechado_por_id == int(responsavel))\n    if aberto_por and aberto_por.isdigit():\n        q = q.filter(Chamado.usuario_id == int(aberto_por))\n    if urgencia:\n        q = q.filter(Chamado.urgencia == urgencia)\n\n    chamados = q.order_by(Chamado.criado_em.asc()).all()\n\n    # dataframe\n    rows = []\n    for c in chamados:\n        duracao_h = None\n        if c.fechado_em:\n            duracao_h = (c.fechado_em - c.criado_em).total_seconds()/3600.0\n        rows.append({\n            \"ID\": c.id,\n            \"T√≠tulo\": c.titulo,\n            \"Status\": c.status,\n            \"Criado em\": c.criado_em,\n            \"Fechado em\": c.fechado_em,\n            \"Dura√ß√£o(h)\": duracao_h,\n            \"Aberto por\": c.usuario.username if c.usuario else \"\",\n            \"Fechado por\": c.fechado_por.username if c.fechado_por else \"\",\n            \"Setor\": (c.setor or '‚Äî'),\n            \"Setor do Solicitante\": (c.usuario_setor or '‚Äî')\n        })\n    df = pd.DataFrame(rows)\n\n    # gerar gr√°ficos (salvos como PNG na pasta static/relatorios)\n    chart_files = []\n    if not df.empty:\n        # OS por m√™s\n        df[\"Mes\"] = pd.to_datetime(df[\"Criado em\"]).dt.to_period(\"M\").astype(str)\n        qty_by_month = df.groupby(\"Mes\")[\"ID\"].count().sort_index()\n\n        fig1 = plt.figure()\n        qty_by_month.plot(kind=\"bar\")\n        plt.title(\"Quantidade de OS por m√™s\")\n        plt.xlabel(\"M√™s\")\n        plt.ylabel(\"Qtd de OS\")\n        file1 = os.path.join(app.config[\"REPORT_DIR\"], f\"{uuid4_hex()}_qtd_mes.png\")\n        fig1.savefig(file1, bbox_inches=\"tight\")\n        plt.close(fig1)\n        chart_files.append(file1)\n\n        # M√©dias por m√™s (fechadas)\n        df_closed = df.dropna(subset=[\"Fechado em\"]).copy()\n        if not df_closed.empty:\n            df_closed[\"MesFech\"] = pd.to_datetime(df_closed[\"Fechado em\"]).dt.to_period(\"M\").astype(str)\n            mean_by_month = df_closed.groupby(\"MesFech\")[\"Dura√ß√£o(h)\"].mean().sort_index()\n            fig2 = plt.figure()\n            mean_by_month.plot(kind=\"line\", marker=\"o\")\n            plt.title(\"Tempo m√©dio de atendimento (h) por m√™s\")\n            plt.xlabel(\"M√™s\")\n            plt.ylabel(\"M√©dia (h)\")\n            file2 = os.path.join(app.config[\"REPORT_DIR\"], f\"{uuid4_hex()}_media_mes.png\")\n            fig2.savefig(file2, bbox_inches=\"tight\")\n            plt.close(fig2)\n            chart_files.append(file2)\n\n        # Distribui√ß√£o por status\n        by_status = df[\"Status\"].value_counts()\n        fig3 = plt.figure()\n        by_status.plot(kind=\"pie\", autopct=\"%1.1f%%\")\n        plt.title(\"Distribui√ß√£o por status\")\n        plt.ylabel(\"\")\n        file3 = os.path.join(app.config[\"REPORT_DIR\"], f\"{uuid4_hex()}_status.png\")\n        fig3.savefig(file3, bbox_inches=\"tight\")\n        plt.close(fig3)\n        chart_files.append(file3)\n\n        # OS por operador (fechou) - contagem\n        if not df_closed.empty:\n            by_op_count = df_closed[\"Fechado por\"].value_counts()\n            fig5 = plt.figure()\n            by_op_count.plot(kind=\"bar\")\n            plt.title(\"OS fechadas por operador\")\n            plt.xlabel(\"Operador\")\n            plt.ylabel(\"Qtd\")\n            file5 = os.path.join(app.config[\"REPORT_DIR\"], f\"{uuid4_hex()}_qtd_operador.png\")\n            fig5.savefig(file5, bbox_inches=\"tight\")\n            plt.close(fig5)\n            chart_files.append(file5)\n\n            # Tempo total por operador\n            by_op_hours = df_closed.groupby(\"Fechado por\")[\"Dura√ß√£o(h)\"].sum().sort_values(ascending=False)\n            fig4 = plt.figure()\n            by_op_hours.plot(kind=\"bar\")\n            plt.title(\"Tempo total por operador (h)\")\n            plt.xlabel(\"Operador\")\n            plt.ylabel(\"Horas\")\n            file4 = os.path.join(app.config[\"REPORT_DIR\"], f\"{uuid4_hex()}_tempo_operador.png\")\n            fig4.savefig(file4, bbox_inches=\"tight\")\n            plt.close(fig4)\n            chart_files.append(file4)\n\n            # Top 5 OS mais demoradas\n            top5 = df_closed.sort_values(\"Dura√ß√£o(h)\", ascending=False).head(5).set_index(\"ID\")[\"Dura√ß√£o(h)\"]\n            if not top5.empty:\n                fig6 = plt.figure()\n                top5.plot(kind=\"bar\")\n                plt.title(\"Top 5 OS mais demoradas (h)\")\n                plt.xlabel(\"OS\")\n                plt.ylabel(\"Horas\")\n                file6 = os.path.join(app.config[\"REPORT_DIR\"], f\"{uuid4_hex()}_top5.png\")\n                fig6.savefig(file6, bbox_inches=\"tight\")\n                plt.close(fig6)\n                chart_files.append(file6)\n\n    # listar operadores e usu√°rios para filtros\n    operadores = User.query.filter(User.role.in_([\"operador\",\"admin\"])).order_by(User.username).all()\n    usuarios = User.query.filter(User.role.in_([\"usuario\",\"operador\",\"admin\"])).order_by(User.username).all()\n    \n    # Buscar setores dinamicamente da tabela Sector\n    try:\n        setores_db = Sector.query.filter_by(active=True).order_by(Sector.display_name).all()\n        setores = [{'name': sector.name, 'display_name': sector.display_name} for sector in setores_db]\n    except:\n        # Fallback para setores padr√£o se a tabela n√£o existir\n        setores = [\n            {'name': 'T.I', 'display_name': 'T.I'},\n            {'name': 'Manuten√ß√£o', 'display_name': 'Manuten√ß√£o'},\n            {'name': 'CCIH / SESMT / Manuten√ß√£o de Ar condicionado', 'display_name': 'CCIH / SESMT / Manuten√ß√£o de Ar condicionado'},\n            {'name': 'Telefonia e outros servi√ßos', 'display_name': 'Telefonia e outros servi√ßos'}\n        ]\n\n    # KPIs\n    total_abertas = int((df[\"Status\"] == \"Aberto\").sum()) if not df.empty else 0\n    total_fechadas = int((df[\"Status\"] == \"Fechado\").sum()) if not df.empty else 0\n    media_h = round(float(df[\"Dura√ß√£o(h)\"].dropna().mean()), 2) if not df.empty and df[\"Dura√ß√£o(h)\"].notna().any() else 0.0\n    mediana_h = round(float(df[\"Dura√ß√£o(h)\"].dropna().median()), 2) if not df.empty and df[\"Dura√ß√£o(h)\"].notna().any() else 0.0\n    taxa_fechamento = round((total_fechadas / (len(df) if not df.empty else 1)) * 100, 1) if not df.empty else 0.0\n    total_horas = round(float(df[\"Dura√ß√£o(h)\"].dropna().sum()), 2) if not df.empty else 0.0\n\n    return render_template(\n        \"relatorios.html\",\n        app_name=APP_NAME,\n        user=u,\n        chamados=chamados,\n        data_ini=data_ini, data_fim=data_fim, status=status, responsavel=responsavel, aberto_por=aberto_por,\n        setor=setor, urgencia=urgencia,\n        operadores=operadores, usuarios=usuarios, setores=setores,\n        chart_files=[f.replace(\"\\\\\",\"/\") for f in chart_files],\n        total_abertas=total_abertas, total_fechadas=total_fechadas, media_h=media_h,\n        mediana_h=mediana_h, taxa_fechamento=taxa_fechamento, total_horas=total_horas\n    )\n\n# Exporta√ß√µes com filtros atuais\ndef _filtered_dataframe(params):\n    data_ini = params.get(\"data_ini\",\"\")\n    data_fim = params.get(\"data_fim\",\"\")\n    status = params.get(\"status\",\"\")\n    responsavel = params.get(\"responsavel\",\"\")\n    aberto_por = params.get(\"aberto_por\",\"\")\n    setor = params.get(\"setor\",\"\")\n    urgencia = params.get(\"urgencia\",\"\")\n    \n    # Get current user and apply sector restrictions\n    u = current_user()\n    q = Chamado.query\n    \n    # Apply operator sector restrictions FIRST\n    if u.is_operator_like() and not u.is_admin() and not u.has_permission('view_all'):\n        user_sector_names = u.get_sector_names()\n        if user_sector_names:\n            q = q.filter(Chamado.setor.in_(user_sector_names))\n        else:\n            # Operator with no sectors sees no tickets\n            q = q.filter(False)\n    \n    # Then apply additional filters\n    if setor:\n        q = q.filter(Chamado.setor == setor)\n    if data_ini:\n        try:\n            di = datetime.strptime(data_ini, \"%Y-%m-%d\")\n            q = q.filter(Chamado.criado_em >= di)\n        except:\n            pass\n    if data_fim:\n        try:\n            df_ = datetime.strptime(data_fim, \"%Y-%m-%d\").replace(hour=23, minute=59, second=59)\n            q = q.filter(Chamado.criado_em <= df_)\n        except:\n            pass\n    if status:\n        q = q.filter(Chamado.status == status)\n    if responsavel and str(responsavel).isdigit():\n        q = q.filter(Chamado.fechado_por_id == int(responsavel))\n    if aberto_por and str(aberto_por).isdigit():\n        q = q.filter(Chamado.usuario_id == int(aberto_por))\n    if urgencia:\n        q = q.filter(Chamado.urgencia == urgencia)\n\n    chamados = q.order_by(Chamado.criado_em.asc()).all()\n    rows = []\n    for c in chamados:\n        duracao_h = None\n        if c.fechado_em:\n            duracao_h = round((c.fechado_em - c.criado_em).total_seconds()/3600.0, 2)\n        rows.append([\n            c.id,\n            c.criado_em,\n            c.usuario.username if c.usuario else \"\",\n            c.setor or '‚Äî',\n            getattr(c, 'ramal', '') or \"\",\n            c.descricao,\n            c.status,\n            c.fechado_em if c.fechado_em else \"\",\n            c.fechado_por.username if c.fechado_por else \"\",\n            duracao_h,\n            getattr(c, 'cdc', '') or \"\"\n        ])\n    df = pd.DataFrame(rows, columns=[\"ID\",\"Abertura\",\"Aberto por\",\"Setor\",\"Ramal\",\"Descri√ß√£o\",\"Status\",\"Fechamento\",\"Fechado por\",\"Dura√ß√£o(h)\",\"CDC\"])\n    \n    # Handle NaT values for Excel export compatibility\n    df['Abertura'] = pd.to_datetime(df['Abertura'])\n    df['Fechamento'] = pd.to_datetime(df['Fechamento'], errors='coerce')\n    \n    return df\n\n@app.route(\"/export_xlsx\")\n@login_required\n@permission_required(\"view_reports\")\ndef export_xlsx():\n    df = _filtered_dataframe(request.args)\n    output = io.BytesIO()\n    \n    # Create Excel with professional formatting\n    with pd.ExcelWriter(output, engine=\"xlsxwriter\") as writer:\n        df.to_excel(writer, index=False, sheet_name=\"Relat√≥rio de OS\", startrow=4)\n        \n        workbook = writer.book\n        worksheet = writer.sheets['Relat√≥rio de OS']\n        \n        # Header format\n        header_format = workbook.add_format({\n            'bold': True,\n            'text_wrap': True,\n            'valign': 'top',\n            'fg_color': '#2E86AB',\n            'font_color': 'white',\n            'border': 1\n        })\n        \n        # Description text wrap formats (for alternating rows)\n        wrap_format = workbook.add_format({\n            'text_wrap': True,\n            'valign': 'top',\n            'border': 1\n        })\n        \n        wrap_alt_format = workbook.add_format({\n            'text_wrap': True,\n            'valign': 'top',\n            'border': 1,\n            'bg_color': '#F8F9FA'\n        })\n        \n        # Title format\n        title_format = workbook.add_format({\n            'bold': True,\n            'font_size': 16,\n            'align': 'center',\n            'valign': 'vcenter'\n        })\n        \n        # Date format\n        date_format = workbook.add_format({\n            'num_format': 'dd/mm/yyyy hh:mm',\n            'border': 1\n        })\n        \n        # Date format with alternating background\n        date_alt_format = workbook.add_format({\n            'num_format': 'dd/mm/yyyy hh:mm',\n            'bg_color': '#F8F9FA',\n            'border': 1\n        })\n        \n        # Alternating row format\n        alt_row_format = workbook.add_format({\n            'bg_color': '#F8F9FA',\n            'border': 1\n        })\n        \n        # Add title (cover all columns - now 11 columns A to K)\n        worksheet.merge_range('A1:K2', 'Sistemas Olivium - Relat√≥rio de OS', title_format)\n        worksheet.write('A3', f'Gerado em: {now_brazil().strftime(\"%d/%m/%Y %H:%M\")}')\n        \n        # Format headers\n        for col_num, value in enumerate(df.columns.values):\n            worksheet.write(4, col_num, value, header_format)\n        \n        # Format data rows with proper date handling\n        for row_num in range(len(df)):\n            for col_num, col_name in enumerate(df.columns):\n                value = df.iloc[row_num, col_num]\n                \n                # Handle date columns specifically\n                if col_name in ['Abertura', 'Fechamento'] and pd.notna(value):\n                    format_to_use = date_format if row_num % 2 == 0 else date_alt_format\n                    worksheet.write_datetime(row_num + 5, col_num, value, format_to_use)\n                elif value is None or pd.isna(value):\n                    # Write empty string for None/NaN values\n                    format_to_use = alt_row_format if row_num % 2 == 1 else None\n                    worksheet.write(row_num + 5, col_num, \"\", format_to_use)\n                else:\n                    # Regular data with special handling for description column\n                    if col_name == 'Descri√ß√£o':\n                        # Apply text wrap to description column with alternating backgrounds\n                        format_to_use = wrap_format if row_num % 2 == 0 else wrap_alt_format  \n                        worksheet.write(row_num + 5, col_num, value, format_to_use)\n                    else:\n                        format_to_use = alt_row_format if row_num % 2 == 1 else None\n                        worksheet.write(row_num + 5, col_num, value, format_to_use)\n        \n        # Set proper column widths matching the new column order\n        worksheet.set_column('A:A', 8)   # ID column - narrow\n        worksheet.set_column('B:B', 20)  # Abertura - wider for date/time\n        worksheet.set_column('C:C', 15)  # Aberto por column\n        worksheet.set_column('D:D', 20)  # Setor column\n        worksheet.set_column('E:E', 10)  # Ramal column - narrow\n        worksheet.set_column('F:F', 50)  # Descri√ß√£o column - wider for long descriptions\n        worksheet.set_column('G:G', 15)  # Status column\n        worksheet.set_column('H:H', 20)  # Fechamento - wider for date/time\n        worksheet.set_column('I:I', 15)  # Fechado por column\n        worksheet.set_column('J:J', 12)  # Dura√ß√£o(h) column\n        worksheet.set_column('K:K', 10)  # CDC column\n    \n    output.seek(0)\n    return send_file(output, as_attachment=True, download_name=f\"relatorio_os_{now_brazil().strftime('%Y%m%d_%H%M')}.xlsx\", \n                     mimetype='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')\n\n@app.route(\"/relatorios/export/csv\")\n@login_required\n@permission_required(\"view_reports\")\ndef export_csv():\n    df = _filtered_dataframe(request.args)\n    output = io.StringIO()\n    df.to_csv(output, index=False)\n    output.seek(0)\n    return send_file(io.BytesIO(output.getvalue().encode(\"utf-8-sig\")), as_attachment=True, \n                     download_name=\"relatorio_os.csv\", mimetype=\"text/csv\")\n\n@app.route(\"/export_pdf\")\n@login_required\n@permission_required(\"view_reports\")\ndef export_pdf():\n    df = _filtered_dataframe(request.args)\n    packet = io.BytesIO()\n    c = canvas.Canvas(packet, pagesize=A4)\n    width, height = A4\n    \n    # Title and header\n    y = height - 80\n    c.setFont(\"Helvetica-Bold\", 18)\n    c.drawCentredString(width/2, y, \"Sistemas Olivium\")\n    y -= 25\n    c.setFont(\"Helvetica-Bold\", 14)\n    c.drawCentredString(width/2, y, \"Relat√≥rio de Ordens de Servi√ßo\")\n    y -= 20\n    c.setFont(\"Helvetica\", 10)\n    c.drawCentredString(width/2, y, f\"Gerado em: {now_brazil().strftime('%d/%m/%Y %H:%M')}\")\n    y -= 30\n    \n    # Draw header line\n    c.setStrokeColorRGB(0.2, 0.5, 0.7)\n    c.setLineWidth(2)\n    c.line(50, y, width-50, y)\n    y -= 20\n    \n    # Table headers\n    c.setFont(\"Helvetica-Bold\", 8)\n    headers = [\"ID\", \"Descri√ß√£o\", \"Status\", \"Setor\", \"Set.Solic\", \"Abertura\", \"Fechamento\", \"Dur.(h)\", \"Aberto por\", \"Ramal\"]\n    x_positions = [50, 80, 140, 180, 210, 240, 280, 310, 350, 390]\n    \n    for i, header in enumerate(headers):\n        c.drawString(x_positions[i], y, header)\n    y -= 5\n    c.line(50, y, width-50, y)\n    y -= 15\n    \n    # Table data\n    c.setFont(\"Helvetica\", 7)\n    row_color = True\n    \n    for _, row in df.iterrows():\n        if y < 100:\n            c.showPage()\n            y = height - 50\n            # Redraw headers on new page\n            c.setFont(\"Helvetica-Bold\", 8)\n            for i, header in enumerate(headers):\n                c.drawString(x_positions[i], y, header)\n            y -= 5\n            c.line(50, y, width-50, y)\n            y -= 15\n            c.setFont(\"Helvetica\", 7)\n        \n        # Alternate row background\n        if row_color:\n            c.setFillColorRGB(0.97, 0.97, 0.97)\n            c.rect(50, y-10, width-100, 12, fill=1, stroke=0)\n        \n        c.setFillColorRGB(0, 0, 0)  # Reset to black for text\n        \n        # Handle optional columns safely\n        setor_solicitante = \"\"\n        if \"Setor do Solicitante\" in df.columns and pd.notna(row[\"Setor do Solicitante\"]) and row[\"Setor do Solicitante\"] != '‚Äî':\n            setor_solicitante = str(row[\"Setor do Solicitante\"])[:8]\n        \n        data = [\n            str(row[\"ID\"]),\n            str(row[\"Descri√ß√£o\"])[:15],\n            str(row[\"Status\"]),\n            str(row[\"Setor\"])[:6] if row[\"Setor\"] != '‚Äî' else \"\",\n            setor_solicitante,\n            row[\"Abertura\"].strftime(\"%d/%m\") if pd.notna(row[\"Abertura\"]) else \"\",\n            row[\"Fechamento\"].strftime(\"%d/%m\") if pd.notna(row[\"Fechamento\"]) else \"\",\n            f'{row[\"Dura√ß√£o(h)\"]:.1f}' if pd.notna(row[\"Dura√ß√£o(h)\"]) else \"\",\n            str(row[\"Aberto por\"])[:8] if row[\"Aberto por\"] else \"\",\n            str(row[\"Ramal\"]) if row[\"Ramal\"] else \"\"\n        ]\n        \n        for i, value in enumerate(data):\n            c.drawString(x_positions[i], y, value)\n        \n        y -= 12\n        row_color = not row_color\n    \n    # Footer\n    c.setFont(\"Helvetica\", 8)\n    c.drawCentredString(width/2, 30, f\"Total de registros: {len(df)}\")\n    \n    c.save()\n    packet.seek(0)\n    return send_file(packet, as_attachment=True, download_name=f\"relatorio_os_{now_brazil().strftime('%Y%m%d_%H%M')}.pdf\", \n                     mimetype=\"application/pdf\")\n\n# util\ndef uuid4_hex():\n    return uuid.uuid4().hex\n\n# -------------------- WEBSOCKET HELPERS --------------------\ndef emit_ticket_update(ticket_data, event_type):\n    \"\"\"Emits ticket updates to clients with proper sector filtering\"\"\"\n    # For now, emit to all clients - client-side filtering should handle sector restrictions\n    # In a production environment, you'd want to track user sessions and filter server-side\n    socketio.emit('ticket_update', {\n        'event_type': event_type,\n        'ticket': ticket_data\n    }, namespace='/')\n    \n    # TODO: Implement server-side session tracking for sector-based filtering\n    # This would require storing user sector info in socket sessions\n\ndef ticket_to_dict(chamado):\n    \"\"\"Convert a ticket object to dictionary for JSON emission\"\"\"\n    return {\n        'id': chamado.id,\n        'titulo': chamado.titulo,\n        'descricao': chamado.descricao,\n        'status': chamado.status,\n        'criado_em': chamado.criado_em.strftime('%Y-%m-%d %H:%M:%S') if chamado.criado_em else None,\n        'fechado_em': chamado.fechado_em.strftime('%Y-%m-%d %H:%M:%S') if chamado.fechado_em else None,\n        'setor': chamado.setor,\n        'usuario_setor': chamado.usuario_setor,\n        'usuario': chamado.usuario.username if chamado.usuario else None,\n        'fechado_por': chamado.fechado_por.username if chamado.fechado_por else None\n    }\n\n# -------------------- ADMIN MENU SYSTEM --------------------\n\n@app.route(\"/admin\")\n@login_required\n@roles_required(\"admin\")\ndef admin_dashboard():\n    \"\"\"Admin dashboard with system overview\"\"\"\n    # Get system statistics\n    total_users = User.query.filter_by(active=True).count() if hasattr(User, 'active') else User.query.count()\n    total_tickets = Chamado.query.count()\n    open_tickets = Chamado.query.filter_by(status='Aberto').count()\n    closed_tickets = Chamado.query.filter_by(status='Fechado').count()\n    urgent_tickets = Chamado.query.filter_by(urgencia='Urgente').count() if hasattr(Chamado, 'urgencia') else 0\n    \n    # Recent activity (last 7 days)\n    seven_days_ago = now_brazil() - pd.Timedelta(days=7)\n    recent_tickets = Chamado.query.filter(Chamado.criado_em >= seven_days_ago).count()\n    \n    stats = {\n        'total_users': total_users,\n        'total_tickets': total_tickets,\n        'open_tickets': open_tickets,\n        'closed_tickets': closed_tickets,\n        'urgent_tickets': urgent_tickets,\n        'recent_tickets': recent_tickets\n    }\n    \n    return render_template(\"admin/dashboard.html\", app_name=APP_NAME, user=current_user(), stats=stats)\n\n# -------------------- ADMIN SECTOR MANAGEMENT --------------------\n\n@app.route(\"/admin/sectors\")\n@login_required\n@roles_required(\"admin\")\ndef admin_sectors():\n    \"\"\"Manage sectors\"\"\"\n    sectors = Sector.query.filter_by(active=True).order_by(Sector.display_name).all()\n    return render_template(\"admin/sectors.html\", app_name=APP_NAME, user=current_user(), sectors=sectors)\n\n@app.route(\"/admin/sectors/new\", methods=[\"GET\", \"POST\"])\n@login_required\n@roles_required(\"admin\")\ndef admin_sectors_new():\n    \"\"\"Create new sector\"\"\"\n    if request.method == \"POST\":\n        name = request.form.get(\"name\", \"\").strip()\n        display_name = request.form.get(\"display_name\", \"\").strip()\n        description = request.form.get(\"description\", \"\").strip()\n        \n        if not name or not display_name:\n            flash(\"Nome interno e nome de exibi√ß√£o s√£o obrigat√≥rios.\", \"danger\")\n            return render_template(\"admin/sector_form.html\", app_name=APP_NAME, user=current_user())\n        \n        # Check if there's an existing sector with the same name (active or inactive)\n        existing_sector = Sector.query.filter_by(name=name).first()\n        \n        if existing_sector:\n            if existing_sector.active:\n                flash(\"J√° existe um setor ativo com este nome interno.\", \"danger\")\n                return render_template(\"admin/sector_form.html\", app_name=APP_NAME, user=current_user())\n            else:\n                # Reactivate the inactive sector\n                existing_sector.active = True\n                existing_sector.display_name = display_name\n                existing_sector.description = description\n                db.session.commit()\n                flash(\"Setor reativado com sucesso.\", \"success\")\n        else:\n            # Create new sector\n            sector = Sector(name=name, display_name=display_name, description=description)\n            db.session.add(sector)\n            db.session.commit()\n            flash(\"Setor criado com sucesso.\", \"success\")\n        return redirect(url_for(\"admin_sectors\"))\n    \n    return render_template(\"admin/sector_form.html\", app_name=APP_NAME, user=current_user(), sector=None)\n\n@app.route(\"/admin/sectors/edit/<int:sector_id>\", methods=[\"GET\", \"POST\"])\n@login_required\n@roles_required(\"admin\")\ndef admin_sectors_edit(sector_id):\n    \"\"\"Edit sector\"\"\"\n    sector = Sector.query.get_or_404(sector_id)\n    \n    if request.method == \"POST\":\n        name = request.form.get(\"name\", \"\").strip()\n        display_name = request.form.get(\"display_name\", \"\").strip()\n        description = request.form.get(\"description\", \"\").strip()\n        \n        if not name or not display_name:\n            flash(\"Nome interno e nome de exibi√ß√£o s√£o obrigat√≥rios.\", \"danger\")\n            return render_template(\"admin/sector_form.html\", app_name=APP_NAME, user=current_user(), sector=sector)\n        \n        # Check for duplicate names (excluding current sector, only among active sectors)\n        existing = Sector.query.filter(Sector.name == name, Sector.id != sector_id, Sector.active == True).first()\n        if existing:\n            flash(\"J√° existe outro setor com este nome interno.\", \"danger\")\n            return render_template(\"admin/sector_form.html\", app_name=APP_NAME, user=current_user(), sector=sector)\n        \n        sector.name = name\n        sector.display_name = display_name\n        sector.description = description\n        db.session.commit()\n        flash(\"Setor atualizado com sucesso.\", \"success\")\n        return redirect(url_for(\"admin_sectors\"))\n    \n    return render_template(\"admin/sector_form.html\", app_name=APP_NAME, user=current_user(), sector=sector)\n\n@app.route(\"/admin/sectors/delete/<int:sector_id>\", methods=[\"POST\"])\n@login_required\n@roles_required(\"admin\")\ndef admin_sectors_delete(sector_id):\n    \"\"\"Delete sector\"\"\"\n    sector = Sector.query.get_or_404(sector_id)\n    \n    # Check if sector is being used\n    tickets_count = Chamado.query.filter_by(setor=sector.name).count()\n    users_count = User.query.filter_by(setor=sector.name).count()\n    \n    if tickets_count > 0 or users_count > 0:\n        flash(f\"N√£o √© poss√≠vel excluir o setor. Ele est√° sendo usado por {tickets_count} chamados e {users_count} usu√°rios.\", \"danger\")\n        return redirect(url_for(\"admin_sectors\"))\n    \n    sector.active = False  # Soft delete\n    db.session.commit()\n    flash(\"Setor removido com sucesso.\", \"success\")\n    return redirect(url_for(\"admin_sectors\"))\n\n# -------------------- ADMIN USER MANAGEMENT --------------------\n\n@app.route(\"/admin/users\")\n@login_required\n@roles_required(\"admin\")\ndef admin_users():\n    \"\"\"Advanced user management\"\"\"\n    users = User.query.order_by(User.username).all()\n    roles = Role.query.filter_by(active=True).order_by(Role.display_name).all()  # Custom roles system enabled\n    sectors = Sector.query.filter_by(active=True).order_by(Sector.display_name).all()\n    return render_template(\"admin/users.html\", app_name=APP_NAME, user=current_user(), users=users, roles=roles, sectors=sectors)\n\n@app.route(\"/admin/users/new\", methods=[\"GET\", \"POST\"])\n@login_required\n@roles_required(\"admin\")\ndef admin_users_new():\n    \"\"\"Create new user with advanced settings\"\"\"\n    if request.method == \"POST\":\n        username = request.form.get(\"username\", \"\").strip()\n        password = request.form.get(\"password\", \"\")\n        role = request.form.get(\"role\", \"\")\n        # role_id = request.form.get(\"role_id\", type=int)  # Removed for PostgreSQL compatibility\n        sector_ids = request.form.getlist(\"sector_ids\")\n        \n        if not username or not password:\n            flash(\"Usu√°rio e senha s√£o obrigat√≥rios.\", \"danger\")\n            return redirect(url_for(\"admin_users_new\"))\n        \n        if User.query.filter_by(username=username).first():\n            flash(\"Usu√°rio j√° existe.\", \"danger\")\n            return redirect(url_for(\"admin_users_new\"))\n        \n        user = User(username=username, role=role)\n        user.set_password(password)\n        \n        # Set new role system if available\n        # Legacy role_id system removed for PostgreSQL compatibility\n        if hasattr(user, 'active'):\n            user.active = True\n        if hasattr(user, 'created_at'):\n            user.created_at = now_brazil()\n        \n        db.session.add(user)\n        db.session.commit()\n        \n        # Assign sectors using the new method\n        if sector_ids:\n            sector_ids = [int(id) for id in sector_ids if id.isdigit()]\n            user.assign_sectors(sector_ids)\n            db.session.commit()\n        \n        # Validate operator sector assignment\n        if role == 'operador' and not user.get_sectors():\n            flash(\"Operadores devem ter pelo menos um setor atribu√≠do.\", \"warning\")\n            # roles = Role.query.filter_by(active=True).order_by(Role.display_name).all()  # Removed for PostgreSQL compatibility\n            roles = []  # Using simple string role system\n            sectors = Sector.query.filter_by(active=True).order_by(Sector.display_name).all()\n            return render_template(\"admin/user_form.html\", app_name=APP_NAME, user=current_user(), u=user, roles=roles, sectors=sectors)\n        \n        flash(\"Usu√°rio criado com sucesso.\", \"success\")\n        return redirect(url_for(\"admin_users\"))\n    \n    roles = Role.query.filter_by(active=True).order_by(Role.display_name).all()  # Custom roles system enabled\n    sectors = Sector.query.filter_by(active=True).order_by(Sector.display_name).all()\n    return render_template(\"admin/user_form.html\", app_name=APP_NAME, user=current_user(), u=None, roles=roles, sectors=sectors)\n\n@app.route(\"/admin/users/edit/<int:uid>\", methods=[\"GET\", \"POST\"])\n@login_required\n@roles_required(\"admin\")\ndef admin_users_editar(uid):\n    \"\"\"Edit user with advanced settings\"\"\"\n    u = db.session.get(User, uid) or abort(404)\n    \n    if request.method == \"POST\":\n        u.username = request.form.get(\"username\", \"\").strip()\n        password = request.form.get(\"password\", \"\")\n        role = request.form.get(\"role\", \"\")\n        # role_id = request.form.get(\"role_id\", type=int)  # Removed for PostgreSQL compatibility\n        sector_ids = request.form.getlist(\"sector_ids\")\n        \n        if not u.username:\n            flash(\"Usu√°rio √© obrigat√≥rio.\", \"danger\")\n            return redirect(url_for(\"admin_users_editar\", uid=uid))\n        \n        # Check for username conflicts (excluding current user)\n        existing = User.query.filter(User.username == u.username, User.id != uid).first()\n        if existing:\n            flash(\"J√° existe outro usu√°rio com este nome.\", \"danger\")\n            return redirect(url_for(\"admin_users_editar\", uid=uid))\n        \n        u.role = role\n        \n        # Set new role system if available\n        if hasattr(u, 'role_id') and role_id:\n            u.role_id = role_id\n        \n        # Assign sectors using the new method\n        if sector_ids:\n            sector_ids = [int(id) for id in sector_ids if id.isdigit()]\n            u.assign_sectors(sector_ids)\n        else:\n            u.assign_sectors([])  # Clear all sectors\n        \n        # Validate operator sector assignment\n        if role == 'operador' and not u.get_sectors():\n            flash(\"Operadores devem ter pelo menos um setor atribu√≠do.\", \"warning\")\n            # roles = Role.query.filter_by(active=True).order_by(Role.display_name).all()  # Removed for PostgreSQL compatibility\n            roles = []  # Using simple string role system\n            sectors = Sector.query.filter_by(active=True).order_by(Sector.display_name).all()\n            return render_template(\"admin/user_form.html\", app_name=APP_NAME, user=current_user(), u=u, roles=roles, sectors=sectors)\n        \n        if password:\n            u.set_password(password)\n        \n        # Force session refresh for currently logged in user\n        if u.id == session.get('user_id'):\n            session['user_sectors'] = u.get_sector_names()\n            session['user_role'] = u.role\n        \n        db.session.commit()\n        flash(\"Usu√°rio atualizado com sucesso.\", \"success\")\n        return redirect(url_for(\"admin_users\"))\n    \n    roles = Role.query.filter_by(active=True).order_by(Role.display_name).all()  # Custom roles system enabled\n    sectors = Sector.query.filter_by(active=True).order_by(Sector.display_name).all()\n    return render_template(\"admin/user_form.html\", app_name=APP_NAME, user=current_user(), u=u, roles=roles, sectors=sectors)\n\n# -------------------- ADMIN ROLES & PERMISSIONS --------------------\n\n@app.route(\"/admin/roles\")\n@login_required\n@roles_required(\"admin\")\ndef admin_roles():\n    \"\"\"Manage roles and permissions\"\"\"\n    \n    roles = Role.query.filter_by(active=True).order_by(Role.display_name).all()\n    \n    # Calculate user count for each role\n    roles_with_counts = []\n    for role in roles:\n        user_count = User.query.filter_by(role=role.name).count()\n        roles_with_counts.append({\n            'role': role,\n            'user_count': user_count\n        })\n    \n    return render_template(\"admin/roles.html\", app_name=APP_NAME, user=current_user(), roles_with_counts=roles_with_counts)\n\n@app.route(\"/admin/roles/new\", methods=[\"GET\", \"POST\"])\n@login_required\n@roles_required(\"admin\")\ndef admin_roles_new():\n    \"\"\"Create new role\"\"\"\n    \n    if request.method == \"POST\":\n        name = request.form.get(\"name\", \"\").strip()\n        display_name = request.form.get(\"display_name\", \"\").strip()\n        description = request.form.get(\"description\", \"\").strip()\n        permissions = request.form.getlist(\"permissions\")\n        \n        if not name or not display_name:\n            flash(\"Nome e nome de exibi√ß√£o s√£o obrigat√≥rios.\", \"danger\")\n            return render_template(\"admin/role_form.html\", app_name=APP_NAME, user=current_user())\n        \n        # Check if there's an existing role with the same name (active or inactive)\n        existing_role = Role.query.filter_by(name=name).first()\n        \n        if existing_role:\n            if existing_role.active:\n                flash(\"J√° existe um papel ativo com este nome.\", \"danger\")\n                return render_template(\"admin/role_form.html\", app_name=APP_NAME, user=current_user())\n            else:\n                # Reactivate the inactive role\n                import json\n                existing_role.active = True\n                existing_role.display_name = display_name\n                existing_role.description = description\n                existing_role.permissions = json.dumps(permissions)\n                db.session.commit()\n                flash(\"Papel reativado com sucesso.\", \"success\")\n                return redirect(url_for(\"admin_roles\"))\n        else:\n            # Create new role\n            import json\n            role = Role(\n                name=name, \n                display_name=display_name, \n                description=description, \n                permissions=json.dumps(permissions)\n            )\n            db.session.add(role)\n        db.session.commit()\n        \n        # Log activity\n        if activity_logger:\n            user = current_user()\n            log_admin_action(\n                user.id if user else 0,\n                user.username if user else \"Sistema\",\n                f\"Papel '{display_name}' criado\"\n            )\n        \n        flash(\"Papel criado com sucesso.\", \"success\")\n        return redirect(url_for(\"admin_roles\"))\n    \n    available_permissions = [\n        {\"id\": \"view_all\", \"name\": \"Ver todos os chamados\"},\n        {\"id\": \"view_sector\", \"name\": \"Ver chamados do setor\"},\n        {\"id\": \"view_own\", \"name\": \"Ver pr√≥prios chamados\"},\n        {\"id\": \"edit_all\", \"name\": \"Editar todos os chamados\"},\n        {\"id\": \"edit_sector\", \"name\": \"Editar chamados do setor\"},\n        {\"id\": \"delete_all\", \"name\": \"Excluir qualquer chamado\"},\n        {\"id\": \"close_tickets\", \"name\": \"Fechar chamados\"},\n        {\"id\": \"create_tickets\", \"name\": \"Criar chamados\"},\n        {\"id\": \"manage_users\", \"name\": \"Gerenciar usu√°rios\"},\n        {\"id\": \"manage_sectors\", \"name\": \"Gerenciar setores\"},\n        {\"id\": \"manage_roles\", \"name\": \"Gerenciar pap√©is\"},\n        {\"id\": \"view_reports\", \"name\": \"Visualizar relat√≥rios\"},\n        {\"id\": \"manage_settings\", \"name\": \"Gerenciar configura√ß√µes\"}\n    ]\n    \n    return render_template(\"admin/role_form.html\", app_name=APP_NAME, user=current_user(), role=None, available_permissions=available_permissions)\n\n@app.route(\"/admin/roles/edit/<int:role_id>\", methods=[\"GET\", \"POST\"])\n@login_required\n@roles_required(\"admin\")\ndef admin_roles_edit(role_id):\n    \"\"\"Edit role\"\"\"\n    \n    role = Role.query.get_or_404(role_id)\n    \n    if request.method == \"POST\":\n        name = request.form.get(\"name\", \"\").strip()\n        display_name = request.form.get(\"display_name\", \"\").strip()\n        description = request.form.get(\"description\", \"\").strip()\n        permissions = request.form.getlist(\"permissions\")\n        \n        if not name or not display_name:\n            flash(\"Nome e nome de exibi√ß√£o s√£o obrigat√≥rios.\", \"danger\")\n            return redirect(url_for(\"admin_roles_edit\", role_id=role_id))\n        \n        # Check for duplicate names (excluding current role)\n        existing = Role.query.filter(Role.name == name, Role.id != role_id).first()\n        if existing:\n            flash(\"J√° existe outro papel com este nome.\", \"danger\")\n            return redirect(url_for(\"admin_roles_edit\", role_id=role_id))\n        \n        import json\n        role.name = name\n        role.display_name = display_name\n        role.description = description\n        role.permissions = json.dumps(permissions)\n        role.updated_at = datetime.now()\n        \n        db.session.commit()\n        \n        # Log activity\n        if activity_logger:\n            user = current_user()\n            log_admin_action(\n                user.id if user else 0,\n                user.username if user else \"Sistema\",\n                f\"Papel '{display_name}' editado\"\n            )\n        \n        flash(\"Papel atualizado com sucesso.\", \"success\")\n        return redirect(url_for(\"admin_roles\"))\n    \n    available_permissions = [\n        {\"id\": \"view_all\", \"name\": \"Ver todos os chamados\"},\n        {\"id\": \"view_sector\", \"name\": \"Ver chamados do setor\"},\n        {\"id\": \"view_own\", \"name\": \"Ver pr√≥prios chamados\"},\n        {\"id\": \"edit_all\", \"name\": \"Editar todos os chamados\"},\n        {\"id\": \"edit_sector\", \"name\": \"Editar chamados do setor\"},\n        {\"id\": \"delete_all\", \"name\": \"Excluir qualquer chamado\"},\n        {\"id\": \"close_tickets\", \"name\": \"Fechar chamados\"},\n        {\"id\": \"create_tickets\", \"name\": \"Criar chamados\"},\n        {\"id\": \"manage_users\", \"name\": \"Gerenciar usu√°rios\"},\n        {\"id\": \"manage_sectors\", \"name\": \"Gerenciar setores\"},\n        {\"id\": \"manage_roles\", \"name\": \"Gerenciar pap√©is\"},\n        {\"id\": \"view_reports\", \"name\": \"Visualizar relat√≥rios\"},\n        {\"id\": \"manage_settings\", \"name\": \"Gerenciar configura√ß√µes\"}\n    ]\n    \n    return render_template(\"admin/role_form.html\", app_name=APP_NAME, user=current_user(), role=role, available_permissions=available_permissions)\n    \n    available_permissions = [\n        {\"id\": \"view_all\", \"name\": \"Ver todos os chamados\"},\n        {\"id\": \"view_sector\", \"name\": \"Ver chamados do setor\"},\n        {\"id\": \"view_own\", \"name\": \"Ver pr√≥prios chamados\"},\n        {\"id\": \"edit_all\", \"name\": \"Editar todos os chamados\"},\n        {\"id\": \"edit_sector\", \"name\": \"Editar chamados do setor\"},\n        {\"id\": \"delete_all\", \"name\": \"Excluir qualquer chamado\"},\n        {\"id\": \"close_tickets\", \"name\": \"Fechar chamados\"},\n        {\"id\": \"create_tickets\", \"name\": \"Criar chamados\"},\n        {\"id\": \"manage_users\", \"name\": \"Gerenciar usu√°rios\"},\n        {\"id\": \"manage_sectors\", \"name\": \"Gerenciar setores\"},\n        {\"id\": \"manage_roles\", \"name\": \"Gerenciar pap√©is\"},\n        {\"id\": \"view_reports\", \"name\": \"Visualizar relat√≥rios\"},\n        {\"id\": \"manage_settings\", \"name\": \"Gerenciar configura√ß√µes\"}\n    ]\n    \n    return render_template(\"admin/role_form.html\", app_name=APP_NAME, user=current_user(), role=role, available_permissions=available_permissions)\n\n@app.route(\"/admin/roles/delete/<int:role_id>\", methods=[\"POST\"])\n@login_required\n@roles_required(\"admin\")\ndef admin_roles_delete(role_id):\n    \"\"\"Delete role\"\"\"\n    \n    role = Role.query.get_or_404(role_id)\n    \n    # Check if role is being used by any users (using string comparison)\n    users_count = User.query.filter_by(role=role.name).count()\n    \n    if users_count > 0:\n        flash(f\"N√£o √© poss√≠vel excluir o papel '{role.display_name}'. Ele est√° sendo usado por {users_count} usu√°rio(s).\", \"danger\")\n        return redirect(url_for(\"admin_roles\"))\n    \n    # Soft delete - just mark as inactive\n    role.active = False\n    db.session.commit()\n    \n    # Log activity\n    if activity_logger:\n        user = current_user()\n        log_admin_action(\n            user.id if user else 0,\n            user.username if user else \"Sistema\",\n            f\"Papel '{role.display_name}' removido\"\n        )\n    \n    flash(\"Papel removido com sucesso.\", \"success\")\n    return redirect(url_for(\"admin_roles\"))\n\n# -------------------- ADMIN SETTINGS --------------------\n\n@app.route(\"/admin/settings\")\n@login_required\n@roles_required(\"admin\")\ndef admin_settings():\n    \"\"\"System settings management\"\"\"\n    settings = SystemSettings.query.order_by(SystemSettings.setting_key).all()\n    settings_dict = {s.setting_key: s.setting_value for s in settings}\n    return render_template(\"admin/settings.html\", app_name=APP_NAME, user=current_user(), settings=settings_dict)\n\n@app.route(\"/admin/settings/update\", methods=[\"POST\"])\n@login_required\n@roles_required(\"admin\")\ndef admin_settings_update():\n    \"\"\"Update system settings\"\"\"\n    for key, value in request.form.items():\n        if key.startswith('setting_'):\n            setting_key = key.replace('setting_', '')\n            setting = SystemSettings.query.filter_by(setting_key=setting_key).first()\n            if setting:\n                setting.setting_value = value\n                setting.updated_at = now_brazil()\n            else:\n                # Create new setting\n                setting = SystemSettings(setting_key=setting_key, setting_value=value, updated_at=now_brazil())\n                db.session.add(setting)\n    \n    db.session.commit()\n    flash(\"Configura√ß√µes atualizadas com sucesso.\", \"success\")\n    return redirect(url_for(\"admin_settings\"))\n\n# -------------------- ENHANCED UTILITIES --------------------\n\ndef get_system_setting(key, default=None):\n    \"\"\"Get system setting value\"\"\"\n    setting = SystemSettings.query.filter_by(setting_key=key).first()\n    return setting.setting_value if setting else default\n\n# Update APP_NAME to be dynamic\ndef get_app_name():\n    return get_system_setting(\"system_name\", \"Sistemas Olivium\")\n\n# -------------------- RUN --------------------\nif __name__ == \"__main__\":\n    print(\"üöÄ Iniciando Sistema Olivion v2.0...\")\n    print(\"üìä Sistema de Gest√£o de Chamados\")\n    print(\"üåê Servidor ser√° iniciado em: http://localhost:5000\")\n    print(\"=\" * 50)\n    \n    # Garantir que SQLite est√° inicializado\n    with app.app_context():\n        try:\n            bootstrap()  # Criar tabelas e usu√°rio admin\n            print(\"‚úÖ SQLite inicializado com sucesso!\")\n        except Exception as e:\n            print(f\"‚ö†Ô∏è Erro na inicializa√ß√£o: {e}\")\n    \n    try:\n        port = int(os.getenv(\"PORT\", 5000))\n        \n        # Verificar se deve usar HTTPS para desenvolvimento local\n        # Detectar se est√° rodando no Replit ou localmente\n        is_replit = any([\n            os.getenv(\"REPL_ID\"),\n            os.getenv(\"REPL_SLUG\"), \n            os.getenv(\"REPLIT_DEPLOYMENT\"),\n            os.getenv(\"REPLIT_DB_URL\"),\n            \"replit\" in os.getcwd().lower()\n        ])\n        \n        # Usar SSL apenas se for desenvolvimento local (n√£o Replit) e vari√°vel espec√≠fica\n        use_ssl = (not is_replit and os.getenv(\"ENABLE_LOCAL_SSL\") == \"1\")\n        \n        if use_ssl:\n            try:\n                print(\"üîí HTTPS ativado para desenvolvimento local\")\n                print(\"‚ö†Ô∏è  Aceite o certificado autoassinado no navegador\")\n                print(\"üåê Acesse: https://localhost:5000\")\n                # Para HTTPS local, for√ßar threading mode para compatibilidade com SSL\n                socketio.init_app(app, async_mode='threading')\n                app.run(host=\"0.0.0.0\", port=port, debug=False, ssl_context='adhoc', threaded=True)\n            except Exception as e:\n                print(f\"‚ö†Ô∏è  N√£o foi poss√≠vel ativar HTTPS: {e}\")\n                print(\"üåê Usando HTTP com SocketIO: http://localhost:5000\")\n                socketio.run(app, host=\"0.0.0.0\", port=port, debug=False, use_reloader=False, log_output=True)\n        else:\n            # Para produ√ß√£o, Replit ou local sem SSL, usar SocketIO normal\n            print(\"üåê Usando HTTP com SocketIO\")\n            socketio.run(app, host=\"0.0.0.0\", port=port, debug=False, use_reloader=False, log_output=True)\n    except OSError as e:\n        if \"Address already in use\" in str(e):\n            print(\"‚ùå ERRO: Porta 5000 j√° est√° em uso!\")\n            print(\"üí° Solu√ß√£o: Feche outros programas que usam a porta 5000\")\n            print(\"   Ou mude a porta no arquivo app.py (linha final)\")\n        else:\n            print(f\"‚ùå ERRO: {e}\")\n        input(\"Pressione Enter para fechar...\")\n\n","size_bytes":122493},"app_refactored.py":{"content":"from flask import Flask, render_template, request, redirect, url_for, session, send_file, abort, flash\nfrom flask_sqlalchemy import SQLAlchemy\nfrom flask_socketio import SocketIO, emit\nfrom sqlalchemy import text\nfrom werkzeug.security import generate_password_hash, check_password_hash\nfrom werkzeug.utils import secure_filename\nfrom functools import wraps\nfrom datetime import datetime, timedelta\nimport pytz\nimport io, os, shutil\nimport psutil\nimport json\nimport sqlite3\nimport pandas as pd\nimport matplotlib\nmatplotlib.use(\"Agg\")\nimport matplotlib.pyplot as plt\nfrom reportlab.pdfgen import canvas\nfrom reportlab.lib.pagesizes import A4\nimport uuid\n\n# Configure Bras√≠lia timezone (GMT-3)\nBRAZIL_TZ = pytz.timezone('America/Sao_Paulo')\n\ndef now_brazil():\n    \"\"\"Return current datetime in Brazil timezone (GMT-3)\"\"\"\n    return datetime.now(BRAZIL_TZ).replace(tzinfo=None)\n\n# SISTEMAS DE LICENCIAMENTO REATIVADOS\ntry:\n    from backup_manager import BackupManager\n    from database_safety import DatabaseSafety  \n    from activity_logger import activity_logger, log_login, log_logout, log_admin_action, log_system_event\n    from license_manager import license_manager, is_licensed, get_license_status, check_feature_access\n    from license_generator import license_generator, create_standard_license, create_premium_license\n    backup_manager = BackupManager(\"sistema_os.db\")\n    db_safety = DatabaseSafety(\"sistema_os.db\")\n    print(\"‚úÖ Configura√ß√µes de seguran√ßa aplicadas\")\n    print(\"‚úÖ Sistemas de seguran√ßa carregados\")\n    print(\"üîê Sistema de licenciamento ativo\")\nexcept ImportError as e:\n    print(f\"‚ö†Ô∏è Sistemas de seguran√ßa n√£o carregados: {e}\")\n    backup_manager = None\n    db_safety = None\n    activity_logger = None\n    license_manager = None\n    \n    # Fun√ß√µes de fallback se n√£o conseguir carregar\n    def is_licensed():\n        return True\n\n    def get_license_status():\n        return {'licensed': True}\n\n    def check_feature_access(feature):\n        return True\n    \n    def log_login(user_id, username, ip_address=None, user_agent=None, session_id=None):\n        pass\n    \n    def log_logout(user_id, username, ip_address=None, session_id=None):\n        pass\n    \n    def log_admin_action(user_id, username, action_description, details=None):\n        pass\n    \n    def log_system_event(event_type, description, details=None):\n        pass\n\n# App configuration\nAPP_NAME = \"Sistemas Olivium\"\nSETOR_CHOICES = [\"T.I\", \"Manuten√ß√£o\", \"CCIH / SESMT / Manuten√ß√£o de Ar condicionado\", \"Telefonia e outros servi√ßos\"]\n\n# Internal value mapping for sector consolidation\nSETOR_INTERNAL_VALUES = {\n    \"T.I\": \"ti\",\n    \"Manuten√ß√£o\": \"manutencao\", \n    \"CCIH / SESMT / Manuten√ß√£o de Ar condicionado\": \"ccih_sesmt_arcondicionado\",\n    \"Telefonia e outros servi√ßos\": \"telefonia_outros\"\n}\n\n# File upload configuration\nUPLOAD_FOLDER = 'static/uploads'\nALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg', 'gif'}\nMAX_FILE_SIZE = 5 * 1024 * 1024  # 5MB\n\ndef allowed_file(filename):\n    return '.' in filename and \\\n           filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\n\ndef save_uploaded_file(file):\n    \"\"\"Save uploaded file with secure name and return filename\"\"\"\n    if file and file.filename and allowed_file(file.filename):\n        # Create unique filename to prevent conflicts\n        filename_parts = file.filename.rsplit('.', 1)\n        if len(filename_parts) > 1:\n            ext = filename_parts[1].lower()\n        else:\n            ext = 'unknown'\n        filename = f\"{uuid.uuid4()}.{ext}\"\n        file.save(os.path.join(UPLOAD_FOLDER, filename))\n        return filename\n    return None\n\n# Carregar vari√°veis do arquivo .env se existir\ntry:\n    from dotenv import load_dotenv\n    load_dotenv()\nexcept ImportError:\n    pass  # dotenv n√£o instalado, continuar sem ele\n\n# Create Flask app\napp = Flask(__name__)\n\n# Load improved configuration\ntry:\n    app.config.from_object('config')\n    print(\"‚úÖ Configura√ß√µes aprimoradas carregadas\")\nexcept ImportError:\n    # Fallback to original configuration\n    import secrets\n    app.secret_key = os.getenv(\"FLASK_SECRET_KEY\", secrets.token_hex(32))\n    app.config[\"SQLALCHEMY_DATABASE_URI\"] = \"sqlite:///sistema_os.db\"\n    app.config[\"SQLALCHEMY_ENGINE_OPTIONS\"] = {\n        'pool_pre_ping': True,\n        'pool_recycle': 300,\n    }\n    print(\"‚ö†Ô∏è  Usando configura√ß√£o padr√£o\")\n\nprint(\"üóÑÔ∏è Usando SQLite para desenvolvimento...\")\n\n# Initialize database\nfrom models import db\ndb.init_app(app)\n\n# Initialize SocketIO\nsocketio = SocketIO(app, cors_allowed_origins=\"*\", async_mode='eventlet', logger=False, engineio_logger=False)\n\n# Import models to ensure tables are created\nfrom models import User, Chamado\n\n# Importar e registrar blueprints\ntry:\n    from blueprints.auth import auth_bp\n    from blueprints.main import main_bp\n    from blueprints.users import users_bp  \n    from blueprints.tickets import tickets_bp\n    from blueprints.admin import admin_bp\n    from blueprints.reports import reports_bp\n    \n    app.register_blueprint(auth_bp)\n    app.register_blueprint(main_bp)\n    app.register_blueprint(users_bp)\n    app.register_blueprint(tickets_bp) \n    app.register_blueprint(admin_bp)\n    app.register_blueprint(reports_bp)\n    \n    print(\"‚úÖ Blueprints registrados com sucesso\")\n    BLUEPRINTS_LOADED = True\nexcept ImportError as e:\n    print(f\"‚ö†Ô∏è Blueprints n√£o carregados: {e}\")\n    print(\"‚ö†Ô∏è Usando rotas do sistema original\")\n    BLUEPRINTS_LOADED = False\n\n# Create tables and admin user if not exist\nwith app.app_context():\n    db.create_all()\n    \n    # Ensure admin user exists\n    admin = User.query.filter_by(username=\"admin\").first()\n    if not admin:\n        admin = User(username=\"admin\", role=\"admin\", setor=None)\n        admin.set_password(\"admin\")\n        db.session.add(admin)\n        db.session.commit()\n        print(\"üë§ Usu√°rio admin criado\")\n\nprint(\"üöÄ Iniciando Sistema Olivion v2.0...\")\nprint(\"üìä Sistema de Gest√£o de Chamados\")\nprint(\"üåê Servidor ser√° iniciado em: http://localhost:5000\")\nprint(\"=\" * 50)\n\n# SocketIO events\n@socketio.on('connect')\ndef on_connect():\n    print(f'Cliente conectado: {request.sid}')\n    emit('status', {'msg': 'Conectado ao servidor'})\n\n@socketio.on('disconnect')\ndef on_disconnect():\n    print(f'Cliente desconectado: {request.sid}')\n\nif __name__ == \"__main__\":\n    # Criar pastas necess√°rias\n    os.makedirs(UPLOAD_FOLDER, exist_ok=True)\n    os.makedirs(\"static/relatorios\", exist_ok=True)\n    \n    # Inicializar banco\n    print(\"‚úÖ Coluna 'ramal' j√° existe na tabela 'chamado'\")\n    print(\"‚úÖ SQLite inicializado com sucesso!\")\n    \n    try:\n        port = int(os.environ.get(\"PORT\", 5000))\n        use_ssl = os.environ.get(\"USE_SSL\", \"false\").lower() == \"true\"\n        \n        if use_ssl:\n            try:\n                print(\"üîí HTTPS ativado para desenvolvimento local\")\n                print(\"‚ö†Ô∏è  Aceite o certificado autoassinado no navegador\")\n                print(\"üåê Acesse: https://localhost:5000\")\n                # Para HTTPS local, for√ßar threading mode para compatibilidade com SSL\n                socketio.init_app(app, async_mode='threading')\n                app.run(host=\"0.0.0.0\", port=port, debug=False, ssl_context='adhoc', threaded=True)\n            except Exception as e:\n                print(f\"‚ö†Ô∏è  N√£o foi poss√≠vel ativar HTTPS: {e}\")\n                print(\"üåê Usando HTTP com SocketIO: http://localhost:5000\")\n                socketio.run(app, host=\"0.0.0.0\", port=port, debug=False, use_reloader=False, log_output=True)\n        else:\n            # Para produ√ß√£o, Replit ou local sem SSL, usar SocketIO normal\n            print(\"üåê Usando HTTP com SocketIO\")\n            socketio.run(app, host=\"0.0.0.0\", port=port, debug=False, use_reloader=False, log_output=True)\n    except OSError as e:\n        if \"Address already in use\" in str(e):\n            print(\"‚ùå ERRO: Porta 5000 j√° est√° em uso!\")\n            print(\"üí° Solu√ß√£o: Feche outros programas que usam a porta 5000\")\n            print(\"   Ou mude a porta no arquivo app.py (linha final)\")\n        else:\n            print(f\"‚ùå ERRO: {e}\")\n        input(\"Pressione Enter para fechar...\")","size_bytes":8190},"basic_tests.py":{"content":"# basic_tests.py - Testes automatizados b√°sicos para o Sistema HelpDesk\n\nimport os\nimport sys\nimport sqlite3\nimport requests\nimport time\nfrom datetime import datetime\nfrom typing import Dict, List, Any, Optional\n\nclass HelpDeskTester:\n    \"\"\"Classe para executar testes automatizados do Sistema HelpDesk\"\"\"\n    \n    def __init__(self, base_url: str = \"http://localhost:5000\", db_path: str = \"sistema_os.db\"):\n        self.base_url = base_url\n        self.db_path = db_path\n        self.test_results = []\n        self.session = requests.Session()\n        \n    def log_test(self, test_name: str, success: bool, message: str = \"\", details: Optional[Dict] = None):\n        \"\"\"Registra resultado de um teste\"\"\"\n        result = {\n            'test_name': test_name,\n            'success': success,\n            'message': message,\n            'details': details or {},\n            'timestamp': datetime.now().isoformat()\n        }\n        self.test_results.append(result)\n        \n        status = \"‚úÖ PASS\" if success else \"‚ùå FAIL\"\n        print(f\"{status} - {test_name}: {message}\")\n    \n    def test_database_connectivity(self) -> bool:\n        \"\"\"Testa conectividade com o banco de dados\"\"\"\n        try:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            # Verificar se as tabelas existem\n            cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table'\")\n            tables = [row[0] for row in cursor.fetchall()]\n            \n            required_tables = ['user', 'chamado', 'system_activity', 'system_license']\n            missing_tables = [table for table in required_tables if table not in tables]\n            \n            if missing_tables:\n                self.log_test(\"database_connectivity\", False, \n                             f\"Tabelas faltando: {missing_tables}\")\n                return False\n            \n            # Verificar dados b√°sicos\n            cursor.execute(\"SELECT COUNT(*) FROM user\")\n            user_count = cursor.fetchone()[0]\n            \n            cursor.execute(\"SELECT COUNT(*) FROM chamado\")\n            chamado_count = cursor.fetchone()[0]\n            \n            conn.close()\n            \n            self.log_test(\"database_connectivity\", True, \n                         f\"Banco OK - {user_count} usu√°rios, {chamado_count} chamados\")\n            return True\n            \n        except Exception as e:\n            self.log_test(\"database_connectivity\", False, str(e))\n            return False\n    \n    def test_server_connectivity(self) -> bool:\n        \"\"\"Testa se o servidor est√° respondendo\"\"\"\n        try:\n            response = self.session.get(f\"{self.base_url}/\", timeout=10)\n            \n            if response.status_code in [200, 302]:  # 302 = redirect to login\n                self.log_test(\"server_connectivity\", True, \n                             f\"Servidor respondendo - Status: {response.status_code}\")\n                return True\n            else:\n                self.log_test(\"server_connectivity\", False, \n                             f\"Status inesperado: {response.status_code}\")\n                return False\n                \n        except Exception as e:\n            self.log_test(\"server_connectivity\", False, str(e))\n            return False\n    \n    def test_login_page(self) -> bool:\n        \"\"\"Testa se a p√°gina de login carrega corretamente\"\"\"\n        try:\n            response = self.session.get(f\"{self.base_url}/login\", timeout=10)\n            \n            if response.status_code == 200:\n                content = response.text\n                \n                # Verificar se elementos importantes est√£o presentes\n                required_elements = ['username', 'password', 'login', 'form']\n                missing_elements = [elem for elem in required_elements \n                                  if elem.lower() not in content.lower()]\n                \n                if missing_elements:\n                    self.log_test(\"login_page\", False, \n                                 f\"Elementos faltando: {missing_elements}\")\n                    return False\n                \n                self.log_test(\"login_page\", True, \"P√°gina de login carregando corretamente\")\n                return True\n            else:\n                self.log_test(\"login_page\", False, f\"Status: {response.status_code}\")\n                return False\n                \n        except Exception as e:\n            self.log_test(\"login_page\", False, str(e))\n            return False\n    \n    def test_api_endpoints(self) -> bool:\n        \"\"\"Testa endpoints da API REST\"\"\"\n        try:\n            # Teste endpoint de health\n            response = self.session.get(f\"{self.base_url}/api/v1/health\", timeout=10)\n            \n            if response.status_code == 200:\n                data = response.json()\n                \n                if 'success' in data and 'data' in data:\n                    health_data = data['data']\n                    if 'status' in health_data and health_data['status'] == 'healthy':\n                        self.log_test(\"api_health_endpoint\", True, \n                                     \"Endpoint /api/v1/health funcionando\")\n                        \n                        # Teste endpoint de stats\n                        stats_response = self.session.get(f\"{self.base_url}/api/v1/stats\", timeout=10)\n                        if stats_response.status_code == 200:\n                            self.log_test(\"api_stats_endpoint\", True, \n                                         \"Endpoint /api/v1/stats funcionando\")\n                            return True\n                        else:\n                            self.log_test(\"api_stats_endpoint\", False, \n                                         f\"Stats endpoint status: {stats_response.status_code}\")\n                            return False\n                    else:\n                        self.log_test(\"api_health_endpoint\", False, \n                                     \"Health status n√£o √© 'healthy'\")\n                        return False\n                else:\n                    self.log_test(\"api_health_endpoint\", False, \n                                 \"Estrutura de resposta inv√°lida\")\n                    return False\n            else:\n                self.log_test(\"api_health_endpoint\", False, \n                             f\"Status: {response.status_code}\")\n                return False\n                \n        except Exception as e:\n            self.log_test(\"api_endpoints\", False, str(e))\n            return False\n    \n    def test_static_files(self) -> bool:\n        \"\"\"Testa se arquivos est√°ticos est√£o acess√≠veis\"\"\"\n        try:\n            static_files = [\n                '/static/css/style.css',\n                '/static/js/form-validation.js',\n                '/static/sw.js'\n            ]\n            \n            successful_files = 0\n            \n            for file_path in static_files:\n                try:\n                    response = self.session.get(f\"{self.base_url}{file_path}\", timeout=5)\n                    if response.status_code == 200:\n                        successful_files += 1\n                except:\n                    pass\n            \n            if successful_files >= len(static_files) * 0.7:  # Pelo menos 70% dos arquivos\n                self.log_test(\"static_files\", True, \n                             f\"{successful_files}/{len(static_files)} arquivos acess√≠veis\")\n                return True\n            else:\n                self.log_test(\"static_files\", False, \n                             f\"Apenas {successful_files}/{len(static_files)} arquivos acess√≠veis\")\n                return False\n                \n        except Exception as e:\n            self.log_test(\"static_files\", False, str(e))\n            return False\n    \n    def test_performance_basic(self) -> bool:\n        \"\"\"Testa performance b√°sica do sistema\"\"\"\n        try:\n            # Medir tempo de resposta da p√°gina principal\n            start_time = time.time()\n            response = self.session.get(f\"{self.base_url}/\", timeout=15)\n            end_time = time.time()\n            \n            response_time = (end_time - start_time) * 1000  # em ms\n            \n            if response_time < 5000:  # Menos de 5 segundos\n                self.log_test(\"performance_basic\", True, \n                             f\"Tempo de resposta: {response_time:.0f}ms\")\n                return True\n            else:\n                self.log_test(\"performance_basic\", False, \n                             f\"Tempo de resposta muito alto: {response_time:.0f}ms\")\n                return False\n                \n        except Exception as e:\n            self.log_test(\"performance_basic\", False, str(e))\n            return False\n    \n    def test_data_integrity(self) -> bool:\n        \"\"\"Testa integridade dos dados no banco\"\"\"\n        try:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            # Verificar se o usu√°rio admin existe\n            cursor.execute(\"SELECT id, username, role FROM user WHERE username = 'admin'\")\n            admin_user = cursor.fetchone()\n            \n            if not admin_user:\n                self.log_test(\"data_integrity\", False, \"Usu√°rio admin n√£o encontrado\")\n                return False\n            \n            # Verificar se h√° chamados de demonstra√ß√£o\n            cursor.execute(\"SELECT COUNT(*) FROM chamado\")\n            chamado_count = cursor.fetchone()[0]\n            \n            if chamado_count == 0:\n                self.log_test(\"data_integrity\", False, \"Nenhum chamado encontrado\")\n                return False\n            \n            # Verificar integridade referencial\n            cursor.execute(\"\"\"\n                SELECT COUNT(*) FROM chamado c \n                LEFT JOIN user u ON c.usuario_id = u.id \n                WHERE u.id IS NULL\n            \"\"\")\n            orphaned_chamados = cursor.fetchone()[0]\n            \n            if orphaned_chamados > 0:\n                self.log_test(\"data_integrity\", False, \n                             f\"{orphaned_chamados} chamados √≥rf√£os encontrados\")\n                return False\n            \n            conn.close()\n            \n            self.log_test(\"data_integrity\", True, \n                         f\"Dados √≠ntegros - Admin OK, {chamado_count} chamados\")\n            return True\n            \n        except Exception as e:\n            self.log_test(\"data_integrity\", False, str(e))\n            return False\n    \n    def run_all_tests(self) -> Dict[str, Any]:\n        \"\"\"Executa todos os testes\"\"\"\n        print(\"üß™ Iniciando testes automatizados do Sistema HelpDesk...\")\n        print(\"=\" * 60)\n        \n        tests = [\n            self.test_database_connectivity,\n            self.test_server_connectivity,\n            self.test_login_page,\n            self.test_api_endpoints,\n            self.test_static_files,\n            self.test_performance_basic,\n            self.test_data_integrity\n        ]\n        \n        passed_tests = 0\n        total_tests = len(tests)\n        \n        for test in tests:\n            try:\n                if test():\n                    passed_tests += 1\n            except Exception as e:\n                self.log_test(test.__name__, False, f\"Erro inesperado: {e}\")\n        \n        print(\"=\" * 60)\n        print(f\"üìä RESULTADO DOS TESTES:\")\n        print(f\"‚úÖ Aprovados: {passed_tests}/{total_tests}\")\n        print(f\"‚ùå Falharam: {total_tests - passed_tests}/{total_tests}\")\n        print(f\"üìà Taxa de sucesso: {(passed_tests/total_tests)*100:.1f}%\")\n        \n        # Determinar status geral\n        if passed_tests == total_tests:\n            overall_status = \"SUCCESS\"\n        elif passed_tests >= total_tests * 0.8:  # 80% ou mais\n            overall_status = \"WARNING\"\n        else:\n            overall_status = \"CRITICAL\"\n        \n        return {\n            'overall_status': overall_status,\n            'passed_tests': passed_tests,\n            'total_tests': total_tests,\n            'success_rate': (passed_tests/total_tests)*100,\n            'test_results': self.test_results,\n            'timestamp': datetime.now().isoformat()\n        }\n\ndef run_tests():\n    \"\"\"Fun√ß√£o principal para executar os testes\"\"\"\n    tester = HelpDeskTester()\n    return tester.run_all_tests()\n\nif __name__ == \"__main__\":\n    # Aguardar um pouco para o servidor inicializar\n    print(\"‚è≥ Aguardando sistema inicializar...\")\n    time.sleep(3)\n    \n    result = run_tests()\n    \n    # Exit code baseado no resultado\n    if result['overall_status'] == 'SUCCESS':\n        sys.exit(0)\n    elif result['overall_status'] == 'WARNING':\n        sys.exit(1)\n    else:\n        sys.exit(2)","size_bytes":12732},"enhanced_logging.py":{"content":"# enhanced_logging.py - Sistema de logs melhorado para o HelpDesk\n\nimport logging\nimport json\nimport os\nfrom datetime import datetime\nfrom typing import Optional, Dict, Any, List\nfrom functools import wraps\nfrom flask import request, session, g\n\n# Configura√ß√£o do sistema de logs\nLOG_DIR = \"logs\"\nos.makedirs(LOG_DIR, exist_ok=True)\n\n# Configurar loggers espec√≠ficos\ndef setup_enhanced_logging():\n    \"\"\"Configura sistema de logging avan√ßado\"\"\"\n    \n    # Logger principal do sistema\n    system_logger = logging.getLogger('helpdesk_system')\n    system_logger.setLevel(logging.INFO)\n    \n    # Handler para logs do sistema\n    system_handler = logging.FileHandler(f'{LOG_DIR}/system.log', encoding='utf-8')\n    system_formatter = logging.Formatter(\n        '%(asctime)s - %(name)s - %(levelname)s - [%(funcName)s:%(lineno)d] - %(message)s'\n    )\n    system_handler.setFormatter(system_formatter)\n    system_logger.addHandler(system_handler)\n    \n    # Logger para a√ß√µes de usu√°rios\n    user_logger = logging.getLogger('helpdesk_users')\n    user_logger.setLevel(logging.INFO)\n    \n    user_handler = logging.FileHandler(f'{LOG_DIR}/user_actions.log', encoding='utf-8')\n    user_formatter = logging.Formatter(\n        '%(asctime)s - %(levelname)s - %(message)s'\n    )\n    user_handler.setFormatter(user_formatter)\n    user_logger.addHandler(user_handler)\n    \n    # Logger para API\n    api_logger = logging.getLogger('helpdesk_api')\n    api_logger.setLevel(logging.INFO)\n    \n    api_handler = logging.FileHandler(f'{LOG_DIR}/api.log', encoding='utf-8')\n    api_formatter = logging.Formatter(\n        '%(asctime)s - API - %(levelname)s - %(message)s'\n    )\n    api_handler.setFormatter(api_formatter)\n    api_logger.addHandler(api_handler)\n    \n    # Logger para performance\n    perf_logger = logging.getLogger('helpdesk_performance')\n    perf_logger.setLevel(logging.INFO)\n    \n    perf_handler = logging.FileHandler(f'{LOG_DIR}/performance.log', encoding='utf-8')\n    perf_formatter = logging.Formatter(\n        '%(asctime)s - PERF - %(message)s'\n    )\n    perf_handler.setFormatter(perf_formatter)\n    perf_logger.addHandler(perf_handler)\n    \n    return {\n        'system': system_logger,\n        'users': user_logger,\n        'api': api_logger,\n        'performance': perf_logger\n    }\n\n# Inst√¢ncias dos loggers\nloggers = setup_enhanced_logging()\n\ndef log_user_action(action: str, details: Optional[Dict[str, Any]] = None, \n                   user_id: Optional[int] = None, username: Optional[str] = None):\n    \"\"\"Log de a√ß√£o do usu√°rio com detalhes\"\"\"\n    try:\n        log_data = {\n            'timestamp': datetime.now().isoformat(),\n            'action': action,\n            'user_id': user_id or session.get('user_id'),\n            'username': username or session.get('username'),\n            'ip_address': request.environ.get('REMOTE_ADDR'),\n            'user_agent': request.headers.get('User-Agent'),\n            'details': details or {}\n        }\n        \n        message = f\"User: {log_data['username']} | Action: {action} | IP: {log_data['ip_address']}\"\n        if details:\n            message += f\" | Details: {json.dumps(details)}\"\n            \n        loggers['users'].info(message)\n        \n    except Exception as e:\n        loggers['system'].error(f\"Erro ao registrar a√ß√£o do usu√°rio: {e}\")\n\ndef log_system_event(event: str, level: str = 'INFO', details: Optional[Dict[str, Any]] = None):\n    \"\"\"Log de evento do sistema\"\"\"\n    try:\n        log_data = {\n            'timestamp': datetime.now().isoformat(),\n            'event': event,\n            'level': level,\n            'details': details or {}\n        }\n        \n        message = f\"Event: {event}\"\n        if details:\n            message += f\" | Details: {json.dumps(details)}\"\n        \n        if level.upper() == 'ERROR':\n            loggers['system'].error(message)\n        elif level.upper() == 'WARNING':\n            loggers['system'].warning(message)\n        else:\n            loggers['system'].info(message)\n            \n    except Exception as e:\n        print(f\"Erro cr√≠tico no sistema de logs: {e}\")\n\ndef log_api_request(endpoint: str, method: str, status_code: int, \n                   response_time: float, details: Optional[Dict[str, Any]] = None):\n    \"\"\"Log de requisi√ß√£o da API\"\"\"\n    try:\n        log_data = {\n            'timestamp': datetime.now().isoformat(),\n            'endpoint': endpoint,\n            'method': method,\n            'status_code': status_code,\n            'response_time_ms': round(response_time * 1000, 2),\n            'ip_address': request.environ.get('REMOTE_ADDR'),\n            'user_agent': request.headers.get('User-Agent'),\n            'details': details or {}\n        }\n        \n        message = f\"{method} {endpoint} | Status: {status_code} | Time: {log_data['response_time_ms']}ms | IP: {log_data['ip_address']}\"\n        \n        if status_code >= 400:\n            loggers['api'].error(message)\n        elif status_code >= 300:\n            loggers['api'].warning(message)\n        else:\n            loggers['api'].info(message)\n            \n    except Exception as e:\n        loggers['system'].error(f\"Erro ao registrar requisi√ß√£o API: {e}\")\n\ndef log_performance_metric(metric_name: str, value: float, unit: str = 'ms', \n                          context: Optional[Dict[str, Any]] = None):\n    \"\"\"Log de m√©trica de performance\"\"\"\n    try:\n        log_data = {\n            'timestamp': datetime.now().isoformat(),\n            'metric': metric_name,\n            'value': value,\n            'unit': unit,\n            'context': context or {}\n        }\n        \n        message = f\"Metric: {metric_name} | Value: {value}{unit}\"\n        if context:\n            message += f\" | Context: {json.dumps(context)}\"\n            \n        loggers['performance'].info(message)\n        \n    except Exception as e:\n        loggers['system'].error(f\"Erro ao registrar m√©trica: {e}\")\n\ndef performance_monitor(metric_name: str):\n    \"\"\"Decorator para monitorar performance de fun√ß√µes\"\"\"\n    def decorator(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            start_time = datetime.now()\n            try:\n                result = func(*args, **kwargs)\n                end_time = datetime.now()\n                duration = (end_time - start_time).total_seconds()\n                \n                log_performance_metric(\n                    f\"{func.__name__}_{metric_name}\",\n                    duration * 1000,\n                    'ms',\n                    {'function': func.__name__, 'success': True}\n                )\n                \n                return result\n            except Exception as e:\n                end_time = datetime.now()\n                duration = (end_time - start_time).total_seconds()\n                \n                log_performance_metric(\n                    f\"{func.__name__}_{metric_name}_error\",\n                    duration * 1000,\n                    'ms',\n                    {'function': func.__name__, 'success': False, 'error': str(e)}\n                )\n                raise\n                \n        return wrapper\n    return decorator\n\ndef get_log_stats() -> Dict[str, Any]:\n    \"\"\"Retorna estat√≠sticas dos logs\"\"\"\n    try:\n        stats = {\n            'log_files': {},\n            'total_entries': 0,\n            'last_updated': datetime.now().isoformat()\n        }\n        \n        log_files = ['system.log', 'user_actions.log', 'api.log', 'performance.log']\n        \n        for log_file in log_files:\n            file_path = f\"{LOG_DIR}/{log_file}\"\n            if os.path.exists(file_path):\n                file_stats = os.stat(file_path)\n                with open(file_path, 'r', encoding='utf-8') as f:\n                    line_count = sum(1 for line in f)\n                \n                stats['log_files'][log_file] = {\n                    'size_bytes': file_stats.st_size,\n                    'size_mb': round(file_stats.st_size / 1024 / 1024, 2),\n                    'line_count': line_count,\n                    'last_modified': datetime.fromtimestamp(file_stats.st_mtime).isoformat()\n                }\n                \n                stats['total_entries'] += line_count\n            else:\n                stats['log_files'][log_file] = {\n                    'exists': False\n                }\n        \n        return stats\n        \n    except Exception as e:\n        loggers['system'].error(f\"Erro ao obter estat√≠sticas de logs: {e}\")\n        return {'error': str(e)}\n\ndef search_logs(query: str, log_type: str = 'all', limit: int = 100) -> List[Dict[str, Any]]:\n    \"\"\"Busca nos logs por termo espec√≠fico\"\"\"\n    try:\n        results = []\n        log_files = []\n        \n        if log_type == 'all':\n            log_files = ['system.log', 'user_actions.log', 'api.log', 'performance.log']\n        else:\n            log_files = [f\"{log_type}.log\"]\n        \n        for log_file in log_files:\n            file_path = f\"{LOG_DIR}/{log_file}\"\n            if os.path.exists(file_path):\n                with open(file_path, 'r', encoding='utf-8') as f:\n                    lines = f.readlines()\n                    \n                for i, line in enumerate(reversed(lines)):\n                    if len(results) >= limit:\n                        break\n                        \n                    if query.lower() in line.lower():\n                        results.append({\n                            'file': log_file,\n                            'line_number': len(lines) - i,\n                            'content': line.strip(),\n                            'timestamp': line.split(' - ')[0] if ' - ' in line else ''\n                        })\n        \n        # Ordenar por timestamp (mais recentes primeiro)\n        results.sort(key=lambda x: x['timestamp'], reverse=True)\n        return results[:limit]\n        \n    except Exception as e:\n        loggers['system'].error(f\"Erro ao buscar logs: {e}\")\n        return [{'error': str(e)}]\n\n# Log de inicializa√ß√£o\nlog_system_event(\"Sistema de logging avan√ßado inicializado\", \"INFO\", {\n    'log_directory': LOG_DIR,\n    'loggers_configured': list(loggers.keys())\n})\n\nprint(\"‚úÖ Sistema de logging avan√ßado configurado\")\nprint(f\"üìÅ Logs salvos em: {LOG_DIR}/\")\nprint(f\"üîç Loggers dispon√≠veis: {', '.join(loggers.keys())}\")","size_bytes":10277},"metrics_dashboard.py":{"content":"# metrics_dashboard.py - Dashboard de m√©tricas avan√ßadas\n\nfrom datetime import datetime, timedelta\nfrom typing import Dict, List, Any, Optional\nimport sqlite3\nimport json\nfrom collections import defaultdict, Counter\n\nclass MetricsDashboard:\n    \"\"\"Sistema de m√©tricas avan√ßadas para o HelpDesk\"\"\"\n    \n    def __init__(self, db_path: str = \"sistema_os.db\"):\n        self.db_path = db_path\n        \n    def _get_db_connection(self):\n        \"\"\"Conex√£o com o banco de dados\"\"\"\n        return sqlite3.connect(self.db_path)\n    \n    def get_system_health(self) -> Dict[str, Any]:\n        \"\"\"M√©tricas de sa√∫de do sistema\"\"\"\n        try:\n            conn = self._get_db_connection()\n            cursor = conn.cursor()\n            \n            # Contadores b√°sicos\n            cursor.execute(\"SELECT COUNT(*) FROM user WHERE active = 1\")\n            active_users = cursor.fetchone()[0]\n            \n            cursor.execute(\"SELECT COUNT(*) FROM chamado\")\n            total_chamados = cursor.fetchone()[0]\n            \n            cursor.execute(\"SELECT COUNT(*) FROM system_activity WHERE timestamp >= datetime('now', '-24 hours')\")\n            activities_24h = cursor.fetchone()[0]\n            \n            # Status dos chamados\n            cursor.execute(\"\"\"\n                SELECT status, COUNT(*) \n                FROM chamado \n                GROUP BY status\n            \"\"\")\n            status_counts = dict(cursor.fetchall())\n            \n            # Chamados por urg√™ncia\n            cursor.execute(\"\"\"\n                SELECT urgencia, COUNT(*) \n                FROM chamado \n                GROUP BY urgencia\n            \"\"\")\n            urgencia_counts = dict(cursor.fetchall())\n            \n            # Chamados recentes (√∫ltimas 24h)\n            cursor.execute(\"\"\"\n                SELECT COUNT(*) \n                FROM chamado \n                WHERE criado_em >= datetime('now', '-24 hours')\n            \"\"\")\n            chamados_24h = cursor.fetchone()[0]\n            \n            # Chamados resolvidos nas √∫ltimas 24h\n            cursor.execute(\"\"\"\n                SELECT COUNT(*) \n                FROM chamado \n                WHERE fechado_em >= datetime('now', '-24 hours') \n                AND status IN ('Resolvido', 'Fechado')\n            \"\"\")\n            resolvidos_24h = cursor.fetchone()[0]\n            \n            # Taxa de resolu√ß√£o\n            taxa_resolucao = (resolvidos_24h / max(chamados_24h, 1)) * 100 if chamados_24h > 0 else 0\n            \n            conn.close()\n            \n            health_status = 'healthy'\n            if chamados_24h > 20:  # Muitos chamados\n                health_status = 'warning'\n            if taxa_resolucao < 50:  # Taxa baixa de resolu√ß√£o\n                health_status = 'critical'\n                \n            return {\n                'status': health_status,\n                'active_users': active_users,\n                'total_chamados': total_chamados,\n                'activities_24h': activities_24h,\n                'chamados_24h': chamados_24h,\n                'resolvidos_24h': resolvidos_24h,\n                'taxa_resolucao': round(taxa_resolucao, 2),\n                'status_distribution': status_counts,\n                'urgencia_distribution': urgencia_counts,\n                'timestamp': datetime.now().isoformat()\n            }\n            \n        except Exception as e:\n            return {\n                'status': 'error',\n                'error': str(e),\n                'timestamp': datetime.now().isoformat()\n            }\n    \n    def get_performance_metrics(self, days: int = 7) -> Dict[str, Any]:\n        \"\"\"M√©tricas de performance dos √∫ltimos X dias\"\"\"\n        try:\n            conn = self._get_db_connection()\n            cursor = conn.cursor()\n            \n            start_date = (datetime.now() - timedelta(days=days)).strftime('%Y-%m-%d')\n            \n            # Chamados por dia\n            cursor.execute(\"\"\"\n                SELECT DATE(criado_em) as dia, COUNT(*) as total\n                FROM chamado \n                WHERE criado_em >= ?\n                GROUP BY DATE(criado_em)\n                ORDER BY dia\n            \"\"\", (start_date,))\n            \n            chamados_por_dia = {\n                row[0]: row[1] for row in cursor.fetchall()\n            }\n            \n            # Tempo m√©dio de resolu√ß√£o por setor\n            cursor.execute(\"\"\"\n                SELECT setor, \n                       AVG(julianday(fechado_em) - julianday(criado_em)) * 24 as horas_media\n                FROM chamado \n                WHERE fechado_em IS NOT NULL \n                AND criado_em >= ?\n                GROUP BY setor\n            \"\"\", (start_date,))\n            \n            tempo_resolucao_setor = {\n                row[0]: round(row[1], 2) for row in cursor.fetchall()\n            }\n            \n            # Chamados por usu√°rio (top 10)\n            cursor.execute(\"\"\"\n                SELECT u.username, COUNT(c.id) as total_chamados\n                FROM chamado c\n                JOIN user u ON c.usuario_id = u.id\n                WHERE c.criado_em >= ?\n                GROUP BY u.username\n                ORDER BY total_chamados DESC\n                LIMIT 10\n            \"\"\", (start_date,))\n            \n            top_usuarios = {\n                row[0]: row[1] for row in cursor.fetchall()\n            }\n            \n            # Distribui√ß√£o por hora do dia\n            cursor.execute(\"\"\"\n                SELECT strftime('%H', criado_em) as hora, COUNT(*) as total\n                FROM chamado \n                WHERE criado_em >= ?\n                GROUP BY strftime('%H', criado_em)\n                ORDER BY hora\n            \"\"\", (start_date,))\n            \n            chamados_por_hora = {\n                f\"{row[0]}:00\": row[1] for row in cursor.fetchall()\n            }\n            \n            # Efici√™ncia por setor\n            cursor.execute(\"\"\"\n                SELECT setor,\n                       COUNT(*) as total,\n                       SUM(CASE WHEN status IN ('Resolvido', 'Fechado') THEN 1 ELSE 0 END) as resolvidos\n                FROM chamado \n                WHERE criado_em >= ?\n                GROUP BY setor\n            \"\"\", (start_date,))\n            \n            eficiencia_setor = {}\n            for row in cursor.fetchall():\n                setor, total, resolvidos = row\n                eficiencia = (resolvidos / total * 100) if total > 0 else 0\n                eficiencia_setor[setor] = {\n                    'total': total,\n                    'resolvidos': resolvidos,\n                    'eficiencia_pct': round(eficiencia, 2)\n                }\n            \n            conn.close()\n            \n            return {\n                'period_days': days,\n                'chamados_por_dia': chamados_por_dia,\n                'tempo_resolucao_setor': tempo_resolucao_setor,\n                'top_usuarios': top_usuarios,\n                'chamados_por_hora': chamados_por_hora,\n                'eficiencia_setor': eficiencia_setor,\n                'timestamp': datetime.now().isoformat()\n            }\n            \n        except Exception as e:\n            return {\n                'error': str(e),\n                'timestamp': datetime.now().isoformat()\n            }\n    \n    def get_user_metrics(self, user_id: Optional[int] = None) -> Dict[str, Any]:\n        \"\"\"M√©tricas espec√≠ficas de usu√°rio\"\"\"\n        try:\n            conn = self._get_db_connection()\n            cursor = conn.cursor()\n            \n            if user_id:\n                # M√©tricas para usu√°rio espec√≠fico\n                cursor.execute(\"\"\"\n                    SELECT username, role, setor, created_at\n                    FROM user WHERE id = ?\n                \"\"\", (user_id,))\n                user_info = cursor.fetchone()\n                \n                if not user_info:\n                    return {'error': 'Usu√°rio n√£o encontrado'}\n                \n                # Chamados criados pelo usu√°rio\n                cursor.execute(\"\"\"\n                    SELECT COUNT(*) FROM chamado WHERE usuario_id = ?\n                \"\"\", (user_id,))\n                chamados_criados = cursor.fetchone()[0]\n                \n                # Chamados fechados pelo usu√°rio (se for operador/admin)\n                cursor.execute(\"\"\"\n                    SELECT COUNT(*) FROM chamado WHERE fechado_por_id = ?\n                \"\"\", (user_id,))\n                chamados_fechados = cursor.fetchone()[0]\n                \n                # Atividades recentes\n                cursor.execute(\"\"\"\n                    SELECT action_type, COUNT(*) \n                    FROM system_activity \n                    WHERE user_id = ? \n                    AND timestamp >= datetime('now', '-7 days')\n                    GROUP BY action_type\n                    ORDER BY COUNT(*) DESC\n                    LIMIT 10\n                \"\"\", (user_id,))\n                \n                atividades = dict(cursor.fetchall())\n                \n                return {\n                    'user_info': {\n                        'username': user_info[0],\n                        'role': user_info[1], \n                        'setor': user_info[2],\n                        'created_at': user_info[3]\n                    },\n                    'chamados_criados': chamados_criados,\n                    'chamados_fechados': chamados_fechados,\n                    'atividades_recentes': atividades,\n                    'timestamp': datetime.now().isoformat()\n                }\n            else:\n                # M√©tricas gerais de usu√°rios\n                cursor.execute(\"\"\"\n                    SELECT role, COUNT(*) FROM user WHERE active = 1 GROUP BY role\n                \"\"\")\n                usuarios_por_role = dict(cursor.fetchall())\n                \n                cursor.execute(\"\"\"\n                    SELECT setor, COUNT(*) FROM user \n                    WHERE active = 1 AND setor != '' \n                    GROUP BY setor\n                \"\"\")\n                usuarios_por_setor = dict(cursor.fetchall())\n                \n                # Usu√°rios mais ativos (por chamados criados)\n                cursor.execute(\"\"\"\n                    SELECT u.username, COUNT(c.id) as total\n                    FROM user u\n                    LEFT JOIN chamado c ON u.id = c.usuario_id\n                    WHERE u.active = 1\n                    GROUP BY u.username\n                    ORDER BY total DESC\n                    LIMIT 10\n                \"\"\")\n                usuarios_ativos = {row[0]: row[1] for row in cursor.fetchall()}\n                \n                return {\n                    'usuarios_por_role': usuarios_por_role,\n                    'usuarios_por_setor': usuarios_por_setor,\n                    'usuarios_mais_ativos': usuarios_ativos,\n                    'timestamp': datetime.now().isoformat()\n                }\n                \n            conn.close()\n            \n        except Exception as e:\n            return {\n                'error': str(e),\n                'timestamp': datetime.now().isoformat()\n            }\n    \n    def get_trend_analysis(self, metric: str = 'chamados', days: int = 30) -> Dict[str, Any]:\n        \"\"\"An√°lise de tend√™ncias\"\"\"\n        try:\n            conn = self._get_db_connection()\n            cursor = conn.cursor()\n            \n            start_date = (datetime.now() - timedelta(days=days)).strftime('%Y-%m-%d')\n            \n            if metric == 'chamados':\n                # Tend√™ncia de chamados\n                cursor.execute(\"\"\"\n                    SELECT DATE(criado_em) as dia, \n                           COUNT(*) as total,\n                           SUM(CASE WHEN urgencia = 'Cr√≠tica' THEN 1 ELSE 0 END) as criticos,\n                           SUM(CASE WHEN urgencia = 'Alta' THEN 1 ELSE 0 END) as altos\n                    FROM chamado \n                    WHERE criado_em >= ?\n                    GROUP BY DATE(criado_em)\n                    ORDER BY dia\n                \"\"\", (start_date,))\n                \n                data = cursor.fetchall()\n                trend_data = []\n                \n                for row in data:\n                    trend_data.append({\n                        'date': row[0],\n                        'total': row[1],\n                        'criticos': row[2],\n                        'altos': row[3]\n                    })\n                \n                # Calcular tend√™ncia (regress√£o linear simples)\n                if len(trend_data) >= 2:\n                    values = [item['total'] for item in trend_data]\n                    n = len(values)\n                    \n                    # M√©dia m√≥vel de 7 dias\n                    moving_avg = []\n                    for i in range(len(values)):\n                        start_idx = max(0, i - 6)\n                        avg = sum(values[start_idx:i+1]) / (i - start_idx + 1)\n                        moving_avg.append(round(avg, 2))\n                    \n                    # Tend√™ncia (diferen√ßa entre √∫ltimos e primeiros valores)\n                    trend = 'stable'\n                    if len(values) >= 7:\n                        recent_avg = sum(values[-7:]) / 7\n                        earlier_avg = sum(values[:7]) / 7\n                        \n                        if recent_avg > earlier_avg * 1.1:\n                            trend = 'increasing'\n                        elif recent_avg < earlier_avg * 0.9:\n                            trend = 'decreasing'\n                    \n                    return {\n                        'metric': metric,\n                        'period_days': days,\n                        'trend_direction': trend,\n                        'data_points': trend_data,\n                        'moving_average': moving_avg,\n                        'summary': {\n                            'total_period': sum(values),\n                            'daily_average': round(sum(values) / len(values), 2),\n                            'peak_day': max(trend_data, key=lambda x: x['total']),\n                            'min_day': min(trend_data, key=lambda x: x['total'])\n                        },\n                        'timestamp': datetime.now().isoformat()\n                    }\n                \n            conn.close()\n            \n            return {\n                'metric': metric,\n                'error': 'Dados insuficientes para an√°lise de tend√™ncia',\n                'timestamp': datetime.now().isoformat()\n            }\n            \n        except Exception as e:\n            return {\n                'metric': metric,\n                'error': str(e),\n                'timestamp': datetime.now().isoformat()\n            }\n    \n    def generate_alerts(self) -> List[Dict[str, Any]]:\n        \"\"\"Gera alertas autom√°ticos baseados nas m√©tricas\"\"\"\n        alerts = []\n        \n        try:\n            health = self.get_system_health()\n            performance = self.get_performance_metrics(7)\n            \n            # Alert: Muitos chamados abertos\n            if health['status_distribution'].get('Aberto', 0) > 10:\n                alerts.append({\n                    'type': 'warning',\n                    'title': 'Muitos chamados abertos',\n                    'message': f\"Existem {health['status_distribution']['Aberto']} chamados em aberto\",\n                    'severity': 'medium',\n                    'timestamp': datetime.now().isoformat()\n                })\n            \n            # Alert: Taxa de resolu√ß√£o baixa\n            if health['taxa_resolucao'] < 70:\n                alerts.append({\n                    'type': 'warning', \n                    'title': 'Taxa de resolu√ß√£o baixa',\n                    'message': f\"Taxa de resolu√ß√£o nas √∫ltimas 24h: {health['taxa_resolucao']}%\",\n                    'severity': 'high',\n                    'timestamp': datetime.now().isoformat()\n                })\n            \n            # Alert: Setor com tempo alto de resolu√ß√£o\n            for setor, tempo in performance['tempo_resolucao_setor'].items():\n                if tempo > 48:  # Mais de 48 horas\n                    alerts.append({\n                        'type': 'alert',\n                        'title': f'Tempo alto de resolu√ß√£o - {setor}',\n                        'message': f\"Tempo m√©dio de resolu√ß√£o: {tempo:.1f} horas\",\n                        'severity': 'medium',\n                        'timestamp': datetime.now().isoformat()\n                    })\n            \n            # Alert: Poucas atividades no sistema\n            if health['activities_24h'] < 5:\n                alerts.append({\n                    'type': 'info',\n                    'title': 'Baixa atividade no sistema',\n                    'message': f\"Apenas {health['activities_24h']} atividades nas √∫ltimas 24h\",\n                    'severity': 'low',\n                    'timestamp': datetime.now().isoformat()\n                })\n                \n        except Exception as e:\n            alerts.append({\n                'type': 'error',\n                'title': 'Erro ao gerar alertas',\n                'message': str(e),\n                'severity': 'high',\n                'timestamp': datetime.now().isoformat()\n            })\n        \n        return alerts\n\n# Inst√¢ncia global\nmetrics_dashboard = MetricsDashboard()\n\nprint(\"‚úÖ Dashboard de m√©tricas configurado\")\nprint(\"üìä M√©tricas dispon√≠veis: sa√∫de, performance, usu√°rios, tend√™ncias\")\nprint(\"üö® Sistema de alertas autom√°ticos ativado\")","size_bytes":17465},"type_fixes.py":{"content":"# type_fixes.py - Melhorias de tipagem para o sistema HelpDesk\n\nfrom typing import Optional, Dict, Any, Union, List, Tuple\nfrom datetime import datetime\nfrom flask_sqlalchemy import SQLAlchemy\n\n# Tipo personalizado para models SQLAlchemy\nModelType = Union[Any, None]\n\n# Fun√ß√µes melhoradas com tipagem correta\ndef safe_log_login(user_id: int, username: str, ip_address: Optional[str] = None, \n                   user_agent: Optional[str] = None, session_id: Optional[str] = None) -> None:\n    \"\"\"Log de login com tipagem correta\"\"\"\n    pass\n\ndef safe_log_logout(user_id: int, username: str, ip_address: Optional[str] = None, \n                    session_id: Optional[str] = None) -> None:\n    \"\"\"Log de logout com tipagem correta\"\"\"\n    pass\n\ndef safe_log_admin_action(user_id: int, username: str, action_description: str, \n                          details: Optional[Dict[str, Any]] = None) -> None:\n    \"\"\"Log de a√ß√£o admin com tipagem correta\"\"\"\n    pass\n\ndef safe_log_system_event(event_type: str, description: str, \n                          details: Optional[Dict[str, Any]] = None) -> None:\n    \"\"\"Log de evento sistema com tipagem correta\"\"\"\n    pass\n\ndef safe_is_licensed() -> bool:\n    \"\"\"Verifica√ß√£o de licen√ßa com tipagem correta\"\"\"\n    return True\n\ndef safe_get_license_status() -> Dict[str, Any]:\n    \"\"\"Status da licen√ßa com tipagem correta\"\"\"\n    return {'licensed': True, 'status': 'active'}\n\ndef safe_check_feature_access(feature: str) -> bool:\n    \"\"\"Verifica√ß√£o de acesso a feature com tipagem correta\"\"\"\n    return True\n\n# Fun√ß√µes utilit√°rias para valida√ß√£o de tipos\ndef validate_file_extension(filename: Optional[str]) -> bool:\n    \"\"\"Valida se o arquivo tem extens√£o v√°lida\"\"\"\n    if filename is None:\n        return False\n    return '.' in filename\n\ndef safe_splitext(filename: Optional[str]) -> Tuple[str, str]:\n    \"\"\"Divis√£o de extens√£o de arquivo com verifica√ß√£o\"\"\"\n    if filename is None:\n        return '', ''\n    import os\n    return os.path.splitext(filename)\n\ndef safe_datetime_format(dt_value: Optional[datetime]) -> str:\n    \"\"\"Formata√ß√£o segura de datetime\"\"\"\n    if dt_value is None:\n        return ''\n    try:\n        return dt_value.strftime('%Y-%m-%d %H:%M:%S')\n    except:\n        return ''\n\n# Classes de tipo para modelos\nclass SafeUser:\n    \"\"\"Tipo seguro para User model\"\"\"\n    def __init__(self, model_instance: Any = None):\n        self._instance = model_instance\n        \n    @property\n    def id(self) -> Optional[int]:\n        return getattr(self._instance, 'id', None)\n    \n    @property\n    def username(self) -> Optional[str]:\n        return getattr(self._instance, 'username', None)\n        \n    @property\n    def is_admin(self) -> bool:\n        return getattr(self._instance, 'is_admin', False) if self._instance else False\n        \n    @property\n    def is_operator_like(self) -> bool:\n        return getattr(self._instance, 'is_operator_like', False) if self._instance else False\n        \n    def has_permission(self, permission: str) -> bool:\n        if not self._instance:\n            return False\n        return getattr(self._instance, 'has_permission', lambda x: False)(permission)\n    \n    def can_access_sector(self, sector: str) -> bool:\n        if not self._instance:\n            return False\n        return getattr(self._instance, 'can_access_sector', lambda x: False)(sector)\n        \n    def get_sectors(self) -> List[str]:\n        if not self._instance:\n            return []\n        return getattr(self._instance, 'get_sectors', lambda: [])()\n        \n    def get_sector_names(self) -> List[str]:\n        if not self._instance:\n            return []\n        return getattr(self._instance, 'get_sector_names', lambda: [])()\n\nclass SafeChamado:\n    \"\"\"Tipo seguro para Chamado model\"\"\"\n    def __init__(self, model_instance: Any = None):\n        self._instance = model_instance\n        \n    @property\n    def id(self) -> Optional[int]:\n        return getattr(self._instance, 'id', None)\n\n# Constantes de tipo\nSETOR_TYPES = {\n    \"T.I\": \"ti\",\n    \"Manuten√ß√£o\": \"manutencao\", \n    \"CCIH / SESMT / Manuten√ß√£o de Ar condicionado\": \"ccih_sesmt_arcondicionado\",\n    \"Telefonia e outros servi√ßos\": \"telefonia_outros\"\n}\n\nSTATUS_TYPES = [\"Aberto\", \"Em andamento\", \"Resolvido\", \"Fechado\"]\nPRIORITY_TYPES = [\"Baixa\", \"Normal\", \"Alta\", \"Cr√≠tica\"]\nROLE_TYPES = [\"admin\", \"operador\", \"user\"]\n\n# Validadores de tipo\ndef validate_sector(sector: str) -> bool:\n    \"\"\"Valida se o setor √© v√°lido\"\"\"\n    return sector in SETOR_TYPES.keys()\n\ndef validate_status(status: str) -> bool:\n    \"\"\"Valida se o status √© v√°lido\"\"\"\n    return status in STATUS_TYPES\n\ndef validate_priority(priority: str) -> bool:\n    \"\"\"Valida se a prioridade √© v√°lida\"\"\"\n    return priority in PRIORITY_TYPES\n\ndef validate_role(role: str) -> bool:\n    \"\"\"Valida se o papel/role √© v√°lido\"\"\"\n    return role in ROLE_TYPES","size_bytes":4876},"blueprints/__init__.py":{"content":"# Blueprints package","size_bytes":20},"blueprints/admin.py":{"content":"\"\"\"\nBlueprint for admin panel routes\n\"\"\"\nfrom flask import Blueprint, render_template, request, redirect, url_for, session, flash, jsonify\nfrom models import User, Chamado, db\nfrom functools import wraps\nimport json\nimport os\nimport psutil\n\nadmin_bp = Blueprint('admin', __name__, url_prefix='/admin')\n\ndef admin_required(f):\n    @wraps(f)\n    def decorated(*args, **kwargs):\n        if \"user_id\" not in session:\n            return redirect(url_for(\"auth.login\"))\n        \n        user_permissions = session.get(\"permissions\", [])\n        if \"admin_access\" not in user_permissions and session.get(\"role\") != \"admin\":\n            flash(\"Acesso negado. Voc√™ n√£o √© um administrador.\", \"error\")\n            return redirect(url_for(\"main.dashboard\"))\n        return f(*args, **kwargs)\n    return decorated\n\n@admin_bp.route(\"/\")\n@admin_required\ndef dashboard():\n    # Admin dashboard statistics\n    total_users = User.query.count()\n    total_tickets = Chamado.query.count()\n    open_tickets = Chamado.query.filter_by(status=\"Aberto\").count()\n    \n    # System info\n    try:\n        memory_info = psutil.virtual_memory()\n        disk_info = psutil.disk_usage('/')\n        system_info = {\n            'memory_percent': memory_info.percent,\n            'memory_used': round(memory_info.used / (1024**3), 2),\n            'memory_total': round(memory_info.total / (1024**3), 2),\n            'disk_percent': disk_info.percent,\n            'disk_used': round(disk_info.used / (1024**3), 2),\n            'disk_total': round(disk_info.total / (1024**3), 2)\n        }\n    except Exception as e:\n        system_info = {'error': str(e)}\n    \n    stats = {\n        'users': total_users,\n        'tickets': total_tickets,\n        'open_tickets': open_tickets,\n        'system': system_info\n    }\n    \n    return render_template(\"admin/dashboard.html\", stats=stats)\n\n@admin_bp.route(\"/backup\")\n@admin_required\ndef backup():\n    # Backup functionality will be moved here\n    return render_template(\"admin/backup.html\")\n\n@admin_bp.route(\"/logs\")\n@admin_required\ndef logs():\n    # Logs viewing functionality will be moved here\n    return render_template(\"admin/logs.html\")\n\n@admin_bp.route(\"/monitoring\")\n@admin_required\ndef monitoring():\n    # System monitoring will be moved here\n    return render_template(\"admin/monitoring.html\")\n\n@admin_bp.route(\"/monitoring/data\")\n@admin_required\ndef monitoring_data():\n    # Return JSON data for monitoring dashboard\n    try:\n        memory_info = psutil.virtual_memory()\n        cpu_percent = psutil.cpu_percent()\n        \n        data = {\n            'memory_percent': memory_info.percent,\n            'cpu_percent': cpu_percent,\n            'timestamp': datetime.now().isoformat()\n        }\n        return jsonify(data)\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n\n@admin_bp.route(\"/maintenance\", methods=[\"GET\", \"POST\"])\n@admin_required\ndef maintenance():\n    # System maintenance functionality will be moved here\n    if request.method == \"POST\":\n        # Handle maintenance actions\n        pass\n    return render_template(\"admin/maintenance.html\")","size_bytes":3103},"blueprints/auth.py":{"content":"\"\"\"\nBlueprint for authentication routes\n\"\"\"\nfrom flask import Blueprint, render_template, request, redirect, url_for, session, flash\nfrom werkzeug.security import check_password_hash\nfrom models import User\nfrom activity_logger import log_login, log_logout\nimport json\n\nauth_bp = Blueprint('auth', __name__)\n\n@auth_bp.route(\"/login\", methods=[\"GET\", \"POST\"])\ndef login():\n    if request.method == \"POST\":\n        username = request.form.get(\"username\")\n        password = request.form.get(\"password\")\n        \n        if not username or not password:\n            flash(\"Por favor, preencha todos os campos.\", \"error\")\n            return render_template(\"login.html\")\n        \n        user = User.query.filter_by(username=username).first()\n        if user and check_password_hash(user.password_hash, password):\n            session[\"user_id\"] = user.id\n            session[\"username\"] = user.username\n            session[\"role\"] = user.role\n            session[\"setor\"] = user.setor\n            session[\"permissions\"] = json.loads(user.permissions or \"[]\")\n            \n            # Log login\n            try:\n                log_login(user.id, user.username)\n            except Exception as e:\n                print(f\"Erro ao registrar login: {e}\")\n            \n            return redirect(url_for(\"main.dashboard\"))\n        else:\n            flash(\"Usu√°rio ou senha inv√°lidos.\", \"error\")\n    \n    return render_template(\"login.html\")\n\n@auth_bp.route(\"/logout\")\ndef logout():\n    try:\n        if \"user_id\" in session and \"username\" in session:\n            log_logout(session[\"user_id\"], session[\"username\"])\n    except Exception as e:\n        print(f\"Erro ao registrar logout: {e}\")\n    \n    session.clear()\n    return redirect(url_for(\"auth.login\"))","size_bytes":1752},"blueprints/main.py":{"content":"\"\"\"\nBlueprint for main dashboard and core routes\n\"\"\"\nfrom flask import Blueprint, render_template, session, redirect, url_for, request\nfrom models import User, Chamado, db\nfrom functools import wraps\nimport json\n\nmain_bp = Blueprint('main', __name__)\n\ndef login_required(f):\n    @wraps(f)\n    def decorated(*args, **kwargs):\n        if \"user_id\" not in session:\n            return redirect(url_for(\"auth.login\"))\n        return f(*args, **kwargs)\n    return decorated\n\n@main_bp.route(\"/\")\ndef dashboard():\n    if \"user_id\" not in session:\n        return redirect(url_for(\"auth.login\"))\n    \n    # Estat√≠sticas b√°sicas\n    total_chamados = Chamado.query.count()\n    chamados_abertos = Chamado.query.filter_by(status=\"Aberto\").count()\n    chamados_fechados = Chamado.query.filter_by(status=\"Fechado\").count()\n    \n    # Chamados recentes\n    chamados_recentes = Chamado.query.order_by(Chamado.data_abertura.desc()).limit(5).all()\n    \n    stats = {\n        'total': total_chamados,\n        'abertos': chamados_abertos,\n        'fechados': chamados_fechados,\n        'em_andamento': total_chamados - chamados_abertos - chamados_fechados\n    }\n    \n    return render_template(\"dashboard.html\", \n                         stats=stats, \n                         chamados=chamados_recentes)\n\n@main_bp.route(\"/abrir_chamado\", methods=[\"GET\", \"POST\"])\n@login_required\ndef abrir_chamado():\n    if request.method == \"POST\":\n        # Logic for creating ticket will be moved here\n        pass\n    return render_template(\"abrir_chamado.html\")","size_bytes":1530},"blueprints/reports.py":{"content":"\"\"\"\nBlueprint for reports and analytics routes\n\"\"\"\nfrom flask import Blueprint, render_template, request, redirect, url_for, session, flash, send_file\nfrom models import Chamado, User, db\nfrom functools import wraps\nfrom datetime import datetime, timedelta\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom reportlab.pdfgen import canvas\nimport io\nimport os\n\nreports_bp = Blueprint('reports', __name__, url_prefix='/relatorios')\n\ndef login_required(f):\n    @wraps(f)\n    def decorated(*args, **kwargs):\n        if \"user_id\" not in session:\n            return redirect(url_for(\"auth.login\"))\n        return f(*args, **kwargs)\n    return decorated\n\ndef reports_access_required(f):\n    @wraps(f)\n    def decorated(*args, **kwargs):\n        user_permissions = session.get(\"permissions\", [])\n        if \"view_reports\" not in user_permissions and session.get(\"role\") != \"admin\":\n            flash(\"Voc√™ n√£o tem permiss√£o para acessar relat√≥rios.\", \"error\")\n            return redirect(url_for(\"main.dashboard\"))\n        return f(*args, **kwargs)\n    return decorated\n\n@reports_bp.route(\"/\")\n@login_required\n@reports_access_required\ndef dashboard():\n    # Reports dashboard\n    return render_template(\"relatorios/dashboard.html\")\n\n@reports_bp.route(\"/chamados\")\n@login_required\n@reports_access_required\ndef tickets_report():\n    # Generate tickets report\n    return render_template(\"relatorios/chamados.html\")\n\n@reports_bp.route(\"/usuarios\")\n@login_required\n@reports_access_required\ndef users_report():\n    # Generate users report\n    return render_template(\"relatorios/usuarios.html\")\n\n@reports_bp.route(\"/performance\")\n@login_required\n@reports_access_required\ndef performance_report():\n    # Generate performance report\n    return render_template(\"relatorios/performance.html\")\n\n@reports_bp.route(\"/export/pdf\")\n@login_required\n@reports_access_required\ndef export_pdf():\n    # PDF export logic will be moved here\n    pass\n\n@reports_bp.route(\"/export/excel\")\n@login_required\n@reports_access_required\ndef export_excel():\n    # Excel export logic will be moved here\n    pass","size_bytes":2077},"blueprints/tickets.py":{"content":"\"\"\"\nBlueprint for ticket management routes\n\"\"\"\nfrom flask import Blueprint, render_template, request, redirect, url_for, session, flash\nfrom models import Chamado, User, db\nfrom werkzeug.utils import secure_filename\nfrom datetime import datetime\nfrom functools import wraps\nimport os\n\ntickets_bp = Blueprint('tickets', __name__, url_prefix='/chamados')\n\ndef login_required(f):\n    @wraps(f)\n    def decorated(*args, **kwargs):\n        if \"user_id\" not in session:\n            return redirect(url_for(\"auth.login\"))\n        return f(*args, **kwargs)\n    return decorated\n\n@tickets_bp.route(\"/\")\n@login_required\ndef list_tickets():\n    chamados = Chamado.query.order_by(Chamado.data_abertura.desc()).all()\n    return render_template(\"chamados.html\", chamados=chamados)\n\n@tickets_bp.route(\"/novo\", methods=[\"GET\", \"POST\"])\n@login_required\ndef create_ticket():\n    if request.method == \"POST\":\n        # Ticket creation logic will be moved here from app.py\n        pass\n    return render_template(\"abrir_chamado.html\")\n\n@tickets_bp.route(\"/editar/<int:ticket_id>\", methods=[\"GET\", \"POST\"])\n@login_required\ndef edit_ticket(ticket_id):\n    ticket = Chamado.query.get_or_404(ticket_id)\n    \n    # Check permissions\n    user_permissions = session.get(\"permissions\", [])\n    if (\"edit_tickets\" not in user_permissions and \n        ticket.usuario_id != session.get(\"user_id\") and \n        session.get(\"role\") != \"admin\"):\n        flash(\"Voc√™ n√£o tem permiss√£o para editar este chamado.\", \"error\")\n        return redirect(url_for(\"tickets.list_tickets\"))\n    \n    if request.method == \"POST\":\n        # Ticket editing logic will be moved here\n        pass\n    \n    return render_template(\"editar_chamado.html\", chamado=ticket)\n\n@tickets_bp.route(\"/fechar/<int:ticket_id>\", methods=[\"GET\", \"POST\"])\n@login_required\ndef close_ticket(ticket_id):\n    ticket = Chamado.query.get_or_404(ticket_id)\n    \n    # Check permissions\n    user_permissions = session.get(\"permissions\", [])\n    if \"close_tickets\" not in user_permissions and session.get(\"role\") != \"admin\":\n        flash(\"Voc√™ n√£o tem permiss√£o para fechar chamados.\", \"error\")\n        return redirect(url_for(\"tickets.list_tickets\"))\n    \n    if request.method == \"POST\":\n        # Ticket closing logic will be moved here\n        pass\n    \n    return render_template(\"fechar_chamado.html\", chamado=ticket)\n\n@tickets_bp.route(\"/view/<int:ticket_id>\")\n@login_required\ndef view_ticket(ticket_id):\n    ticket = Chamado.query.get_or_404(ticket_id)\n    return render_template(\"view_chamado.html\", chamado=ticket)\n\n@tickets_bp.route(\"/excluir/<int:ticket_id>\")\n@login_required\ndef delete_ticket(ticket_id):\n    # Check permissions\n    user_permissions = session.get(\"permissions\", [])\n    if \"delete_tickets\" not in user_permissions and session.get(\"role\") != \"admin\":\n        flash(\"Voc√™ n√£o tem permiss√£o para excluir chamados.\", \"error\")\n        return redirect(url_for(\"tickets.list_tickets\"))\n    \n    # Ticket deletion logic will be moved here\n    return redirect(url_for(\"tickets.list_tickets\"))","size_bytes":3045},"blueprints/users.py":{"content":"\"\"\"\nBlueprint for user management routes\n\"\"\"\nfrom flask import Blueprint, render_template, request, redirect, url_for, session, flash\nfrom models import User, db\nfrom werkzeug.security import generate_password_hash\nfrom functools import wraps\nimport json\n\nusers_bp = Blueprint('users', __name__, url_prefix='/usuarios')\n\ndef admin_required(f):\n    @wraps(f)\n    def decorated(*args, **kwargs):\n        if \"user_id\" not in session:\n            return redirect(url_for(\"auth.login\"))\n        \n        # Check if user has admin permissions\n        user_permissions = session.get(\"permissions\", [])\n        if \"manage_users\" not in user_permissions and session.get(\"role\") != \"admin\":\n            flash(\"Acesso negado.\", \"error\")\n            return redirect(url_for(\"main.dashboard\"))\n        return f(*args, **kwargs)\n    return decorated\n\n@users_bp.route(\"/\")\n@admin_required\ndef list_users():\n    users = User.query.all()\n    return render_template(\"admin/usuarios.html\", users=users)\n\n@users_bp.route(\"/novo\", methods=[\"GET\", \"POST\"])\n@admin_required\ndef create_user():\n    if request.method == \"POST\":\n        # User creation logic will be moved here\n        pass\n    return render_template(\"admin/novo_usuario.html\")\n\n@users_bp.route(\"/editar/<int:user_id>\", methods=[\"GET\", \"POST\"])\n@admin_required\ndef edit_user(user_id):\n    user = User.query.get_or_404(user_id)\n    if request.method == \"POST\":\n        # User editing logic will be moved here\n        pass\n    return render_template(\"admin/editar_usuario.html\", user=user)\n\n@users_bp.route(\"/excluir/<int:user_id>\")\n@admin_required\ndef delete_user(user_id):\n    # User deletion logic will be moved here\n    return redirect(url_for(\"users.list_users\"))","size_bytes":1707},"utils/__init__.py":{"content":"# Utils package","size_bytes":15},"utils/cache.py":{"content":"\"\"\"\nSimple caching utility for improved performance\n\"\"\"\nfrom flask import current_app\nimport time\nfrom functools import wraps\nimport json\nimport hashlib\n\nclass SimpleCache:\n    def __init__(self):\n        self.cache = {}\n        self.timeouts = {}\n    \n    def get(self, key):\n        \"\"\"Get value from cache\"\"\"\n        if key in self.cache:\n            # Check if expired\n            if key in self.timeouts and time.time() > self.timeouts[key]:\n                del self.cache[key]\n                del self.timeouts[key]\n                return None\n            return self.cache[key]\n        return None\n    \n    def set(self, key, value, timeout=300):\n        \"\"\"Set value in cache with timeout (default 5 minutes)\"\"\"\n        self.cache[key] = value\n        if timeout:\n            self.timeouts[key] = time.time() + timeout\n    \n    def delete(self, key):\n        \"\"\"Delete key from cache\"\"\"\n        if key in self.cache:\n            del self.cache[key]\n        if key in self.timeouts:\n            del self.timeouts[key]\n    \n    def clear(self):\n        \"\"\"Clear all cache\"\"\"\n        self.cache.clear()\n        self.timeouts.clear()\n\n# Global cache instance\ncache = SimpleCache()\n\ndef cached(timeout=300, key_prefix=''):\n    \"\"\"Decorator for caching function results\"\"\"\n    def decorator(f):\n        @wraps(f)\n        def decorated(*args, **kwargs):\n            # Generate cache key\n            key_data = f\"{key_prefix}:{f.__name__}:{str(args)}:{str(sorted(kwargs.items()))}\"\n            cache_key = hashlib.md5(key_data.encode()).hexdigest()\n            \n            # Try to get from cache\n            result = cache.get(cache_key)\n            if result is not None:\n                return result\n            \n            # Execute function and cache result\n            result = f(*args, **kwargs)\n            cache.set(cache_key, result, timeout)\n            return result\n        return decorated\n    return decorator","size_bytes":1927},"utils/rate_limiting.py":{"content":"\"\"\"\nRate limiting utility for security\n\"\"\"\nfrom flask import request, jsonify, flash, redirect, url_for\nfrom functools import wraps\nimport time\nfrom collections import defaultdict, deque\n\nclass RateLimiter:\n    def __init__(self):\n        # Store for each IP: deque of timestamps  \n        self.requests = defaultdict(deque)\n        # Store for login attempts per IP\n        self.login_attempts = defaultdict(deque)\n    \n    def is_allowed(self, key, max_requests=60, window=60):\n        \"\"\"Check if request is allowed (default: 60 requests per minute)\"\"\"\n        now = time.time()\n        \n        # Clean old requests outside window\n        while self.requests[key] and self.requests[key][0] < now - window:\n            self.requests[key].popleft()\n        \n        # Check if limit exceeded\n        if len(self.requests[key]) >= max_requests:\n            return False\n        \n        # Add current request\n        self.requests[key].append(now)\n        return True\n    \n    def is_login_allowed(self, ip, max_attempts=5, window=300):\n        \"\"\"Check login attempts (default: 5 attempts per 5 minutes)\"\"\"\n        now = time.time()\n        \n        # Clean old attempts\n        while self.login_attempts[ip] and self.login_attempts[ip][0] < now - window:\n            self.login_attempts[ip].popleft()\n        \n        return len(self.login_attempts[ip]) < max_attempts\n    \n    def record_login_attempt(self, ip):\n        \"\"\"Record a failed login attempt\"\"\"\n        self.login_attempts[ip].append(time.time())\n\n# Global rate limiter instance\nrate_limiter = RateLimiter()\n\ndef rate_limit(max_requests=60, window=60):\n    \"\"\"Decorator for rate limiting routes\"\"\"\n    def decorator(f):\n        @wraps(f)\n        def decorated(*args, **kwargs):\n            # Get client IP (handle proxy headers)\n            client_ip = request.environ.get('HTTP_X_FORWARDED_FOR', request.remote_addr)\n            if client_ip:\n                client_ip = client_ip.split(',')[0].strip()\n            \n            if not rate_limiter.is_allowed(client_ip, max_requests, window):\n                return jsonify({\n                    'error': 'Rate limit exceeded',\n                    'message': f'Maximum {max_requests} requests per {window} seconds'\n                }), 429\n            \n            return f(*args, **kwargs)\n        return decorated\n    return decorator\n\ndef login_rate_limit(max_attempts=5, window=300):\n    \"\"\"Decorator for login rate limiting\"\"\"\n    def decorator(f):\n        @wraps(f)\n        def decorated(*args, **kwargs):\n            client_ip = request.environ.get('HTTP_X_FORWARDED_FOR', request.remote_addr)\n            if client_ip:\n                client_ip = client_ip.split(',')[0].strip()\n            \n            if not rate_limiter.is_login_allowed(client_ip, max_attempts, window):\n                flash(f\"Muitas tentativas de login. Tente novamente em {window//60} minutos.\", \"error\")\n                return redirect(url_for('auth.login'))\n            \n            return f(*args, **kwargs)\n        return decorated\n    return decorator","size_bytes":3054}},"version":1}